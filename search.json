[{"title":"Crash Course Computer Science学习笔记","url":"/2025/10/09/Crash-Course-Computer-Science学习笔记/","content":"\n<!--more-->\n\n# 前言\n\n在我的研究生阶段，我开始学习编程，通过编程去参与实验室项目，对软件进行增删查改也使用设计模式去设计模块融入软件。但是我从未系统的了解过计算机的历史。 Crash Course Computer Science非常适合现在的我，它简单有趣、通俗易懂。感谢课程制造者以及字幕组。互联网的世界真是丰富多彩、妙不可言。\n\n\n\n在看完Crash Course Computer Science 的课程之后，我有一种豁然开朗的感觉。了解到计算机“成长”的历史，根据需求的不断创新以及在数学、科技、物理发展的促进下有了今天互联网的时代。\n\n从为了解决美国人口统计问题到如今离不开计算机，从使用齿轮--继电器控制电路--二极管三极管--晶体三极管，我们站在前人的肩膀上感受和体验科技发展带来的便利，同时也使我思考What can I do？事物的发展都不是一蹴而就的，是由许多微小的变化积累而来的，我也可以去解决一些小的问题，发展就是为了解决当下遇见的问题的。用计算机去处理重复性的劳动。\n\n抽象思想的学习和运用。 a new level of abstraction :)\n\n在这个课程之后我也拨开了计算机科学神秘的面纱，对其有了系统性的认识，虽然只是一个大概的认识。而我将继续利用互联网学习我感兴趣以及我需要系统性学习的知识。\n\n\n\n## Crash Course Computer Science简介\n\n在短短 8 个小时里非常生动且全面地科普了关于计算机科学的方方面面：计算机的历史、计算机是如何运作的、组成计算机的各个重要模块、计算机科学中的重要思想等等等等。Crash Course Computer Science（计算机科学速成课）共 40 集，整体遵循 “**从底层原理到上层应用，从技术本身到社会影响**” 的逻辑脉络。整个教程遵循 “**从‘是什么’（基础）→‘怎么做’（硬件 / 软件 / 算法）→‘连起来’（网络）→‘用在哪 / 怎么办’（应用 / 社会）** ” 的认知路径，从最底层的二进制到最前沿的量子计算，既覆盖计算机科学的核心知识点，也兼顾历史背景与现实意义，适合零基础学习者建立完整的计算机科学框架。\n\ngithub：https://github.com/1c7/crash-course-computer-science-chinese\n\n哔哩哔哩：https://www.bilibili.com/video/av21376839/\n\n\n\n## Carrie Anne老师\n\nwikipedia：[Carrie Anne Philbin - Wikipedia](https://en.wikipedia.org/wiki/Carrie_Anne_Philbin)\n\nCarrie Anne Philbin MBE是计算机科学的英语老师和作家。她是树莓派基金会（Raspberry Pi Foundation）的教育支持总监，并主持CASInclude校园计算（CAS）多样性和包容性小组。她为青少年撰写了计算书《 Raspberry Pi中的冒险》（2013年）。她负责管理YouTube频道Geek Gurl Diaries，并于2017年主持了速成课程计算机科学。\n\n**Carrie Anne Philbin** [MBE](https://en.wikipedia.org/wiki/Order_of_the_British_Empire) is an English teacher of [computer science](https://en.wikipedia.org/wiki/Computer_science) and an author. She is a director of educator support at the [Raspberry Pi Foundation](https://en.wikipedia.org/wiki/Raspberry_Pi_Foundation) and chairs the [Computing At School](https://en.wikipedia.org/w/index.php?title=Computing_At_School&action=edit&redlink=1) (CAS) diversity and inclusion group, *#CASInclude*. She wrote the computing book *Adventures in Raspberry Pi* (2013) for teenagers. She runs the YouTube channel *Geek Gurl Diaries* and in 2017, was the host for *[Crash Course](https://en.wikipedia.org/wiki/Crash_Course_(YouTube)) Computer Science*.\n\n\n\n# 笔记\n\n**参考以下**\n\n哔哩哔哩视频\n\ngithub\n\n哔哩哔哩视频下网友[叶子佩纳](https://space.bilibili.com/8705499)分享的思维导图 [百度网盘-整个思维导图-英文版](https://pan.baidu.com/s/1zEWE4G_IuxM8UxFTGyJisg) 提取码: mjyf \n\n[计算机科学速成课（计组部分）-p1-p10的思维导图](https://www.processon.com/view/link/61ef6e8f0e3e7439ae917672#map)\n\n[计算机科学速成课 - 知乎-全面](https://www.zhihu.com/column/c_1535311772248100864)\n\n[计算机科学速成课笔记 - 知乎-缺少p29-p33](https://zhuanlan.zhihu.com/p/460879375)\n\n[CS速成课笔记 | wzj042-只到ALU](https://blog.xqher.cn/post/3ac0a3d1be26/#参考链接)\n\n豆包老师\n\n\n\n整个课程的内容大致如下：\n\n1-9章:`计算机基本组成` - 从开关到逻辑门到CPU\n\n10-16章:`编程语言` - 编程方式语言发展，处理数据方法的发展\n\n17-23章:`操作系统与文件系统` - 怎样管理计算机与相关文件\n\n24-25章:`促进计算机发展的历史` - 战争与商业化对计算机的发展促进\n\n26-27章:`计算机图形界面` - 计算机与人交互方式的简化\n\n28-30章:`互联网组成` - 计算机数据交互方式的发展\n\n31-33章:`计算机安全` - 网络数据安全怎样受到挑战与保护手法\n\n34-40章:`计算机拓展应用` - 让计算机利用自身优势做的从与人类相似到超越人类\n\n\n\n1-27章: 计算机发展到从专注硬件到软件，专注于将计算机`贴近人类`\n\n28-40章:计算机网络与AI教育，专注于将计算机`超越人类`\n\n\n\n## 第 1 集：计算机早期历史  \n\n提到的设备：算盘 → 步进计算器 → 差分机 → 分析机 → 打孔卡片制表机  \n提到的人名：Charles Babbage, Ada Lovelace  \n\n02:27  最早的计算设备是算盘，举例如何使用  \n04:31  Computer 从指代职业变成指代机器  \n04:57  机器里有名的是：步进计算器。第一个可以做加减乘除的机器  \n06:44  炮弹为了精准，要计算弹道，二战是查表来做。但每次改设计了就需要做一张新表  \n07:30  Charles Babbage 提出了 &quot;差分机&quot;, 在构造差分机期间，想出了分析机, 分析机是通用计算机  \n08:50  Lovelace 给分析机写了假想程序，因此成为了第一位程序员  \n09:25  人口普查 10 年一次.  Herman Hollerith 的打孔卡片制表机大大提升了效率  \n\n\n## 第 2 集：电子计算机  \n\n提到的设备：继电器 → 真空管 → 晶体管  \n\n00:17  20世纪的发展要求更强的计算能力。柜子大小的计算机发展到房间大小  \n01:06  哈佛  Mark 1 号，IBM 1944 年做的  \n02:25  继电器，继电器一秒最多 50 次开关  \n03:24  继电器出 bug---bug说法的由来  \n03:49  1904 年，热电子管出现，第一个真空管。改进后变成和继电器的功能一样  \n05:34  &quot;巨人1号&quot; 计算机在英国 布莱切利园 首次大规模使用真空管。但编程麻烦，还要配置  \n06:40  1946 年，宾夕法尼亚大学的 ENIAC 是第一个通用可编程计算机  \n07:36  1947 年，贝尔实验室做出了晶体管，晶体管有诸多好处，IBM 很快全面转向晶体管  \n09:27  硅谷的典故：很多晶体管和半导体的开发都是这里做的。而生产半导体最常见的材料是硅  \n09:41  肖克利半导体 → 仙童半导体 → 英特尔  \n\n\n## 第 3 集：布尔逻辑和逻辑门  \n\n01:00  什么是二进制, 为什么用二进制, 布尔逻辑  \n02:46  3个基本操作：NOT，AND，OR  \n02:51  解释3个基本操作  \n07:11  XOR 异或  \n\n\n## 第 4 集：二进制  \n\n00:46  用十进制举例二进制的原理，演示二进制加法。存储单位 MB GB TB 等  \n05:30  正数，负数，整数，浮点数的表示  \n07:20  美国信息交换标准代码 - ASCII, 用来表示字符  \n09:00  UNICODE 1992 年诞生，是字符编码标准， 解决 ASCII 不够表达所有语言的问题  \n\n\n## 第 5 集：算数逻辑单元 - ALU  \n\n00:03  简单介绍 ALU ，英特尔 74181  \n01:24  ALU 有 2 个单元，1 个算术单元和 1 个逻辑单元    \n01:32  **算术单元**  \n半加器 (处理1个 bit，2个输入)  \n全加器 (处理1个 bit，3个输入)  \n8 bit 加法 (1个半加器，7个全加器）  \n溢出的概念，吃豆人的例子  \n乘法除法 \n07:32  **逻辑单元**  \n检测数字是否为 0 的电路（一堆 OR 门最后加个 NOT 门）  \nALU 抽象成一个 V 符号  \nFlag 标志（是否相等，是否小于，是否溢出等等）  \n\n\n## 第 6 集：寄存器和内存  \n\n本集重点是 Memory （存储 / 内存 两种含义）  \n\n03:30  存 1 位  (Gated Latch - 锁存器）  \n04:48  存 8 位  (Register - 寄存器)  \n\n05:46  16x16 的矩阵存 256 位  \n数据选择器/多路复用器 (Multiplexer) 解码 8 位地址，定位到单个锁存器  \n\n07:38  4 位代表行， 4 位代表列  \n\n08:16  组合 256 位内存 + 多路复用器  \n09:01  可寻址的 256 字节 内存  \n一条1980年代的内存，1M 大小  \n\n10:14  8个模块，每个模块有32个小方块，  \n每个小方块有 4 个小块，每个小块是 128 位 x 64 位  \n\n\n## 第 7 集：中央处理器（CPU)  \n\n重点  \n\n1. 拼个 CPU 出来  \n2. CPU 怎么执行命令  \n\n01:00  RAM + 寄存器 + ALU  做个 CPU  \n04:00  解释  &quot;取指令→解释→执行&quot; 这个循环  \n08:00  时钟是什么, 时钟速度和赫兹  \n10:00  超频提升性能, 降频省电  \n\n\n## 第 8 集：指令和程序  \n\n本集重点：一步步带你运行一遍程序  \n\n00:45  回顾上集的例子程序，一步步讲解。介绍”指令集”的概念  \nLOAD_A，LOAD_B，SUB，JUMP，ADD，HALT 等指令  \n05:16  带条件跳转，JUMP NEGATIVE 是负数才跳转，还有其他类型的 JUMP  \n08:00  真正现代 CPU 用更多指令集。位数更长。  \n09:07  1971年的英特尔 4004 处理器，有 46 个指令  \n09:36  如今英特尔酷睿 i7, 有上千条指令  \n\n\n\n## 第 9 集：高级 CPU 设计  \n\n00:24  早期是加快晶体管切换速度，来提升 CPU 速度  \n01:20  给 CPU 专门的除法电路 + 其他电路来做复杂操作，比如游戏，视频解码  \n02:28  给 CPU 加缓存，提高数据存取速度，更快喂给 CPU，用计算餐馆销售额举例  \n05:13  脏位 -  Dirty bit  \n05:33  流水线设计，用 1 个洗衣机和 1 个干燥机举例  \n06:01  并行处理 -  parallelize  \n07:33  乱序执行 -  out-of-order execution  \n08:21  推测执行 -  speculative execution  \n08:50  分支预测 -  branch prediction  \n09:34  多个 ALU  \n09:54  多核 (Core)  \n10:11  多个独立 CPU  \n10:52  超级计算机，中国的&quot;神威 太湖之光&quot;  \n\n\n## 第 10 集：早期的编程方式  \n\n本集重点：早期计算机如何编程  \n打孔纸卡 → 插线板 → 面板拨开关  \n\n00:00  开头说本集重点：程序如何进入计算机  \n00:53  拿纺织业举例，给机器编程的需求远在计算机出现前就有了  \n01:41  打孔纸卡 - Punched card  \n02:36  插线板 - Plugboard  \n04:20  冯诺依曼架构 - Von Neumann Architecture  \n07:00  面板编程 - Panel programming  \n07:29  第一款取得商业成功的家用计算机:  Altair 8800  \n08:15  编程依然很困难，人们需要更友好更简单的方式编程  \n08:44  下周主题：编程语言  \n\n\n## 第 11 集：编程语言发展史  \n\n编程：二进制 → 助记符（汇编器）→ A-0（编译器）→ FORTRAIN  \n\n01:45  二进制写程序，先纸上写伪代码，手工转二进制，很快就烦了  \n02:28  用 &quot;助记符” 写代码（LOAD_A 14）为了把助记符转二进制，汇编器诞生 (Assembler)  \n04:32  葛丽丝·霍普 (Grace Hopper)  - 哈佛1号计算机首批程序员, 海军军官  \n05:13  Grace 设计了编程语言 A-0  \n05:29  Grace 1952 年做了第一个编译器 (Compiler)，实现 A-0  \n06:29  变量 (Variables)  \n07:01  FORTRAN  \n08:18  COBOL  \n09:25  新语言  \n1960 年代：ALGOL，LISP，BASIC  \n1970 年代：Pascal，C，Smalltalk  \n1980 年代：C++，Objective-C，Perl  \n1990 年代：Python，Ruby，Java  \n\n\n## 第 12 集：编程基础 - 语句和函数  \n\n00:50  变量, 赋值语句  \n02:08  Grace Hopper 拍虫子游戏  \n02:52  if 判断  \n04:19  while 循环  \n05:48  for 循环  \n07:00  函数  \n11:11  下集介绍算法  \n\n\n## 第 13 集：算法入门  \n\n03:00  选择排序 - Selection sort  \n03:52  大 O 表示法 - Big O notation  \n04:31  归并排序 - Merge sort  \n08:03  Dijkstra 算法  \n\n\n## 第 14 集：数据结构  \n\n00:39   数组     - Array  \n02:06   字符串  - String  \n03:12   矩阵     - Matrix  \n04:05   结构体  - Struct  \n04:46   指针     - Pointer  \n04:44   节点     - Node  \n04:53   链表     - Linked List  \n06:21   队列     - Queue  \n06:21   栈        - Stack  \n07:31   树        - Tree  \n08:01   二叉树 - Binary Tree  \n08:26   图        - Graph  \n08:50   没时间讲红黑树和堆, 不同数据结构适用不同场景  \n\n\n## 第 15 集：阿兰·图灵  \n\n00:33   介绍图灵  \n00:52   可判定性问题  \n01:14   阿隆佐·丘奇，Lambda 算子  \n01:38   图灵机  \n04:54   停机问题  \n08:09   破解德军英格玛加密机  \n10:40   图灵测试  \n11:18   图灵的个人生活  \n12:07   图灵奖  \n\n\n## 第 16 集：软件工程  \n\n01:31  对象  Object  \n02:39  面向对象编程  Object Oriented Programming.  \n03:55  API  Application Programming Interface  \n04:33  public, private  \n05:36  集成开发环境, IDE - Integrated Development Environments  \n06:09  调试 debugging  \n06:31  文档和注释 - readme, comment  \n07:33  版本控制   Version control  \n08:50  质量控制   Quality Assurance testing，QA  \n09:21  Beta, Alpha  \n\n\n## 第 17 集：集成电路与摩尔定律  \n\n本集重点：晶圆的制作流程：光刻  (04:21~07:42)  \n\n00:51  分立元件  Discrete components  \n01:09  数字暴政  Tyranny of Numbers - 是 1960 年代工程师碰到的问题  \n意思是如果想加强电脑性能，就要更多部件，这导致更多线路，更复杂。所以很难做  \n04:21  光刻         Photolithography  \n04:26  晶圆         Wafer  \n04:57  光刻胶     Photoresist  \n05:08  光掩膜     Photomask  \n06:00  掺杂         Doping  \n09:09  摩尔定律   Moore’s Law.  \n09:38  英特尔      Intel  \n10:20  晶体管数量大幅度增长, 1980年三万个，1990年一百万个，2000年三千万个，2010年十亿个  \n11:44  进一步小型化会碰到 2 个问题  1. 光的波长不足以制作更精细的设计  2. 量子隧穿效应  \n\n\n## 第 18 集：操作系统  \n\n00:48  操作系统  Operating systems  \n01:34  批处理     Batch processing  \n01:58  计算机变便宜变多，有不同配置，写程序处理不同硬件细节很痛苦，因此操作系统负责抽象硬件  \n02:12  外部设备         Peripherals  \n02:48  设备驱动程序   Device drivers  \n04:43  多任务处理      Multitasking  \n05:54  虚拟内存         Virtual Memory  \n07:09  动态内存分配  Dynamic memory allocation  \n07:31  内存保护         Memory Protection  \n07:54  1970年代，计算机足够便宜，大学买了让学生用，多个学生用多个 &quot;终端&quot; 连接到主机  \n08:29  多用户分时操作系统，Multics  \n09:32  Unix  \n11:02  MS-DOS  \n12:09  下集是内存&amp;存储介质  \n\n\n## 第 19 集：内存&amp;储存介质  \n\n本集重点：存储技术的发展  \n\n01:01  纸卡                Paper punch cards  \n02:01  延迟线存储器  Delay Line Memory  \n04:06  磁芯               Magnetic Core Memory  \n06:08  磁带               Magnetic Tape  \n07:08  磁鼓               Magnetic Drum Memory  \n07:43  硬盘               Hard Disk Drives  \n08:53  内存层次结构  Memory Hierarchy  \n09:36  软盘                Floppy Disk  \n10:09  光盘                Compact Disk  \n10:51  固态硬盘         Solid State Drives  \n\n\n## 第 20 集：文件系统  \n\n00:47  文件格式：可以随便存文件数据，但按格式存会更方便  \n01:00  TXT   文本文件：ASCII  \n01:31  WAV 音频文件：每秒上千次的音频采样数字  \n02:47  BMP  图片文件：像素的红绿蓝 RGB 值  \n04:43  文件系统：很早期时空间小，整个存储器就像一整个文件。后来随容量增长，多文件非常必要  \n05:37  目录文件：用来解决多文件问题，存其他文件的信息，比如开头，结尾，创建时间等  \n06:39  平面文件系统 - Flat File System：文件都在同一个层次，早期空间小，只有十几个文件，平面系统够用  \n06:57  如果文件紧密的一个个前后排序会造成问题，所以文件系统会： 1. 把空间划分成一块块  2. 文件拆分存在多个块里  \n08:30  文件的增删改查会不可避免的造成文件散落在各个块里，如果是磁带这样的存储介质就会造成问题，所以做碎片整理  \n09:46  **分层文件系统** - Hierarchical File System：有不同文件夹，文件夹可以层层嵌套  \n\n第21集讲压缩  \n\n\n## 第 21 集：压缩  \n\n00:26  压缩的好处是能存更多文件，传输也更快  \n01:52  游程编码   Run-Length Encoding  \n02:45  无损压缩   Lossless compression  \n03:55  霍夫曼树   Huffman Tree  \n05:56  &quot;消除冗余&quot;和&quot;用更紧凑的表示方法&quot;，这两种方法通常会组合使用  \n06:07  字典编码   Dictionary coders,  游程编码 和 字典编码 都是无损压缩  \n08:03  感知编码   Perceptual coding  \n08:09  有损压缩   jpeg 格式  \n09:39  时间冗余   Temporal redundancy  \n10:30  MPEG-4 视频编码  \n\n\n## 第 22 集：命令行界面  \n\n**本集重点：**计算机早期同时输入程序和数据（用纸卡/纸带）  运行开始直到结束，中间没有人类进行操作，  原因是计算机很贵，不能等人类慢慢输入，执行完结果打印到纸上 (02:34)  \n\n到1950年代，计算机足够便宜+快，人类和计算机交互式操作变得可行，为了让人类输入到计算机，改造之前就有的打字机，变成电传打字机 (02:44~05:38)  \n\n到1970年代末，屏幕成本足够低，屏幕代替电传打字机，屏幕成为标配 (07:24)  \n\n00:32  人机交互  Human-Computer Interaction  \n00:50  早期输出数据是打印到纸上，而输入是用纸卡/纸带一次性把程序和数据都给进去  \n03:00  QWERTY  打字机的发展，克里斯托弗·莱瑟姆·肖尔斯 发明于 1868 年  \n05:38  电传打字机  Teletype machine  \n06:32  命令行界面  Command line interface  \n06:38  ls 命令  \n08:22  早期文字游戏  Zork  (1977年)  \n08:47  cd 命令  \n\n\n## 第 23 集：屏幕与 2D 图形显示  \n\n00:05   PDP-1 计算机。键盘和显示器分开，屏幕显示临时值  \n01:14   阴极射线管  Cathode Ray Tube (CRT)  \n01:38   CRT 有两种绘图方式：  矢量扫描  Vector Scanning  光栅扫描  Raster Scanning  \n02:14   液晶显示器   Liquid Crystal Displays (LCD)，像素 (Pixel)  \n03:32   字符生成器   Character generator  \n03:45   屏幕缓冲区   Screen buffer  \n05:09   矢量命令画图  \n06:34   Sketchpad,  光笔 (Light pen)  \n09:00   函数画线，矩形  \n\n\n## 第 24 集：冷战和消费主义  \n\n本集重点：冷战导致美国往计算机领域投入大量资源  (00:00~01:43)  \n\n范内瓦·布什 预见了计算机的潜力，提出假想机器 Memex  帮助建立 国家科学基金会，给科学研究提供资金  (01:43~03:43)  \n\n1950 年代消费者开始买晶体管设备，收音机大卖。日本取得晶体管授权后，索尼做了晶体管收音机，为日本半导体行业崛起埋下种子 (03:43~04:29）  \n\n苏联 1961 年把宇航员加加林送上太空，导致美国提出登月。NASA 预算大大增加，用集成电路来制作登月计算机 (04:29~06:27)  \n\n集成电路的发展实际上是由军事应用大大推进的，阿波罗登月毕竟只有 17 次。美国造超级计算机进一步推进集成电路 (04:29~07:11)  \n\n美国半导体行业一开始靠政府高利润合同活着，忽略消费者市场，1970年代冷战渐消，行业开始衰败。很多公司倒闭，英特尔转型处理器 (07:11~08:23)  \n\n末尾总结：政府和消费者推动了计算机的发展。早期靠政府资金，让技术发展到足够商用，然后消费者购买商用产品继续推动产品发展 (08:23~10:41)  \n\n\n## 第 25 集：个人计算机革命  \n\n本集：全是历史故事  \n00:18   1970年代初成本下降，个人计算机变得可行  \n01:51   Altair 8800  \n02:32   比尔·盖茨 和 保罗·艾伦写 BASIC 解释器  \n03:45   乔布斯提议卖组装好的计算机，Apple-I 诞生  \n04:40   1977年出现3款开箱即用计算机：\n&quot;Apple-II&quot;，&quot;TRS-80 Model I&quot;，&quot;Commodore PET 2001&quot;  \n06:26   IBM 意识到个人计算机市场。IBM PC 发布，采用开放架构，兼容的机器都叫 IBM Compatible (IBM 兼容) 。生态系统产生雪球效应：  因为用户多，软硬件开发人员更愿意花精力在这个平台。因为软硬件多，用户也更乐意买 &quot;IBM 兼容&quot; 的计算机  \n08:44   苹果选封闭架构，一切都自己来，只有苹果在非  &quot;IBM 兼容&quot; 下保持了足够市场份额  \n\n\n## 第 26 集：图形用户界面 (GUI)  \n\n01:10  图形界面先驱：道格拉斯·恩格尔巴特（Douglas Engelbart）  \n03:20  1970年成立 帕洛阿尔托研究中心（Palo Alto Research Center）  \n03:29  1973年完成 Xerox Alto(施乐奥托) 计算机  \n04:42  举例：写一个简单的 GUI 程序  \n06:38  1981年的 Xerox Star system(施乐之星系统)  \n08:18  史蒂夫·乔布斯去施乐参观  \n07:45  所见即所得 WYSIWYG  \n09:15  1983年推出 Apple Lisa  \n09:31  1984年推出 Macintosh  \n10:12  1985年推出 Windows 1.0，之后出到 3.1  \n10:43  1995年推出 Windows 95 提供图形界面  \n11:08  1995年微软做失败的 Microsoft Bob  \n\n\n## 第 27 集：3D 图形  \n\n01:15   线框渲染  Wireframe Rendering  \n01:39   正交投影  Orthographic Projection  \n01:50   透视投射  Perspective Projection  \n02:14   网格  Mesh  \n02:37   三角形更常用因为能定义唯一的平面  \n03:09   扫描线渲染  Scanline Rendering  \n05:04   遮挡            Occlusion  \n05:19   画家算法     Painter&apos;s Algorithm  \n06:09   深度缓冲      Z Buffering  \n07:45   Z Fighting 错误  \n07:51   背面剔除      Back Face Culling  \n08:53   表面法线      Surface Normal  \n09:33   平面着色      Flat Shading  \n09:43   高洛德着色   Gouraud shading,  冯氏着色  Phong Shading  \n10:06   纹理映射      Texture Mapping  \n11:24   图形处理单元  GPU, Graphics Processing Unit  \n\n\n## 第 28 集：计算机网络  \n\n02:05   局域网   Local Area Networks - LAN  \n02:36   媒体访问控制地址   Media Access Control address - MAC  \n02:55   载波侦听多路访问   Carrier Sense Multiple Access - CSMA  \n05:18   指数退避   Exponential Backoff  \n05:36   冲突域       Collision Domain  \n07:08   电路交换   Circuit Switching  \n07:36   报文交换   Message Switching  \n10:20   分组交换   Packet Switching  \n\n\n## 第 29 集：互联网  \n\n02:23  IP - 互联网协议 - Internet Protocol  \n03:00  UDP - 用户数据报协议 - User Datagram Protocol  \n03:41  校验和 - Checksum  \n05:26  TCP - 传输控制协议 - Transmission Control Protocol  \n08:21  DNS - 域名系统 - Domain Name System  \n10:47  OSI - 开放式系统互联通信参考模型 - Open System Interconnection  \n\n\n## 第 30 集：万维网  \n\n01:01  超链接  Hyperlinks  \n02:20  URL - 统一资源定位器 - Uniform Resource Locator  \n03:01  HTTP - 超文本传输协议 -  HyperText Transfer Protocol  \n04:13  HTML - 超文本标记语言  - HyperText Markup Language  \n04:24  写一个简单网页，用到了 &lt;h1&gt; &lt;a&gt; &lt;h2&gt; &lt;ol&gt; &lt;li&gt; 标签  \n06:04  第一个浏览器和服务器是 Tim Berners-Lee 花了 2 个月在 CERN 写的  \n06:32  1991年正式发布，万维网就此诞生  \n07:19  开始讲搜索引擎的故事  \n07:40  Jerry 和 David 的万维网指南 后来改名成 Yahoo  \n07:52  搜索引擎  JumpStation  \n09:07  搜索引擎  Google  \n09:20  网络中立性  \n\n\n## 第 31 集：计算机安全  \n\n01:00   Secrecy, Integrity, Availability  保密性, 完整性, 可用性  \n01:49   Threat Model 威胁模型  \n03:14   身份验证 (Authentication) 的三种方式：  \n\t\tWhat you know, 你知道什么  \n\t\tWhat you have, 你有什么  \n\t\tWhat you are, 你是什么  \n07:34   访问控制   Access Control  \n08:48   Bell LaPadula model  不能向上读取，不能向下写入  \n11:00   隔离 Isolation, 沙盒 Sandbox  \n\n\n## 第 32 集：黑客与攻击  \n\n01:28  社会工程学   Social Engineering  \n01:38  钓鱼             Phishing  \n02:06  假托             Pretexting  \n02:50  木马             Trojan Horses  \n03:32  NAND镜像  NAND Mirroring  \n04:12  漏洞利用      Exploit  \n04:16  缓冲区溢出   Buffer Overflow  \n05:45  边界检查      Bounds Checking  \n06:16  代码注入      Code Injection  \n09:32  零日漏洞      Zero Day Vulnerability  \n09:53  计算机蠕虫   Worms  \n09:58  僵尸网络      Botnet  \n10:11  拒绝服务攻击   DDoS  \n\n\n## 第 33 集：加密  \n\n00:16  多层防御  Defence in depth  \n01:00  加密 - Encryption，解密 - Decryption  \n01:11  凯撒加密  Caesar cipher  \n01:27  替换加密  Substitution cipher  \n01:59  移位加密  Permutation cipher  \n02:03  列移位加密  Columnar transposition cipher  \n02:37  德国 Enigma 加密机  \n04:54  1977年&quot;数据加密标准&quot; - Data Encryption Standard (DES)  \n05:24  2001年&quot;高级加密标准&quot; - Advanced Encryption Standard (AES)  \n07:06  密钥交换 - Key exchange  \n07:33  用颜色来举例&quot;单向函数&quot;和&quot;密钥加密&quot;的原理  \n08:24  迪菲-赫尔曼密钥交换 - Diffie-Hellman Key Exchange  \n10:18  非对称加密 - Asymmetric encryption  \n11:22  非对称加密算法  RSA  \n\n\n## 第 34 集：机器学习与人工智能  \n\n01:23   分类              Classification  \n01:25   分类器           Classifier  \n01:34   特征               Feature  \n02:03   标记数据        Labeled data  \n02:38   决策边界        Decision boundaries  \n03:00   混淆矩阵        Confusion matrix  \n03:39   未标签数据     Unlabeled data  \n03:49   决策树            Decision tree  \n04:25   支持向量机     Support Vector Machines  \n05:52  人工神经网络   Artificial Neural Network  \n08:34  深度学习         Deep learning  \n09:21  弱AI, 窄AI      Weak AI, Narrow AI  \n09:43  强AI               Strong AI  \n10:42  强化学习         Reinforcement Learning  \n\n\n## 第 35 集：计算机视觉  \n\n02:41  检测垂直边缘的算法  \n03:26  核/过滤器  kernel or filter  \n03:56  卷积 convolution  \n04:23  Prewitt 算子   Prewitt Operators  \n05:34  维奥拉·琼斯 人脸检测   Viola-Jones Face Detection  \n05:35  卷积神经网络   Convolutional Neural Networks  \n07:33  识别出脸之后，可以进一步用其他算法定位面部标志，如眼睛和眉毛具体位置，从而判断心情等信息  \n08:52  跟踪全身的标记点，如肩部，手臂等  \n\n\n## 第 36 集：自然语言处理  \n\n01:50  词性                   Parts of speech  \n02:15  短语结构规则      Phrase structure rules  \n02:32  分析树                Parse tree  \n05:30  语音识别             Speech recognition  \n07:26  谱图                    Spectrogram  \n07:44  快速傅立叶变换   Fast Fourier Transform  \n08:42  音素                   Phonemes  \n09:29   语音合成           Speech Synthesis  \n\n\n## 第 37 集：机器人  \n\n02:08  法国吃饭鸭 - Digesting Duck, Canard Digerateur  \n02:23  土耳其行棋傀儡, 下国际象棋  \n02:43  第一台计算机控制的机器出现在1940年代晚期，叫数控机器, Computer Numerical Control(CNC)  \n03:32  1960年 Unimate，第一个商业贩卖的 可编程工业机器人  \n03:47  简单控制回路  simple control loop  \n04:08  负反馈回路  negative feedback loop  \n05:17  比例-积分-微分控制器   Proportional–Integral–Derivative controller   PID 控制器  \n10:48  机器人三定律   Three Laws of Robotics  \n\n\n## 第 38 集：计算机心理学  \n\n00:45  我们需要了解人类心理学，做出更好的计算机  \n01:12  易用度 - Usability  \n01:31  颜色强度排序 和 颜色排序  \n02:30  分组更好记，电话号码 317-555-3897 比 3175553897 好记  \n03:25  直观功能 - Affordances  \n04:33  认出 vs 回想 Recognition vs Recall  \n05:45  让机器有一定情商以及 Facebook 的研究  \n08:40  用软件修正注视位置。让视频通话时看起来像盯着对方，而不是盯着下方  \n09:58  把机器人做的像人，恐怖谷理论  \n11:35  有很多开放式的问题，心理学帮助我们明白不同选择可能带来的影响  \n\n\n## 第 39 集：教育科技  \n\n02:15  通过调速，暂停等技巧，加强学习效率  \n03:15  大型开放式在线课程  - Massive Open Online Courses  (MOOC)  \n05:08  智能辅导系统 - Intelligent Tutoring Systems  \n05:22  判断规则 - Production rule  \n06:10  域模型 - Domain Model  \n06:46  贝叶斯知识追踪  Bayesian knowledge tracing  \n\n1. 学生已经学会的概率  \n2. 瞎猜的概率  \n3. 失误的概率  \n4. 做题过程中学会的概率 \n\n09:27  教育数据挖掘  Educational Data Mining  \n\n## 第 40 集：奇点，天网，计算机的未来 （完结）\n\n01:21  普适计算  Ubiquitous Computing  \n04:55  奇点          Singularity  \n06:51  把工作分为4个象限，讨论自动化带来的影响  \n10:15  机器人的存在时间可能长过人类，可以长时间探索宇宙  \n\n\n\n# 总结\n\n## 第一部分：计算机基础与历史\n\n本模块旨在回答 “什么是计算机” ，“计算机如何诞生”，搭建最基础的认知框架，核心是 “二进制” 与 “早期计算逻辑”。\n\n1. 计算机的本质与历史溯源\n   - 计算机的定义：能执行 “输入→处理→输出→存储” 循环的设备（不止电脑，手机、微波炉均是）\n   - 早期计算工具：算盘（手动计算辅助）、差分机（巴贝奇，首台机械计算雏形）、穿孔卡片机（用于人口普查等批量数据处理）\n   - 图灵与图灵机：图灵的核心贡献 ——“通用计算” 思想（任何可计算问题都能通过一套规则在抽象机器上实现）\n   - ENIAC：世界首台通用电子计算机（1946 年，用于二战弹道计算，体积庞大、功耗高）\n2. 二进制与信息表示\n   - 二进制的必要性：计算机硬件（晶体管）仅能识别 “通 / 断”（0/1），二进制是硬件与信息的桥梁\n   - 二进制与十进制、十六进制的转换逻辑（重点：位权概念）\n   - 信息的二进制编码：文本（ASCII、Unicode）、图像（像素与二进制颜色值）、声音（采样率与二进制振幅）\n\n## 第二部分：计算机硬件原理（物理基础）\n\n本模块拆解计算机的 “身体”，从最底层的 “晶体管” 到 “整机组件协同”，解释 “硬件如何实现计算”。\n\n1. 基础电子组件：从晶体管到逻辑门\n   - 晶体管：计算机的 “原子”—— 半导体材料制成，可实现 “开关” 功能（控制电流通断，对应 0/1）\n   - 逻辑门：由晶体管组成的 “计算单元”—— 与门（AND）、或门（OR）、非门（NOT）、异或门（XOR），实现基础逻辑运算\n   - 组合逻辑电路：多个逻辑门组合，实现更复杂运算（如加法器：半加器→全加器→ ripple carry adder）\n2. 核心硬件组件与功能\n   - CPU（中央处理器）：计算机的 “大脑”\n     - 结构：ALU（算术逻辑单元，执行加减乘除 / 逻辑运算）、控制单元（协调指令执行顺序）、寄存器（临时存储数据 / 指令，速度极快）\n     - 指令周期：取指（从内存拿指令）→译码（理解指令）→执行（ALU 运算）→写回（结果存回寄存器 / 内存）\n   - 内存与存储：计算机的 “记忆”\n     - RAM（随机存取存储器）：临时存储，断电数据丢失，速度快（配合 CPU 高速读写）\n     - ROM（只读存储器）：永久存储，断电数据不丢（如 BIOS，启动计算机的基础指令）\n     - 外部存储：硬盘（机械，容量大、速度慢）、SSD（固态硬盘，基于闪存，速度快、成本高）\n   - 输入 / 输出（I/O）设备：计算机与外界的 “接口”\n     - 输入：键盘、鼠标、摄像头（将物理信号转为电信号 / 二进制）\n     - 输出：显示器、打印机、音箱（将二进制转为物理信号）\n   - 总线（Bus）：硬件组件的 “高速公路”—— 地址总线（指定数据位置）、数据总线（传输数据）、控制总线（传递控制信号，如 “读 / 写” 命令）\n3. 硬件发展规律：**摩尔定律**\n   - 核心内容：每 18-24 个月，集成电路上可容纳的晶体管数量翻倍，性能也翻倍\n   - 影响：推动计算机从 “房间大小” 缩小到 “手掌大小”（手机），成本持续降低\n   - 挑战：物理极限（晶体管尺寸接近原子级，漏电问题凸显）\n\n## 第三部分：软件系统（控制硬件的 “灵魂”）\n\n本模块聚焦 “软件如何指挥硬件工作”，从操作系统到编程语言，解释 “抽象层如何降低使用门槛”。\n\n1. 操作系统（OS）：硬件与用户的 “中间层”\n   - 核心功能：进程管理（多任务调度，如同时打开浏览器 + 音乐）、内存管理（分配 RAM 空间，避免冲突）、设备管理（驱动程序，让 OS 识别打印机 / 显卡）、文件管理（组织硬盘数据，如文件夹、文件格式）\n   - 主流 OS：Windows（桌面端）、macOS（桌面端）、Linux（开源，服务器 / 嵌入式常用）、Android/iOS（移动端）\n   - 启动流程：BIOS→引导程序→加载 OS 内核→启动用户界面\n2. 编程语言与编译原理\n   - 编程语言的演进：从 “机器语言” 到 “高级语言”\n     - 机器语言：二进制指令（直接控制硬件，难写难读）\n     - 汇编语言：用英文缩写代替二进制（如 ADD 代表加法，仍依赖硬件架构）\n     - 高级语言：接近人类自然语言（如 Python、Java、C++），不依赖硬件，跨平台性强\n   - 编译与解释：将高级语言转为机器语言的工具\n     - 编译器：一次性将整个高级语言程序编译为机器码（如 C++，**运行速度快**）\n     - 解释器：逐行解释高级语言代码并执行（如 Python，**开发效率高，运行速度慢**）\n   - 编程范式：面向过程（按步骤执行，如 C）、**面向对象**（以 “对象” 为核心，如 Java，封装 / 继承 / 多态）\n3. 软件的层级结构：从内核到应用\n   - 底层：内核（OS 的核心，直接操作硬件）\n   - 中层：系统调用（应用程序调用 OS 功能的接口，如 “打开文件” 需调用 OS 的文件管理函数）\n   - 上层：应用程序（如浏览器、Office，用户直接操作的软件）\n\n## 第四部分：数据结构与算法（计算机解决问题的 “方法”）\n\n本模块是计算机科学的 “核心思维”，回答 “如何高效存储数据” “如何快速解决问题”，核心是 “效率”。\n\n1. 数据结构：组织数据的 “容器”\n   - 线性结构：数据按顺序排列\n     - 数组（Array）：连续内存空间，随机访问快（按索引找数据），插入 / 删除慢（需移动元素）\n     - 链表（Linked List）：非连续内存，通过指针连接，插入 / 删除快，随机访问慢\n     - 栈（Stack）：“先进后出”（如浏览器后退、函数调用栈）\n     - 队列（Queue）：“先进先出”（如打印机排队、消息队列）\n   - 非线性结构：数据多对多关联\n     - 树（Tree）：分层结构，**树是单向的，由根节点指向子节点**。如二叉树（每个节点最多 2 个子节点）、二叉搜索树（左子树 < 根 < 右子树，查找快）、堆（用于排序、优先队列）\n     - 图（Graph）：由节点和边组成（如社交网络、地图路径），分有向图 / 无向图、加权图 / 无权图。**图是可以有双向指向的**。\n2. 算法基础：解决问题的 “步骤”\n   - 基础算法：\n     - 排序算法：冒泡排序（简单但低效）、选择排序、插入排序、快速排序（分治思想，高效）、归并排序（稳定，适合大数据）\n     - 搜索算法：线性搜索（遍历所有元素，适用于无序数据）、二分搜索（仅适用于有序数据，效率高）\n   - 算法复杂度：衡量 “效率” 的标准\n     - 时间复杂度：算法执行时间随数据量增长的趋势（如 O (1) 常数、O (log n) 对数、O (n) 线性、O (n²) 平方）\n     - 空间复杂度：算法占用内存随数据量增长的趋势\n   - 常用算法思想：分治（大问题拆小问题）、递归（函数调用自身，如斐波那契数列）、动态规划（存储子问题结果，避免重复计算，如背包问题）\n\n## 第五部分：网络与互联网（计算机的 “连接”）\n\n本模块解释 “计算机如何互联互通”，从局域网到互联网，拆解网络协议与架构。\n\n1. 网络基础：从局域网到广域网\n   - 网络的定义：多台计算机通过通信设备（网卡、路由器）连接，实现数据共享\n   - 局域网（LAN）：小范围网络（如家庭 WiFi、公司内网），常用以太网（Ethernet）协议\n   - 广域网（WAN）：大范围网络（如跨城市连接），依赖光纤、卫星等长途传输介质\n2. 互联网（Internet）的核心：协议与架构\n   - 互联网的诞生：ARPANET（1969 年，美国军方项目，为抗故障设计的分布式网络）\n   - TCP/IP 协议簇：互联网的 “交通规则”\n     - IP（网际协议）：负责 “寻址”—— 给每台设备分配 IP 地址（如 IPv4：192.168.1.1），确定数据传输的 “目的地”\n     - TCP（传输控制协议）：负责 “可靠传输”—— 将数据拆分为数据包，确认接收（丢包重传），按顺序重组\n     - HTTP/HTTPS：应用层协议，用于浏览器与服务器通信（HTTPS 比 HTTP 多了加密，更安全）\n   - DNS（域名系统）：“IP 地址的翻译官”—— 将易记的域名（如[www.baidu.com](https://www.baidu.com/)）转为 IP 地址（如 180.101.49.12），避免用户记忆复杂 IP\n3. 网络安全基础\n   - 威胁类型：黑客攻击（如 DDOS：洪水般请求瘫痪服务器）、病毒（自我复制破坏数据）、钓鱼（伪装合法网站窃取信息）\n   - 防御手段：加密（如 SSL/TLS，保护数据传输）、防火墙（过滤非法网络请求）、密码哈希（存储密码时不存明文，存哈希值）\n\n## 第六部分：应用领域与社会影响（技术的 “落地与责任”）\n\n本模块将前面的技术知识与实际应用结合，并探讨技术带来的社会问题与未来趋势。\n\n1. 计算机的核心应用领域\n   - 数据库：存储海量结构化数据的系统\n     - 关系型数据库（如 MySQL、SQL Server）：用表格（行 / 列）存储，支持 SQL 查询，适合交易类数据（如银行转账）\n     - 非关系型数据库（如 MongoDB、Redis）：灵活存储非结构化数据（如社交软件的用户动态），适合高并发场景\n   - 人工智能（AI）基础：\n     - 机器学习：让计算机从数据中 “学习” 规律（如垃圾邮件识别、推荐系统）\n     - 神经网络：模拟人脑神经元结构，实现深度学习（如图像识别、语音助手）\n   - 计算机图形学：生成 / 处理图像的技术（如 3D 游戏渲染、电影特效，核心是 “像素计算” 与 “三维建模”）\n   - 嵌入式系统：嵌入到设备中的专用计算机（如智能手表、汽车控制系统，体积小、功能专一）\n2. 技术的社会影响与伦理\n   - 隐私问题：数据收集（如 APP 获取位置 / 通讯录）、数据滥用（如精准广告、身份泄露）\n   - 数字鸿沟：不同地区 / 人群在获取计算机 / 网络资源上的差距（如农村与城市的网络覆盖率）\n   - AI 伦理：算法偏见（如招聘 AI 因训练数据偏向男性而歧视女性）、自动化替代工作（如工厂机器人替代工人）\n3. 未来趋势：突破现有极限\n   - 量子计算：基于量子力学（叠加态、纠缠态），解决传统计算机难以处理的问题（如密码破解、药物研发）\n   - 量子互联网：利用量子纠缠实现 “绝对安全” 的通信（任何窃听都会改变量子状态，可被察觉）\n   - 边缘计算：将计算任务从 “云端” 转移到 “设备端”（如智能家居、自动驾驶），降低延迟，保护隐私\n","tags":["Computer Science","CS"],"categories":["Study Notes"]},{"title":"static和const修饰符被设计的原因和使用方法","url":"/2025/09/16/static和const修饰符被设计的原因和使用方法/","content":"\n<!--more-->\n\n# 背景：\n\n写代码这一年多以来，或多或少都有在使用这些修饰符。但是感觉还是却一点什么东西，有点好奇为什么要有这些修饰符，没有会怎么样。于是有了这篇博客。做一次总结。\n\n\n\n# static：\n\n`static` 在 C++ 中确实非常重要，它并不是随意设计的语法糖，而是解决了 C 语言（C++ 的祖先）在**存储期、作用域、链接属性**上的一系列核心问题。\n\n## **static 被创造的原因**\n\n`static` 最早出现在 **C 语言里**，C++ 沿用了它。它的主要目的是**在编译期/链接期明确某个符号或变量的存储周期和可见性**，以解决三个核心问题：\n\n**变量的生命周期问题**\n\n- 默认情况下，局部变量在函数调用时创建、函数退出时销毁。\n- 但有时我们希望“函数的某些状态”能**跨调用保存**，而又不想放到全局变量里（污染命名空间）。\n- `static` 局部变量 = **只初始化一次，直到程序结束才销毁**。\n\n👉 这是为了支持**状态保持**（stateful function）。\n\n**符号的可见性问题**\n\n- 在 C 语言里，多个 `.c` 文件会链接在一起。\n- 如果你在多个文件里都定义了一个同名函数或全局变量，会冲突。\n- `static` 修饰全局变量或函数 → 让它们只在**本翻译单元（.cpp 文件）可见**，避免链接冲突。\n\n👉 这是为了支持**模块化编程**。\n\n**与类的结合（C++ 新增的语义）**\n\n- C++ 里引入了类，`static` 成为了类成员的重要修饰符：\n  - `static` 成员变量 → **属于类而不是对象**（所有对象共享一份）。\n  - `static` 成员函数 → **不依赖对象实例即可调用**。\n\n👉 这是为了支持**面向对象中的共享数据与工具函数**。\n\n\n\n### 总结：\n\nstatic 在C语言中是为了解决**变量周期**和**同名函数或者变量的冲突问题**而设计的。而在C++中又有与类的结合，实现不依赖对象而属于类的成员变量和成员函数。\n\n\n\n## static的重要性\n\n`static` 之所以被创造并保留到现在，是因为它解决了**模块化编程**和**状态管理**的核心痛点：\n\n- 没有 `static`，所有函数和变量要么全局可见（容易冲突），要么局部且无法持久（无法跨调用保存状态）。\n- `static` 刚好填补了这两者之间的空缺：\n  - **局部但持久**（局部 static 变量）；\n  - **全局但私有**（文件内 static 全局变量/函数）；\n  - **类级别共享**（static 类成员）。\n\n可以说，**没有 `static`，C++ 的模块化和面向对象都会大打折扣**。\n\n\n\n## static常见的使用场景\n\n### static对于局部变量\n\n在局部变量之前加上关键字static，局部变量就被定义成为一个局部静态变量。\n\n内存中的位置：data段\n\n初始化：局部的静态变量只能被初始化一次\n\n作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域随之结束。\n\n> 当static用来修饰局部变量的时候，它就**改变了局部变量的存储位置（从原来的栈中存放改为静态存储区）及其生命周期（局部静态变量在离开作用域之后，并没有被销毁，而是仍然驻留在内存当中，直到程序结束，只不过我们不能再对他进行访问），但未改变其作用域。**\n\ne.g.\n\n```\nvoid f() {\n\tint a = 0;\n\tstatic int b = 0;\n\ta++;\n\tb++;\n\tstd::cout <<  a << \",\" << b << std::endl;\n}\n\nvoid demo(){\n\tf();\n\tf();\n\tf();\n}\n```\n\n输出\n\n```\n1，1\n1，2\n1，3\n```\n\n### static对于全局变量/函数\n\n在全局变量之前加上关键字static，全局变量就被定义成为一个全局静态变量。\n\n内存中的位置：静态存储区（静态存储区在整个程序运行期间都存在）\n\n初始化：未经初始化的全局静态变量会被程序自动初始化为0\n\n作用域：**全局静态变量在声明他的文件之外是不可见的**。准确地讲从定义之处开始到文件结尾**。(只能在本文件中存在和使用**)\n\n>  全局变量本身就是静态存储方式， 静态全局变量当然也是静态存储方式。两者的区别在于非静态全局变量的作用域是整个源程序， 当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的（在其他源文件中使用时加上extern关键字重新声明即可）。 而**静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它**。\n\n\n\n修饰普通函数，表明函数的作用范围，**仅在定义该函数的文件内才能使用**。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static。（和全局变量一样限制了作用域而已）\n\n\n\n### **static对于类**\n\n1. 成员变量\n\n   用static修饰类的数据成员实际使**其成为类的全局变量，会被类的所有对象共享，包括派生类的对象。**\n\n   因此，**static成员必须在类外进行初始化，而不能在构造函数内进行初始化。不过也可以用const修饰static数据成员在类内初始化 。**\n\n2. 成员函数\n\n   用static修饰成员函数，使这个类只存在这一份函数，所有对象共享该函数，**不含this指针**。\n\n   静态成员是可以独立访问的，也就是说，无须创建任何对象实例就可以访问。\n\n   **不可以同时用const和static修饰成员函数。**\n\n\n\n\n\n# const:---只读\n\n## **const 被创造的原因**\n\n在 C 语言早期，所有变量几乎都是可修改的，这带来了几个问题：\n\n1. **表达力不足**\n   - 程序员想要声明一个“常量”（例如 π=3.14159），结果只能用 `#define PI 3.14159`。\n   - 但是 `#define` 只是预处理替换，没有类型检查，很危险。\n   - `const` 被创造出来，就是为了提供 **类型安全的常量**。\n2. **接口安全**\n   - 在函数参数中，如果只需要读数据，但又传了个指针/引用，调用者可能无意修改数据。\n   - `const` 可以在函数签名中**表达只读约束**，避免误改，提高安全性。\n3. **编译器优化**\n   - 如果某个变量被标记为 `const`，编译器就能大胆地进行优化（例如放在只读区，寄存器优化，消除冗余写操作）。\n\n👉 总结一句：**const 被创造出来是为了解决 \"定义真正的常量 + 限制不必要的修改 + 提升类型安全与优化空间\"。**\n\n### 总结：\n\nconst在定义常量方面比#define好，因为能够进行类型检查，const能区分函数/对象是否会修改数据，增强了代码的可读性、可维护性，能够提高编译器的优化机会。\n\n\n\n## const常见的使用场景\n\n### **定义常量**\n\nconst修饰变量：限定变量为不可修改。\n\n```\nconst double PI = 3.14159;  \n```\n\n- **场景**：替代 `#define`，用于数学常量、配置参数等。\n- **意义**：\n  - **类型安全（编译器能检查类型）**\n  - 有作用域，不会全局污染\n  - 不可修改，避免误操作\n\n\n\n### **指针修饰：区分只读数据 vs 固定地址**\n\n```\nconst int* p1;   // 不能改 *p1----常量指针\nint* const p2;   // 不能改 p2-----指针常量\nconst int* const p3; // 两者都不能改\n```\n\n- **场景**：\n  - `const int*` → 指向只读数据（保护数据）\n  - `int* const` → 固定指针（保证地址不变）\n- **意义**：更精确地表达“修改权限”。\n\n**注意：左定值右定向**\n\n\n\n### const和函数：\n\n#### **函数参数：只读引用**\n\n```\nvoid print(const std::string& s) {\n    std::cout << s << std::endl;\n}\n```\n\n- **场景**：函数只需要读取数据，不会修改它（打印、计算哈希等）。\n- **意义**：\n  - 避免拷贝，提高效率\n  - 明确告诉调用者“不会修改”\n  - 调用者更放心传对象\n\n```c++\nconst int& fun(int& a); //修饰返回值--------返回值是一个const修饰的变量\n```\n\n### const和类：\n\n①**const修饰成员变量**，在某个对象的声明周期内是常量，但是对于整个类而言是可以改变的。因为类可以创建多个对象，**不同的对象其const成员变量的值是不同的**。\n\n切记，**不能在类内初始化const成员变量**，因为类的对象没创建前，编译器并不知道const成员变量是什么，因此const数据成员只能在初始化列表中初始化。\n\n```\nclass A {\n    const int id;   // 必须在构造函数初始化\npublic:\n    A(int i) : id(i) {}\n};\n```\n\n②**const修饰成员函数**，主要目的是防止成员函数修改成员变量的值，即该**成员函数并不能修改成员变量。**\n\n```\nint& fun(int& a) const{} //const成员函数----函数不会修改成员变量\n```\n\n\n\n### **const 对象**：\n\n```\nconst Person p(\"Alice\");  \np.getName();   // ✅\np.setName(\"Bob\"); // ❌\n```\n\n- **场景**：当你只需要读取对象，不希望修改它。\n- **意义**：\n  - 强制接口使用只读模式\n  - 提高代码的健壮性\n\n\n\n### 总结：\n\nconst修饰是用来表达  **只读** 的。能修饰变量、指针、类的成员函数、函数的返回值等等。能够**明确表达“不变性”**\n\n\n\n\n\n# 总结：\n\nstatic的意义是，为了解决**变量周期**和**同名函数或者变量的冲突问题**\n\nconst的意义是，定义能够**进行类型检查常量**，c区分函数/对象是否会修改数据，增强了代码的可读性、可维护性，能够提高编译器的优化机会。\n\n使用方面要从修饰的不同类型来分析。都是 变量、指针、函数、以及在类中的使用。\n","tags":["C++"],"categories":["C++"]},{"title":"基于Opencv实现张正友标定法以及机器人手眼标定","url":"/2025/09/11/基于Opencv实现张正友标定法以及机器人手眼标定/","content":"\n<!--more-->\n\n# OpenCV简要介绍\n\nOpenCV（全称 **Open Source Computer Vision Library**）是由英特尔发起并由社区维护的**跨平台、开源计算机视觉与机器学习库**，核心目标是为开发者提供通用、高效的计算机视觉解决方案。\n\n## OpenCV 核心特点\n\n1. **开源与免费**\n   OpenCV 是一个开源项目，任何人都可以免费使用、修改和分发其代码。这意味着你可以根据需要对 OpenCV 进行定制化修改。\n2. **跨平台支持**\n   OpenCV 支持多个操作系统平台，包括 Windows、Linux、macOS、Android 和 iOS。你可以在各种设备上使用 OpenCV，包括桌面、服务器以及移动设备。\n3. **支持多种编程语言**\n   OpenCV 提供了多种编程语言的接口，支持 C++、Python、Java、JavaScript 和 MATLAB 等多种编程语言。因此，无论你是 C++ 开发者还是 Python 爱好者，都能轻松使用 OpenCV。\n4. **强大的功能库**\n   OpenCV 提供了数百个优化的算法，涵盖了计算机视觉和图像处理的方方面面。以下是一些常见的应用：\n   - **图像处理：** 图像滤波、边缘检测、颜色空间转换、形态学操作、特征提取等。\n   - **视频分析：** 视频捕捉、运动分析、物体检测与追踪等。\n   - **机器学习与人工智能：** OpenCV 集成了深度学习框架，可以进行人脸识别、目标检测、图像分类等。\n   - **计算机视觉：** 图像匹配、物体识别、立体视觉、深度图计算等。\n5. **高效的性能**\n   OpenCV 内置的许多算法都经过高度优化，支持硬件加速（如 Intel 的 TBB、OpenCL、CUDA 等技术），使得它在处理复杂计算时具备高性能，尤其在处理视频流和实时图像分析时非常高效。\n\n\n\n## OpenCV中的相机标定\n\n经过之前的介绍，我们已经知道了在相机标定中需要求解的有内参、畸变系数、外参。\n\n### opencv中标定核心函数\n\n#### **计算内参和畸变系数：**\n\n采用基于已知标定物的标定方法：**张正友标定法**\n\n- 原理：只需一块平面棋盘格，拍摄多张不同姿态的图片。\n- 步骤：\n  1. 检测棋盘格角点（得到二维像素点 (u,v）\n  2. 知道棋盘格格点的三维世界坐标 (X,Y,0)\n  3. 建立二维–三维对应关系，先线性估计相机参数\n  4. 再通过非线性优化（最小化重投影误差）精确求解内参、畸变系数、外参\n\n##### **整个流程：**\n\n###### 1.设置标定板类型  \n\n​\tcv::Size 注意在opencv中是角点数量而不是格子数量。例如： 12 * 9 标定板的角点数是 11 *  8\n\n###### 2.从路径中加载图片 \n\n​\t用 std::vector < cv::Mat >&  images 保存图片。读取图片的方法为 cv::Mat img = cv::imread(fullPath, cv::IMREAD_COLOR);\n\n###### 3.检测角点 ----要先转灰度图。\n\n\tCV_EXPORTS_W bool findChessboardCorners( InputArray image, Size patternSize, OutputArray corners,\n\t                                     int flags = CALIB_CB_ADAPTIVE_THRESH + CALIB_CB_NORMALIZE_IMAGE );\n\n###### 4.亚像素级角点优化（提高精度）\n\n```\ncase HPLPatternType::CHESSBOARD:\n\t\tfound = cv::findChessboardCorners(gray, patternSize, imagePoints,\n\t\t\tcv::CALIB_CB_ADAPTIVE_THRESH | cv::CALIB_CB_NORMALIZE_IMAGE);\n\n\t\tif (found) {\n\t\t\tcv::cornerSubPix(gray, imagePoints, cv::Size(11, 11), cv::Size(-1, -1),\n\t\t\t\tcv::TermCriteria(cv::TermCriteria::EPS + cv::TermCriteria::MAX_ITER, 30, 0.001));\n\t\t\tstd::cout << imagePoints.size() << \"  \";\n\t\t}\n\t\tbreak;\n\n```\n\n- **前提**：只有当角点检测成功（`found`为`true`）时，才进行后续优化。\n\n- **`cv::cornerSubPix`功能**：将初步检测到的像素级角点优化到**亚像素级别**（精度可达 0.1 像素以内），这是提高后续标定（如相机内参、手眼矩阵）精度的关键步骤。\n\n- 参数说明：\n\n  - `gray`：输入灰度图（用于计算梯度信息，辅助亚像素定位）。\n\n  - `imagePoints`：输入输出参数，传入初步检测的角点，输出优化后的亚像素角点。\n\n  - `cv::Size(11, 11)`：搜索窗口大小（11×11 像素），表示在该范围内寻找更精确的角点位置。\n\n  - `cv::Size(-1, -1)`：死区大小（此处设为负，表示无死区，即使用整个搜索窗口计算）。\n\n  - 终止条件\n\n    ```\n    TermCriteria\n    ```\n\n    - `EPS + MAX_ITER`：满足 “精度阈值” 或 “最大迭代次数” 任一条件即停止优化。\n    - `30`：最大迭代次数（最多迭代 30 次）。\n    - `0.001`：精度阈值（当角点位置变化小于 0.001 像素时，停止优化）。\n\n###### 5.根据标定板的参数生成理想的**物理点**\n\n​\t核心是为了让生成的**三维物体点坐标顺序**与**图像中检测到的角点顺序**保持一致，确保后续标定过程中 “三维物体点” 与 “二维图像点” 能正确匹配。\n\n```\nint rows = boardSize.height;\nint cols = boardSize.width;\n\ncase HPLPatternType::CHESSBOARD:\n\t\t// 生成 (j, i) 格子对应的三维坐标 (单位：size)\n\t\tfor (size_t i = 0; i < rows; ++i) {\n\t\t\tfor (int j = 0; j < cols; ++j) {\n\t\t\t\tm_objPts.emplace_back(j * spacing, i * spacing, 0);\n\t\t\t}\n\t\t}\n\t\tbreak;\n```\n\n​\t双重循环即可，需要注意的是：\n\n​\t\t**1.棋盘格的坐标系统定义**\n\n​\t\t标定板（棋盘格）的三维坐标系通常这样定义：原点（0,0,0）设在棋盘格**左上角的第一个内角点**；**x 轴**沿水平方向（从左到右，对应 “列方向”）；**y 轴**沿垂直方向（从上到下，对应 “行方向”）；**z 轴**垂直于标定板平面（所有点 z=0，因为棋盘格是平面）。\n\n​\t\t**2.循环顺序与点的排列顺序**\n\n​\t\t代码中：外层循环`i`：遍历棋盘格的**行数**（`rows = boardSize.height`），对应 y 轴方向（从上到下）；\n\n​\t\t\t\t内层循环`j`：遍历棋盘格的**列数**（`cols = boardSize.width`），对应 x 轴方向（从左到右）。\n\n​\t\t\t\t生成的三维坐标是 `(j * spacing, i * spacing, 0)`，即：\n\n​\t\t\t\t对于第`i`行、第`j`列的内角点，x 坐标由列索引`j`决定（水平方向），y 坐标由行索引`i`决定（垂直方向）。\n\n​\t\t\t\t这样生成的`m_objPts`中，点的顺序是 **“按行排列”**：先排完第 0 行的所有列（j 从 0 到 cols-1），再排第 1 行的所有列，以此类推。\n\n​\t\t**3. 与图像角点检测顺序匹配**\n\n​\t\t关键原因是：**图像中检测到的角点顺序也是 “按行排列” 的**。\n在之前的`findChessboardCorners`函数中，检测到的`imagePoints`（二维图像角点）顺序是**从左到右、从上到下**（先扫完一行，再扫下一行），与上述三维物体点的排列顺序完全一致。\n\n​\t\t如果循环顺序反过来（外层 j、内层 i），会导致三维物体点 “按列排列”，与二维图像点的顺序不匹配，后续标定（如`calibrateCamera`）时会因 “点对应错误” 导致结果失效。\n\n​\t\t**总结**\n\n​\t\t循环的内外层顺序（先 i 后 j）是为了保证：**三维物体点的排列顺序 ↔ 二维图像角点的检测顺序** 严格一致。\n​\t\t这种一致性是相机标定、位姿估计的核心前提 —— 只有每个二维图像点都能准确对应到唯一的三维物体点，才能通过几何关系求解相机内参或位姿矩阵。\n\n\n\n###### 6.调用函数\n\n主要使用的函数： \n\n```cpp\n/** @overload */\nCV_EXPORTS_W double calibrateCamera( InputArrayOfArrays objectPoints,\n                                     InputArrayOfArrays imagePoints, Size imageSize,\n                                     InputOutputArray cameraMatrix, InputOutputArray distCoeffs,\n                                     OutputArrayOfArrays rvecs, OutputArrayOfArrays tvecs,\n                                     int flags = 0, TermCriteria criteria = TermCriteria(\n                                        TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON) );\n\n// 我的调用\ndouble rms = cv::calibrateCamera(m_objectPoints, m_imagePoints, m_imageSize,\n    cameraMatrix, distCoeffs, rvecs, tvecs, cv::CALIB_FIX_K3);\n```\n\n主要功能是通过标定板图像的特征点，求解相机的内参矩阵（Camera Matrix）和畸变系数（Distortion Coefficients），并评估标定精度。\n\n- 参数说明：\n  - `m_objectPoints`/`m_imagePoints`：三维物体点和二维图像点的对应关系（核心输入）。\n  - `m_imageSize`：图像尺寸（宽 x 高），用于辅助计算。\n  - `cameraMatrix`/`distCoeffs`：输出参数，存储求解得到的内参矩阵和畸变系数。\n  - `rvecs`/`tvecs`：输出参数，存储每幅图像对应的旋转 / 平移向量。\n  - `cv::CALIB_FIX_K3`：标定标志，含义是 “固定畸变系数中的 k3 为 0”（简化模型，适用于畸变较小的场景）。\n- 返回值`rms`：重投影误差的均方根（Root Mean Square），是评估标定精度的核心指标（值越小越好，通常希望小于 1 像素）。\n\n\n\n###### 7.实验和误差计算\n\n![image-20250915140726971](基于Opencv实现张正友标定法以及机器人手眼标定/image-20250915140726971.png)\n\n可以求总的RMS 和每张图片的RMS\n\n![image-20250915140056602](基于Opencv实现张正友标定法以及机器人手眼标定/image-20250915140056602.png)\n\n#### **计算外参：**\n\n根据之前的介绍我们知道，外参就是描述相机在世界坐标系下的位姿，在机器人手眼标定中，其实就是描述相机在机器人基座标系下的位姿。\n\n而在机器人手眼标定中，又分为两种：眼在手上、眼在手外。\n\n![image-20250915142546676](基于Opencv实现张正友标定法以及机器人手眼标定/image-20250915142546676.png)\n\n##### 眼在手上：\n\n相机直接安装在机器人末端执行器上，与机械臂同步运动。此时，相机“看到”的场景会随着机械臂的移动而变化。\n\n![image-20250915142507063](基于Opencv实现张正友标定法以及机器人手眼标定/image-20250915142507063.png)\n\n##### 眼在手外：\n\n相机安装在机器人之外的一个固定地方。不会随着机器人运动而运动。\n\n\n\n![image-20250915154051347](基于Opencv实现张正友标定法以及机器人手眼标定/image-20250915154051347.png)\n\n##### **安装方式不同带来的影响：**\n\n手眼标定的核心是建立 “相机坐标系” 与 “机器人基坐标系” 的转换关系，但相机与机器人的安装方式会改变位姿数据的物理意义：\n\n- **`EyeInHand`（眼在手上）**：\n  相机固定在机器人末端（夹爪）上，随机器人一起运动。此时，标定板固定在外部（如桌面），相机拍摄的是固定的标定板。\n  机器人提供的位姿数据（`robotPoseList`）是 “**夹爪坐标系 → 机器人基坐标系**” 的转换（`R_gripper2base, t_gripper2base`），这正是手眼标定需要的位姿关系（因为相机与夹爪刚性连接，两者相对位姿不变）。\n- **`EyeToHand`（眼在手外）**：\n  相机固定在外部（如支架上），不随机器人运动。此时，标定板固定在机器人末端（夹爪）上，随机器人一起运动。\n  机器人提供的位姿数据（`robotPoseList`）仍是 “**夹爪坐标系 → 机器人基坐标系**” 的转换，但手眼标定需要的是 “**机器人基坐标系 → 夹爪坐标系**” 的转换（因为标定板随夹爪运动，相机观察的是运动的标定板）。\n\n手眼标定算法（如`cv::calibrateHandEye`）要求输入的位姿数据必须满足 “**运动端与固定端的对应关系**”：\n\n- 对于`EyeInHand`：运动端是 “夹爪 + 相机”，固定端是 “标定板”，需要 “夹爪→基” 的位姿；\n- 对于`EyeToHand`：运动端是 “夹爪 + 标定板”，固定端是 “相机”，需要 “基→夹爪” 的位姿（与机器人原始数据方向相反）。\n\n因此，`EyeToHand`需要对原始位姿做**逆变换**，将 “夹爪→基” 转换为 “基→夹爪”：\n\n**旋转矩阵`R`的处理（转置）**\n\n旋转矩阵的 “逆变换” 等价于 “转置”（因为旋转矩阵是正交矩阵，其逆矩阵 = 转置矩阵）：\n\n- 原始旋转矩阵`R_gripper2base`：表示 “夹爪→基” 的旋转；\n- 逆变换后`Rt = R.t()`：表示 “基→夹爪” 的旋转（即`R_base2gripper`）。\n\n**平移向量`t`的处理（反向变换）**\n\n平移向量的逆变换需要结合旋转矩阵：\n\n- 原始平移向量`t_gripper2base`：表示 “夹爪原点在基坐标系中的坐标”；\n- 逆变换后`t_inv = -Rt * t`：表示 “基原点在夹爪坐标系中的坐标”（即`t_base2gripper`）。\n\n推导逻辑：若`P_base = R * P_gripper + t`（夹爪坐标→基坐标），则逆变换为`P_gripper = R.t() * (P_base - t) = R.t() * P_base - R.t() * t`，因此 “基→夹爪” 的平移向量为`-R.t() * t`。\n\n**总结**\n\n两种安装方式下对`R`和`t`的处理不同，本质是为了**统一位姿数据的方向**，确保输入到手眼标定算法中的位姿关系符合 **“运动端→固定端”** 的逻辑：\n\n- `EyeInHand`：直接使用 “夹爪→基” 的位姿（与运动方向一致）；\n- `EyeToHand`：通过逆变换将 “夹爪→基” 转为 “基→夹爪” 的位姿（修正方向以匹配运动逻辑）。\n\n\n\n##### 整个流程：\n\n###### 1.设置标定板类型\n\n###### 2.加载图片\n\n###### 3.使用之前计算出来的内参和畸变系数进行图片矫正\n\n```\n\t// 利用标定好的内参，对输入的相片进行图像校正（去除畸变，还原真实世界视角）\n\tstd::cout << \"UndistoredImage:\" << std::endl;\n\n\tfor (int i = 0; i < m_vMatImages.size(); i++)\n\t{\n\t\tcv::Mat Matundistorted;\n\t\tundistort(m_vMatImages[i], Matundistorted, m_cameraMatrix, m_distCoeffs);\n\t\tm_vMatundistortedImg.push_back(Matundistorted);\n\t}\n}\n```\n\n###### 4.对矫正之后的图像检测角点\n\n###### 5.生成理想的物理点\n\n###### 6.处理机器人末端数据---求解gripper2base（运动到固定）\n\n注意：这里要根据安装方式的不同去不同地处理  参考上面的“ 安装方式不同带来的影响”\n\n```\n\t\t// 1. 提取平移向量\n\t\tcv::Mat tvec = (cv::Mat_<double>(3, 1) << pose.x(), pose.y(), pose.z());\n\n\t\t// 2. 提取欧拉角并转为 Mat  单位：角度\n\t\tcv::Mat euler = (cv::Mat_<double>(1, 3) << pose.r1(), pose.r2(), pose.r3());\n\t\t//std::cout << \"Pose \" << i << \": \"\n\t\t//\t<< \"T=(\" << tvec << \"),, \"\n\t\t//\t<< \"euler=(\" << euler << \"),,\" << std::endl;\n\n\t\t// 3. 计算旋转矩阵\n\t\tcv::Mat rmat = eulerAngleToRotateMatrix(euler);\n\n\t\t//std::cout << \"R=(\" << rmat << \")\" << std::endl;\n\n\t\tcv::Mat R, Rt, t, t_inv;\n\n\t\tswitch (m_InstallType){\n\t\tcase HPLEyeHandType::EyeInHand:\n\t\t\t// 眼在手上\n\t\t\tm_Vec_t_gripper2base.push_back(tvec);\n\t\t\tm_Vec_R_gripper2base.push_back(rmat);\n\t\t\tbreak;\n\n\t\tcase HPLEyeHandType::EyeToHand:\n\t\t\t// 眼在手外--对旋转矩阵进行转置；-对平移矩阵进行一次变换\n\t\t\tR = rmat;\n\t\t\t// 对旋转矩阵进行转置\n\t\t\tRt = R.t();\n\t\t\tm_Vec_R_gripper2base.push_back(Rt);\n\n\t\t\t// 读取末端平移矩阵\n\t\t\tt = tvec;\n\t\t\tt_inv = -Rt * t;\n\t\t\t//std::cout << \"-Rt*t:\" << t_inv << std::endl;\n\t\t\tm_Vec_t_gripper2base.push_back(t_inv);\n\t\t\tbreak;\n```\n\n\n\n###### 7.使用pnp算法求解target2cam-----核心作用是**计算 “标定板（目标）相对于相机的位姿”**（即标定板在相机坐标系下的旋转和平移关系）\n\n```\nCV_EXPORTS_W bool solvePnP( InputArray objectPoints, InputArray imagePoints,\n                            InputArray cameraMatrix, InputArray distCoeffs,\n                            OutputArray rvec, OutputArray tvec,\n                            bool useExtrinsicGuess = false, int flags = SOLVEPNP_ITERATIVE );\n```\n\n**PnP算法**\n\nPnP（Perspective-n-Point，**透视 n 点问题**）是计算机视觉中的核心算法，核心逻辑是：\n**已知相机内参的前提下，通过 “n 个 3D 世界坐标已知的点” 和它们对应的 “2D 图像像素坐标”，求解 3D 目标（如标定板）相对于相机的位姿（旋转矩阵 R + 平移向量 t）。**\n\n简单理解：通过图像中 “已知 3D 位置的点”，反推 “相机看目标的角度（R）” 和 “相机到目标的距离（t）”。\n\n**PnP 算法的核心好处**\n\n1. **精度高**\n   支持迭代法（如代码中 `SOLVEPNP_ITERATIVE`）、鲁棒法（如 `solvePnPRansac` 抗外点），能有效抑制噪声和少量误匹配点的干扰，适合高精度位姿测量（如机器人视觉引导）。\n2. **依赖条件少**\n   仅需两个核心输入：① 相机内参（标定后可复用）；② 至少 4 个 3D-2D 点对（n≥4，实际用标定板的多个角点进一步提升精度），无需额外设备。\n3. **通用性强**\n   广泛应用于相机标定、手眼标定、AR/VR（虚拟物体对齐现实）、目标跟踪、机器人抓取等场景，是视觉位姿估计的 “基础工具”。\n4. **工程化友好**\n   OpenCV 等库已优化实现，接口简洁、运行效率高，支持实时或批量处理（如代码中循环处理多帧图像的位姿）。\n\n\n\n###### 8.调用函数\n\n`cv::calibrateHandEye`是 OpenCV 中用于**机器人手眼标定**的核心函数。它通过多组位姿数据，求解出相机与夹爪的相对位姿，为机器人视觉引导（如抓取、定位）提供坐标映射的关键参数。\n\n\n\n手眼标定的本质是建立 “相机” 与 “机器人末端” 的刚性转换关系。当机器人带动相机（或相机固定、机器人末端带动靶标）运动时，通过记录多组位姿，该函数可计算出：**相机坐标系 → 机器人末端（夹爪）坐标系的旋转矩阵和平移向量**，从而实现 “相机识别的目标坐标” 到 “机器人可执行的坐标” 的转换。\n\n\n\n```\nCV_EXPORTS_W void calibrateHandEye( InputArrayOfArrays R_gripper2base, InputArrayOfArrays t_gripper2base,\n                                    InputArrayOfArrays R_target2cam, InputArrayOfArrays t_target2cam,\n                                    OutputArray R_cam2gripper, OutputArray t_cam2gripper,\n                                    HandEyeCalibrationMethod method=CALIB_HAND_EYE_TSAI );\n```\n\n\n\n只需要将前面得到的gripper2base和target2cam参数放到函数中去调用即可。\n\n```\nCV_EXPORTS_W void calibrateHandEye(\n    InputArrayOfArrays R_gripper2base,  // 输入：夹爪到机器人基坐标系的旋转矩阵集合\n    InputArrayOfArrays t_gripper2base,  // 输入：夹爪到机器人基坐标系的平移向量集合\n    InputArrayOfArrays R_target2cam,    // 输入：靶标到相机坐标系的旋转矩阵集合\n    InputArrayOfArrays t_target2cam,    // 输入：靶标到相机坐标系的平移向量集合\n    OutputArray R_cam2gripper,          // 输出：相机到夹爪坐标系的旋转矩阵\n    OutputArray t_cam2gripper,          // 输出：相机到夹爪坐标系的平移向量\n    HandEyeCalibrationMethod method = CALIB_HAND_EYE_TSAI  // 标定方法（默认TSAI）\n);\n```\n\n\n\n###### 标定方法介绍：\n\n| 方法枚举值               | 核心原理                                                     | 优点                                                   | 缺点                                                         | 适用场景                                                     |\n| ------------------------ | ------------------------------------------------------------ | ------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| `CALIB_HAND_EYE_TSAI`    | 分离求解旋转与平移：先通过矩阵运算求旋转，再用最小二乘法求平移 | 计算效率高，精度均衡，抗中等噪声能力较好，工程实用性强 | 平移误差依赖旋转结果，易累积；对严重噪声或位姿分布不均敏感   | 常规工业场景（如装配、搬运），中等精度需求，对实时性有一定要求 |\n| `CALIB_HAND_EYE_PARK`    | 基于四元数表示旋转，构建线性方程组同时求解旋转与平移的近似解 | 数学模型简单，计算速度快，适合快速验证                 | 对噪声极敏感，精度较低；位姿数据不足时易漂移                 | 快速原型验证，低精度场景（如误差允许＞1mm），对速度要求高的场景 |\n| `CALIB_HAND_EYE_HORAUD`  | 用对偶四元数统一表示旋转与平移，通过特征值分解同时优化两者   | 理论精度高，抗噪声能力较强，避免误差累积               | 计算复杂度高（特征值分解耗时），对上位姿数量和分布要求高（需≥10 组） | 高精度场景（如精密装配、微电子封装），离线标定且位姿数据充足 |\n| `CALIB_HAND_EYE_ANDREFF` | 基于非线性优化（如 Levenberg-Marquardt），构建联合误差函数迭代求解最优解 | 精度最高，对噪声和位姿分布不均容忍度好，无近似简化     | 计算量最大（迭代耗时），需大量高质量位姿数据才能稳定收敛     | 超高精度任务（如光学检测、精密定位），离线标定且对精度要求严苛的场景 |\n\n主要采用TSAI\n\n\n\n###### 误差分析\n\n1.会进行多种标定方法的计算，如果有很大的误差，不同方法算出来的值会相差很多。\n\n2.重投影误差分析\n\n3.实际走点\n\n4.通过量化 “靶标在机器人基坐标系下的位姿一致性” 来评估标定结果的可靠性。\n\n核心逻辑是：**若手眼标定准确，靶标在机器人基坐标系下的位姿应保持稳定（变化极小）**，因此通过计算多组位姿的 “平移偏差” 和 “旋转偏差” 来衡量标定精度。\n\n**误差计算的核心原理**\n\n手眼标定的本质是建立 “相机→夹爪” 的变换关系（矩阵`X`）。在标定过程中，无论相机是 “眼在手上”（随夹爪运动）还是 “眼在手外”（固定），**靶标相对机器人基坐标系的位姿理论上应保持不变**（因靶标要么固定在外部，要么随夹爪刚性连接）。\n\n```\nstd::string HPLCaliAlgoOpenCV::HandEyeCalibrationError()\n{\n\tstd::string error;\n\tif (m_Vec_R_gripper2base.size() != m_Vec_t_gripper2base.size() ||\n\t\tm_Vec_R_target2cam.size() != m_Vec_t_target2cam.size() ||\n\t\tm_Vec_R_gripper2base.size() != m_Vec_R_target2cam.size()){\n\t\tstd::cerr << \"Hand-eye calibration input size mismatch!\" << std::endl;\n\t\treturn \"Hand-eye calibration input size mismatch!\";\n\t}\n\n\t// 构造手眼变换矩阵 X = [R | t]\n\tcv::Mat X = cv::Mat::eye(4, 4, CV_64F);\n\tm_HandEyeResult_RVec.copyTo(X(cv::Rect(0, 0, 3, 3)));\n\tm_HandEyeResult_TVec.copyTo(X(cv::Rect(3, 0, 1, 3)));\n\n\tstd::vector<cv::Mat> vec_target_in_base;\n\tstd::vector<cv::Mat> vec_R;\n\n\tfor (size_t i = 0; i < m_Vec_R_gripper2base.size(); ++i)\n\t{\n\t\t// T_e^b\n\t\tcv::Mat T_e_b = cv::Mat::eye(4, 4, CV_64F);\n\t\tm_Vec_R_gripper2base[i].copyTo(T_e_b(cv::Rect(0, 0, 3, 3)));\n\t\tm_Vec_t_gripper2base[i].copyTo(T_e_b(cv::Rect(3, 0, 1, 3)));\n\n\t\t// T_t^c\n\t\tcv::Mat T_t_c = cv::Mat::eye(4, 4, CV_64F);\n\t\tm_Vec_R_target2cam[i].copyTo(T_t_c(cv::Rect(0, 0, 3, 3)));\n\t\tm_Vec_t_target2cam[i].copyTo(T_t_c(cv::Rect(3, 0, 1, 3)));\n\n\t\t// 计算 T_t^b = T_e^b * X * T_t^c\n\t\tcv::Mat T_t_b = T_e_b * X * T_t_c;\n\n\t\tvec_target_in_base.push_back(T_t_b);\n\t\tvec_R.push_back(T_t_b(cv::Rect(0, 0, 3, 3)).clone());\n\t}\n\n\t// 计算平移误差（平均值 + RMS）\n\tcv::Mat mean_t = cv::Mat::zeros(3, 1, CV_64F);\n\tfor (const auto& T : vec_target_in_base)\n\t\tmean_t += T(cv::Rect(3, 0, 1, 3));\n\tmean_t /= (double)vec_target_in_base.size();\n\n\tdouble rms = 0.0;\n\tfor (const auto& T : vec_target_in_base)\n\t{\n\t\tcv::Mat diff = T(cv::Rect(3, 0, 1, 3)) - mean_t;\n\t\trms += cv::norm(diff);\n\t}\n\n\trms /= vec_target_in_base.size();\n\n\t// --- 旋转误差 ---\n\tcv::Mat rvec_mean = cv::Mat::zeros(3, 1, CV_64F);\n\tfor (const auto& R : vec_R)\n\t{\n\t\tcv::Mat rvec;\n\t\tcv::Rodrigues(R, rvec);\n\t\trvec_mean += rvec;\n\t}\n\trvec_mean /= static_cast<double>(vec_R.size());\n\n\tcv::Mat R_mean;\n\tcv::Rodrigues(rvec_mean, R_mean);\n\n\tdouble total_rot_error_deg = 0.0;\n\tfor (const auto& R : vec_R)\n\t{\n\t\tcv::Mat R_diff = R_mean.t() * R;\n\t\tdouble angle_rad = std::acos(std::min(1.0, std::max(-1.0, (cv::trace(R_diff)[0] - 1.0) / 2.0)));\n\t\tdouble angle_deg = angle_rad * 180.0 / CV_PI;\n\t\ttotal_rot_error_deg += angle_deg;\n\t}\n\tdouble avg_rot_error_deg = total_rot_error_deg / vec_R.size();\n\n\tstd::ostringstream oss;\n\toss << \"RMS translation error = \" << rms << \" mm\\n\"\n\t\t<< \"Average rotation error = \" << avg_rot_error_deg << \" deg\";\n\t\n\terror = oss.str();\n\treturn error;\n}\n```\n\n","tags":["opencv","相机标定","机器人"],"categories":["相机标定"]},{"title":"解决 Typora 插入图片路径与 Hexo 不兼容","url":"/2025/09/11/解决-Typora-插入图片路径与-Hexo-不兼容/","content":"\n<!--more-->\n\n\n\n# 问题描述：\n\n每次在typaro 里面插入的图片格式都是这样的绝对路径\n\n![image-20250911155104238](解决-Typora-插入图片路径与-Hexo-不兼容/image-20250911155104238.png)\n\n而在hexo显示需要的是这样的格式\n\n![image-20250911155148931](解决-Typora-插入图片路径与-Hexo-不兼容/image-20250911155148931.png)\n\n第一个是绝对路径应该改为相对路径\n\n第二个是 / 与 \\ 的不同\n\n\n\n# 解决方法：\n\n**核心思路**：让 Typora 自动将图片保存到 Hexo 文章的同名资源文件夹，并生成相对路径。\n\n#### 1. 配置 Hexo 资源文件夹\n\n打开 Hexo 根目录的 `_config.yml`，添加以下配置：\n\n```yaml\npost_asset_folder: true  # 启用文章资源文件夹功能\n```\n\n此后，使用 `hexo new \"文章标题\"` 创建文章时，会自动生成同名文件夹（如 `相机标定原理介绍/`）。\n\n#### 2. 配置 Typora 自动保存图片\n\n打开 Typora → **偏好设置 → 图像**，按以下步骤操作：\n\n- 插入图片时：选择 复制到指定路径，并输入路径：\n\n  ```plaintext\n  ./$(filename)  # 表示当前文章的同名文件夹（与 Hexo 资源文件夹路径一致）\n  ```\n\n  - 若文章名为 `相机标定原理介绍.md`，图片会自动保存到 `相机标定原理介绍/` 文件夹。\n  - **关键**：路径必须以 `./` 开头，表示当前文章所在目录。\n\n- **勾选**：对本地位置的图片应用上述规则。\n\n- **链接格式**：选择 **相对路径**（确保生成的路径不带盘符或绝对路径）。\n\n#### 3. 验证效果\n\n- 插入图片时，Typora 会自动将图片复制到文章同名文件夹，并生成路径：\n\n  ```markdown\n  ![图片](相机标定原理介绍/1.png)  # 直接引用文件夹内的图片\n  ```\n\n- 执行 `hexo g && hexo d` 部署后，图片会被正确打包到 Hexo 的 `public` 目录。\n\n#### 4. 注意事项\n\n- 必须通过 `hexo new` 命令创建文章，否则不会自动生成资源文件夹。\n- 若手动创建文章，需手动在 `source/_posts/` 下创建同名文件夹，并在 Typora 中粘贴图片时选择 **复制到当前文件夹**。\n\n\n\n# 效果\n\n![image-20250911155502919](解决-Typora-插入图片路径与-Hexo-不兼容/image-20250911155502919.png)\n","tags":["hexo","解决问题","typora"],"categories":["hexo"]},{"title":"相机标定原理介绍","url":"/2025/09/09/相机标定原理介绍/","content":"\n<!--more-->\n\n# 相机标定的原理简介\n\n相机标定（Camera Calibration）的原理主要是通过一系列已知几何信息的标定板图像，求解相机的内参、外参以及畸变参数，从而建立三维空间点与图像二维像素点之间的准确数学模型。\n\n\n\n# 相机是如何成像的\n\n相机标定的理论基础是 **针孔成像模型**。（小孔成像）\n\n<img src=\"相机标定原理介绍/5.png\" style=\"zoom: 80%;\" />\n\n空间点 (X,Y,Z)（在相机坐标系下）经过投影关系映射到图像平面上的像素点 (u,v)。基本关系为：\n\n![图片](相机标定原理介绍/1.png)\n\n其中，K为内参矩阵；[R|t]为外参矩阵。s：尺度因子（归一化用）。\n\n[u,v,1]是齐次坐标 的一种表达方式。\n\n> 前两个分量 (u,v)(u, v)(u,v) 还是原来的像素坐标；\n>\n> 最后一个分量 “1” 是一个 **尺度因子**，保证齐次坐标与普通坐标的对应关系：\n>\n> (u,v)↔(ku,kv,k), k≠0\n>\n> 它们表示的是同一个点。\n\n## 什么是内参？\n\n内参描述的是 **相机自身的成像特性**，与相机的物理结构（镜头、像素尺寸等）有关。\n\n所以内参矩阵一般标定一次之后，如果没有碰撞是不会改变的。\n\n![图片](相机标定原理介绍/2.png)\n\n其中：\n\n- fx,fy：焦距在图像 x、y 方向的像素单位表示\n  - fx=f/dx，fy=f/dy\n  - f：实际焦距（mm）\n  - dx,dy：单个像素在物理尺寸上的宽高（mm/pixel）\n- (u0,v0)：主点（principal point），理想情况下是光轴穿过图像的点（通常接近图像中心）\n- γ：像素坐标轴之间的夹角系数，若像素是矩形则 γ=0\n\n**总结**：在标定时通常是固定的一组参数，求出后可用于去畸变、图像矫正。相机“内在的透视投影规律” → 相机的固有属性。\n\n## 什么是外参？\n\n外参描述的是 **相机坐标系与世界坐标系之间的关系**。\n\n它由旋转矩阵 R 和平移向量 t 组成：\n\n![图片](相机标定原理介绍/3.png)\n\n其中：\n\n- R：3×3的旋转矩阵，描述世界坐标系相对于相机坐标系的旋转关系\n- t：3×1 的平移向量，描述世界坐标系原点在相机坐标系下的位置\n\n**总结**：每张标定板图像对应一组外参，用来描述标定板在相机前的位置和方向。相机“放在空间里的位置和方向” → 相机和世界坐标系的关系。\n\n\n\n## 成像原理详细介绍\n\n![图片](相机标定原理介绍/4.png)\n\n**相机成像系统中，共包含四个坐标系：世界坐标系、相机坐标系、图像坐标系、像素坐标系。**\n\n- **世界坐标系**：由用户定义的三维世界坐标系，描述物体和相机在真实世界中的位置，原点可以任意选择。\n- **相机坐标系**：以相机的光心为坐标原点，x轴和y轴平行于图像坐标系的x轴和y轴，z轴为相机的光轴。\n- **图像坐标系**：与成像平面重合，以成像平面的中心（光轴与成像平面的交点）为坐标原点，x 轴和 y轴分别平行于成像平面的两条边。\n- **像素坐标系**：与成像平面重合，以成像平面的左上角顶点为原点，x 轴和 y 轴分别平行于图像坐标系的x轴和y轴。\n\n世界坐标系下的Pw点 ，在相机坐标系中的坐标为Pc，投影到图像坐标系后坐标为P(x,y) ，对应在像素坐标系中的坐标为P(u,v)。\n\n![图片](相机标定原理介绍/6.png)\n\n![图片](相机标定原理介绍/7.png)\n\n\n\n\n\n## 相机畸变与畸变矫正\n\n相机拍摄的图片还存在一定的畸变，畸变包括桶形畸变和枕形畸变。畸变模型包括**径向畸变**和**切向畸变**。\n\n\n\n### **径向畸变：**\n\n可以这样来理解，对于透镜而言，以透镜的中心作为原点，往外是透镜的半径的方向，**当光线越靠近中心的位置，畸变越小**，沿着半径方向远离中心的时候，畸变越大。典型的径向畸变有桶形畸变和枕形畸变。如下图所示。\n\n### **切向畸变：**\n\n切向畸变可以这样理解，当透镜与成像平面不行时，就产生了畸变，类似于透视变换。\n\n![图片](相机标定原理介绍/8.png)\n\n\n\n![图片](相机标定原理介绍/9.png)\n\n注：\n\n一般来说k1,k2,k3,k4,k5 一般只会用到k1 和k2\n\n如下图我做的梅卡曼德相机内参标定结果\n\n![图片](相机标定原理介绍/10.png)\n\n\n\n畸变系数 [k1, k2, p1, p2, k3]\n\n\n\n# 相机标定的方法\n\n**相机标定的目标是去求解内参、畸变系数、外参。**\n\n\n\n## 常见的相机标定方法\n\n### **基于已知标定物的标定**（最常用）\n\n利用一个几何结构已知的标定板（如棋盘格、圆点阵列），获取多组图像来求解相机参数。\n\n#### a) 张正友标定法（Zhang’s Method）\n\n- **原理**：只需一块平面棋盘格，拍摄多张不同姿态的图片。\n- **步骤**：\n  1. 检测棋盘格角点（得到二维像素点 (u,v）\n  2. 知道棋盘格格点的三维世界坐标 (X,Y,0)\n  3. 建立二维–三维对应关系，先线性估计相机参数\n  4. 再通过非线性优化（最小化重投影误差）精确求解内参、畸变系数、外参\n- **优点**：方便、精度高、只需要平面棋盘格\n- **缺点**：对角点检测精度敏感\n\n#### b) 基于圆点阵列/对称圆标定板\n\n- 用规则排列的圆形点，提取圆心作为特征点\n- **优点**：鲁棒性好，圆心定位比棋盘格角点更稳定，适合光照复杂环境\n- **缺点**：特征检测比棋盘格稍复杂\n\n#### c) 三维标定物体（立体标定块）\n\n- 使用三维立体标定块（如立方体、3D 标定架）\n- **优点**：几何约束更强，精度高\n- **缺点**：制作复杂、成本高\n\n------\n\n### (2) **自标定（Self-Calibration）**\n\n- 不使用标定板，只依赖图像序列中的几何约束（如相机运动信息、场景几何特征）。\n- **方法**：通过基础矩阵 F、单应性矩阵 H 等约束求相机内参。\n- **优点**：无需标定板，适合野外场景或移动设备（SLAM、SfM）。\n- **缺点**：精度低于基于标定板的方法，收敛依赖运动轨迹。\n\n------\n\n### (3) **基于运动的标定**（Hand-Eye Calibration, Robot Calibration）\n\n- 相机和机器人协作，通过已知的机器人运动信息（末端位姿）和相机观测到的特征点，联合求解外参或手眼关系。\n- 常用于：**眼在手上 / 眼在手外** 机器人视觉系统。\n\n## 各方法对比\n\n| 方法               | 特点        | 优点             | 缺点               |\n| ------------------ | ----------- | ---------------- | ------------------ |\n| 棋盘格（张正友法） | 平面标定板  | 简单易用，精度高 | 角点检测受噪声影响 |\n| 圆点阵列           | 圆心特征    | 鲁棒性好         | 检测算法稍复杂     |\n| 立体标定块         | 三维标定物  | 高精度           | 制作成本高         |\n| 自标定             | 无需标定物  | 灵活，适合SLAM   | 精度低，收敛不稳定 |\n| 机器人手眼标定     | 相机+机器人 | 工业应用广泛     | 依赖机器人精度     |\n\n\n\n# 总结：\n\n相机标定的目的是为了得到  世界坐标系下的三维点与成像平面上二维像素点之间的关系。\n\n相机标定的原理是，通过一系列的已知标定板的图像信息去求解相机内参外参和畸变系数。\n\n相机的内参和畸变系数在出厂之后如果不被撞动内部元器件，是不会改变的。\n\n下一篇文章将继续介绍 使用Opencv开源库实现 张正友标定法和机器人手眼标定。\n","tags":["相机标定原理"],"categories":["相机标定"]},{"title":"VMware17.6安装VMware Tools失败的原因以及解决方法","url":"/2025/09/08/VMwareTools安装失败的原因以及解决方法/","content":"\n<!--more-->\n\n在VMware17.6里面 安装ubuntu 和 win11 都发现VMware Tools很难安装，一开始我以为是我系统安装的问题，后面经过搜索发现2025年有遇见同样的问题。\n\n\n\n原来是博通变更链接致 VMware 自动更新功能失效\n\n[博通变更链接致 VMware 自动更新功能失效，用户被迫手动升级 - IT之家](https://www.ithome.com/0/842/319.htm)\n\n然后参考\n\n[(68 封私信 / 24 条消息) vmware解决更新Tools报错，无法连接更新服务器。请检查您的 Internet 设置或联系您的系统管理员 - 知乎](https://zhuanlan.zhihu.com/p/1891460517534619423)\n\n[【解决方案】Windows11 Vmware 17.6.0更新Tools报错，无法连接更新服务器。请检查您的 Internet 设置或联系您的系统管理员。_无法解析更新服务器。请检查您的 internet 设置或联系您的系统管理员。-CSDN博客](https://blog.csdn.net/qq_45196785/article/details/146966596)\n\n\n\n解决方法为：\n\n在虚拟机下载VMware Tools工具 安装。\n\n下载地址：\n\n[https://packages.vmware.com/too](https://link.zhihu.com/?target=https%3A//packages.vmware.com/tools/esx/latest/windows/x64/)\n\n然后一直点下一步安装即可。\n","tags":["虚拟机","解决问题"],"categories":["虚拟机"]},{"title":"C++命名规范","url":"/2025/08/09/C-命名规范/","content":"\n<!--more-->\n\n参考：\n\n[看了这么多代码，谈一谈代码风格！ | 代码随想录](https://www.programmercarl.com/前序/代码风格.html#题外话)\n\nGoogle C++ 编程风格指南\n\n# 前言：\n\n为什么会注意到C++命名规范呢？\n\n因为在我实习的过程中，无法避免地需要去阅读师兄师姐师弟师妹的代码。在我们软件中当然也有 JJ 师兄定制的代码规范，但是并不是很全面也不是所有人都会去遵循，这就导致有些代码可读性非常非常非常差。\n\n举例一个我刚刚实习看的业务代码让我很难阅读的地方：\n\n**变量命名完全不规范**，成员变量和局部变量混乱，成员变量有时候加m_ 有时候不加，局部变量也有时候加m_ 。尽管有IDE的帮助，阅读起来还是很费劲。\n\n我相信他自己回来重新看也会很费劲。\n\n为了提升自己代码的可读性，规范命名是很重要的。方便自己也方便共同开发的大家。\n\n\n\n\n\n# 简略内容\n\n## 变量的命名\n\n主流有如下三种变量规则：\n\n- 小驼峰、大驼峰命名法\n- 下划线命名法\n- 匈牙利命名法\n\n**小驼峰**，第一个单词首字母小写，后面其他单词首字母大写。例如 `int myAge;`\n\n**大驼峰法**把第一个单词的首字母也大写了。例如：`int MyAge;`\n\n\n\n通常来讲 java和go都使用驼峰，C++的函数和结构体命名也是用大驼峰，\n\n下划线命名法是名称中的每一个逻辑断点都用一个下划线来标记，例如：`int my_age`，**下划线命名法是随着C语言的出现流行起来的，如果大家看过UNIX高级编程或者UNIX网络编程，就会发现大量使用这种命名方式**。\n\n**匈牙利命名法**是：变量名 = 属性 + 类型 + 对象描述，例如：`int iMyAge`，这种命名是一个来此匈牙利的程序员在微软内部推广起来，然后推广给了全世界的Windows开发人员。\n\n\n\n### **总结**：\n\n### 尽管现在IDE很发达，我个人现在还是认为**匈牙利命名法**更加有可读性。\n\n\n\n## 水平留白（代码空格）\n\n操作符左右一定有空格，例如\n\n```text\ni = i + 1;\n```\n\n分隔符（`,` 和`;`）前一位没有空格，后一位保持空格，例如：\n\n```text\nint i, j;\nfor (int fastIndex = 0; fastIndex < nums.size(); fastIndex++)\n```\n\n大括号和函数保持同一行，并有一个空格例如：\n\n```text\nwhile (n) {\n    n--;\n}\n```\n\n控制语句（while，if，for）后都有一个空格，例如：\n\n```text\nwhile (n) {\n    if (k > 0) return 9;\n    n--;\n}\n```\n\n以下是我刚写的力扣283.移动零的代码，大家可以看一下整体风格，注意空格的细节！\n\n```cpp\nclass Solution {\npublic:\n    void moveZeroes(vector<int>& nums) {\n        int slowIndex = 0;\n        for (int fastIndex = 0; fastIndex < nums.size(); fastIndex++) {\n            if (nums[fastIndex] != 0) {\n                nums[slowIndex++] = nums[fastIndex];\n            }\n        }\n        for (int i = slowIndex; i < nums.size(); i++) {\n            nums[i] = 0;\n        }\n    }\n};\n```\n\n\n\n### **总结**：\n\n其实在使用VS2019写代码的时候，编译器都会自动调整，比如说 int a=1;编译器会在你输入 ; 的时候自动修改为 int a = 1;\n\n所以也说明这样的代码看上去更加规范，好阅读不会挤在一起。\n\n\n\n\n\n# GoogleC++命名规范（详细）\n\n晚一点总结，里面内容很多。我还没有读完。\n","tags":["C++","代码命名规范"],"categories":["C++"]},{"title":"虚拟机克隆、快照、迁移、删除","url":"/2025/08/08/虚拟机克隆、快照、迁移、删除/","content":"\n\n\n<!--more-->\n\n参考：\n\n[VMware虚拟机快照、克隆、迁移的概述以及操作_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1CD421V72i/?spm_id_from=333.337.search-card.all.click&vd_source=a858a9df12a9613b40ef1eefb011b473)\n\n[纯小白学习linux系统之----VMware虚拟机克隆、快照、迁移、删除_wmware拷贝-CSDN博客](https://blog.csdn.net/kezhene1/article/details/149900866)\n\n安装虚拟机不只是为了学习和体验Linux内核的系统，还有虚拟机的非常多好处吸引我。\n\n# 1.快照\n\n## 1.1快照概念:\n\n记录了虚拟机在某个特定时间点的状态(照片备份、游戏存档 )\n\n## 1.2快照用途:\n\n可以在需要时轻松地恢复虚拟机到快照创建时的状态。\n\n可保存虚拟机某一时刻的完整状态（内存、磁盘、配置）可随时回退，如系统升级/软件安装前创建快照，有问题可快速还原。\n\n详细：\n\n​\t**备份和恢复:**快速备份虚拟机状态的方法可以在数据丢失或损坏时快速恢复虚拟机到先前的状态。\n​\t**测试和开发**:在进行软件测试或开发时，可以先创建一个快照，然后进行更改。如果测试失败或发现错误，可以轻松地恢复虚拟机到快照状态，而不影响其他开发工作。\n​\t**安全更新**:在应用重要更新或配置更改之前，可以先创建一个快照，以便在更新失败时可以快速恢复到以前的状态，避免对生产环境造成影响。\n\n \n\n# 2.克隆\n\n## 2.1克隆概念:\n\n创建一个与源对象相似但完全独立的副本\n\n## 2.2克降用途:\n\n​\t快速部署:克降是快速创建相似配置的新对象的一种方法，因此在需要快速部署多个相似环境时非常有用，例如测试环境或开发环境。\n​\t测试和开发:在软件测试或开发过程中可以使用克降来创建一个与生产环境相似但独立的测试环境，以便进行安全的测试和开发工作。\n​\t灾难恢复:在灾难恢复方案中，克隆可以作为恢复备份数据的一种方式，通过创建虚拟机的克隆来快速恢复到先前的状态\n\n![图片](虚拟机克隆、快照、迁移、删除/1.png)\n\n- **完整克隆**：副本完全独立，性能高，占用存储空间大（适合生产环境）\n- **链接克隆**：依赖父虚拟机，节省空间，但父机不可删除（适合临时测试）。\n\n这里我感觉还是**完整克隆**更好。\n\n\n\n# 3.迁移\n\n## 3.1迀移概念:\n\n将虚拟机从一个物理服务器或数据中心迁移到另一个物理服务器或数据中心的过程(迁移到新硬件、新位置或新环境。)\n\n冷迁移（关闭虚拟机）：将虚拟机从一台物理主机迁移到另一台，或存储位置迁移\n\n热迁移（不关闭虚拟机）：对操作要求较高，感兴趣的同学可以研究下。\n\n## 3.2迁移用途:\n\n​\t资源平衡:迁移可以帮助在物理服务器之间平衡负载，确保资源被有效利用。\n\n​\t维护和升级:当您需要对物理服务器进行维护或升级时，可以使用迁移将虚拟机转移到备用服务器上，而无需中断服务。\n\n​\t灾难恢复:在出现灾难情况时，迁移可以帮助您将虚拟机快速迁移到备用数据中心以确保业务连续性。\n\n## 3.3如何进行迁移 ?\n\n注意:\n迁移过去的虚拟机所在软件也就是vmware的版本一定要>=迁移前vmware的版本(vmware高版本兼容低版本，但是低版本缺失/不匹配高版本的硬件版本、功能支持等)\n\n找到安装虚拟机操作系统时保存的文件夹，选择文件拷贝即可。\n","tags":["虚拟机","VMware","备份"],"categories":["虚拟机"]},{"title":"虚拟机Ubuntu和宿主机之间的复制粘贴功能","url":"/2025/08/04/虚拟机Ubuntu和宿主机之间的复制粘贴功能/","content":"\n<!--more-->\n\n参考：\n\n[关于VMware Tools 不再随旧版客户机操作系统的 VMware Workstation 一起提供。-CSDN博客](https://blog.csdn.net/qq_39172792/article/details/146919942)\n\n[(68 封私信 / 20 条消息) VMware虚拟机和主机间复制粘贴共享剪贴板 - 知乎](https://zhuanlan.zhihu.com/p/665154528)\n\n\n\n# 前言:\n\n看视频别人安装Ubuntu之后,能自动安装VMware Tools，实现VMware虚拟机和主机间复制粘贴共享剪贴板，但是我的不行，点击安装VMware Tools，提示\n\nVMware Tools 不再随旧版客户机操作系统的 VMware Workstation 一起提供。\n\n请从 https://packages-prod.broadcom.com/tools/frozen/linux/linux.iso 下载，并参阅 Install VMware Tools in VMware products 以了解安装步骤。\n\n客户机操作系统没有任何 VMware Tools 映像。\n![](虚拟机Ubuntu和宿主机之间的复制粘贴功能/1.png)\n\n\n\n# 解决：\n\n尝试参考[关于VMware Tools 不再随旧版客户机操作系统的 VMware Workstation 一起提供。-CSDN博客](https://blog.csdn.net/qq_39172792/article/details/146919942)的第一种解决方法\n\n> ### 方法一\n>\n> 进入命令行，输入命令\n>\n> sudo apt-get install open-vm-tools-desktop\n>\n> 一路输入yes下去，直到安装完成\n\n**但是根本不行，说找不到这个。**\n\n于是尝试第二种方法\n\n> ### 方法二\n>\n> #### 1.复制上述连接\n>\n> https://packages-prod.broadcom.com/tools/frozen/linux/linux.iso\n>\n> #### 2.打开火狐浏览器\n>\n> 粘贴连接进入浏览器，下载弹出的文件\n\n发现连不上网，于是解决联网的问题，咨询ai老师\n\n## 联网问题解决：\n\n### 1.VMware 常见网络模式\n\n- **NAT**：通过主机共享网络。\n- **桥接**：直接使用主机网络。\n- **仅主机**：只和主机通信。\n\n✔ 推荐使用：**NAT 模式**。\n\n> 设置路径：虚拟机 → 设置 → 网络适配器 → 选择 NAT 或 桥接。\n\n### 2、检查 Ubuntu 网络是否启用\n\n进入 Ubuntu，执行以下命令查看网络状态：\n\n```\nip a\n```\n\n或使用：\n\n```\nnmcli device status\n```\n\n查看 `eth0` 或 `enp0s3` 等网卡是否是 `connected` 状态。\n\n### 3.测试联网是否成功\n\n```\nping -c 4 www.baidu.com\nping -c 4 8.8.8.8\n```\n\n- 能 ping 通域名 → 网络和 DNS 正常。\n- 能 ping 通 IP 但不能 ping 域名 → DNS 有问题。\n- 都 ping 不通 → 网卡/网络配置错误。\n\n然后就可以联网了。\n\n一开始想复制网址过去打开，发现还不能复制，只好手打。\n\n\n\n\n\n下载之后，按照步骤操作。\n\n## 下载完成后打开文件所在目录\n\n可以看到下载了如下文件\n\n![](虚拟机Ubuntu和宿主机之间的复制粘贴功能/2.png)\n\n在文件所在目录空白处右键选择Open in Terminal进入命令行\n\n![](虚拟机Ubuntu和宿主机之间的复制粘贴功能/3.png)\n\n## 挂载设备\n\n进入命令行，使用如下命令，创建挂载目录\n\n```\nsudo mkdir /media/iso_mount\n```\n\n使用如下命令，将iso挂载到指定目录\n\n```\nsudo mount -o loop ./linux.iso /media/iso_mount\n```\n\n可以看到桌面出现如下文件，即挂载成功\n\n![](虚拟机Ubuntu和宿主机之间的复制粘贴功能/5.png)\n\n\n\n> 这个时候开始不顺利了\n\n![](虚拟机Ubuntu和宿主机之间的复制粘贴功能/4.png)\n\n**注意：**输入密码是不会显示的，输入完之后，直接回车即可。\n\n这里第一次输入错误因为 （`mkdir/media/iso_mount` 被当作一个整体命令）\n\n在ai老师的指导下，先删除了之前的文件目录，重新创建挂载就可以了，不是很清楚为什么。\n\n```\n# 1. 删除残留文件/目录（如果存在）\nsudo rm -rf /media/iso_mount\n\n# 2. 正确创建目录（使用 mkdir）\nsudo mkdir /media/iso_mount\n\n# 3. 挂载ISO文件（确保当前在 ~/下载 目录）\nsudo mount -o loop ./linux.iso /media/iso_mount\n```\n\n\n\n## 安装VmwareTool\n\n进入该目录，将压缩包复制到桌面\n\n![](虚拟机Ubuntu和宿主机之间的复制粘贴功能/6.png)\n\n> 我发现我的桌面已经有了\n\n在桌面进入命令行，输入如下命令，然后按下Tab补全，解压压缩包\n\n```\ntar -zvxf ./V\n```\n\n![](虚拟机Ubuntu和宿主机之间的复制粘贴功能/7.png)\n\n解压完成我们进入解压后的文件夹\n\n![](虚拟机Ubuntu和宿主机之间的复制粘贴功能/8.png)\n\n内容如下\n\n![](虚拟机Ubuntu和宿主机之间的复制粘贴功能/9.png)\n\n右键进入命令行，输入如下指令\n\n```\nsudo ./[vmware]-install.pl\n```\n\n进入如下界面\n\n![](虚拟机Ubuntu和宿主机之间的复制粘贴功能/10.png)\n\n输入yes，然后一路回车\n\n出现这个就是安装好了\n\n![](虚拟机Ubuntu和宿主机之间的复制粘贴功能/11.png)\n\n![](虚拟机Ubuntu和宿主机之间的复制粘贴功能/12.png)\n\n这个时候我发现还是不能复制粘贴，其实应该要重启之后再尝试，应该就可以了。\n\n### 重启你的系统\n\n```text\nsudo reboot\n```\n\n\n\n下面是安装open-vm-tools和open-vm-tools-desktop\n\n```\nsudo apt-get install open-vm-tools\nsudo apt-get install open-vm-tools-desktop\n```\n\n\n\n安装过程中遇见如下问题\n\n![](虚拟机Ubuntu和宿主机之间的复制粘贴功能/13.png)\n\n这个提示是关于 PAM（Pluggable Authentication Modules）配置文件 `/etc/pam.d/vmtoolsd` 的冲突处理。在安装 `open-vm-tools` 时，安装程序发现该文件在系统中已经存在（可能是之前安装 VMware Tools 时创建的），并且与软件包维护者提供的版本不同。因此，它询问您如何处理这个冲突。\n\n\\### 选项解释：\n\n\\- **Y 或 I**：安装软件包维护者提供的版本（覆盖当前文件）\n\n\\- **N 或 O**：保留您当前使用的版本（不覆盖）\n\n\\- **D**：显示两个版本的区别（diff）\n\n\\- **Z**：将进程切换到后台（暂时不处理）\n\n**问题核心**\n\n1. **冲突文件**：`/etc/pam.d/vmtoolsd` (PAM 认证配置文件)\n2. **冲突双方**：\n   - 您系统中已存在的版本（可能是之前安装留下的）\n   - 软件包维护者提供的新版本\n\n- `-` 开头行：当前系统中存在的配置（将被删除）\n- `+` 开头行：软件包提供的新配置（将替换旧配置）\n\n这个差异显示配置格式有重大变化，新版本使用了更标准的 PAM 配置方式。\n\n**强烈建议选择**\n\n✅ **输入 `Y` 然后按回车**\n（使用软件包维护者提供的新版本）\n\n**为什么选择 Y？**\n\n1. **兼容性保证**：新版本是专门为当前软件（open-vm-tools 12.3.5）设计的\n2. **安全性**：旧配置可能包含已弃用的模块（如 `pan_shells.so`）\n3. **功能完整性**：确保 VMware Tools 认证系统正常工作\n4. **避免后续问题**：选择 N 可能导致服务启动失败\n\n**安装后验证**\n\n完成选择后执行：\n\n```\n# 重启服务\nsudo systemctl restart vmtoolsd\n\n# 检查状态\nsystemctl status vmtoolsd\n\n# 测试功能（安装后重启）\nsudo reboot\n```\n\n\n\n**至此，复制粘贴功能实现。**\n\n# Ubuntu复制粘贴快捷键\n\n复制：Ctrl+Shift+C\n\n粘贴：Ctrl+Shift+V\n\n比Windows系统的多了个Shift。\n\n\n\n# open-vm-tools和open-vm-tools-desktop关系\n\n1. open-vm-tools 和 open-vm-tools-desktop 都是 VMware的开源虚拟化工具，它们提供了一些增强功能和集成来改善虚拟机在 VMware 虚拟化环境中的性能和用户体验。\n2. open-vm-tools-desktop 是 open-vm-tools 的扩展，专注于提供与桌面虚拟机相关的增强功能。安装open-vm-tools-desktop 将包括 open-vm-tools提供的所有功能。\n3. 即只安装open-vm-tools-desktop也可以。但是只安装open-vm-tools可能还是不能共享剪贴板，某些 Linux 发行版和虚拟机环境需要额外的组件来实现这些功能，这时候就需要额外安装open-vm-tools-desktop了。\n","tags":["虚拟机","Ubuntu","复制粘贴"],"categories":["Ubuntu"]},{"title":"虚拟机安装Linux系统","url":"/2025/08/04/虚拟机安装Linux系统/","content":"\n<!--more-->\n\n# 结果展示\n\n![图片](虚拟机安装Linux系统/1)\n\n\n\n# 安装VMware虚拟机软件\n\n在微信公众号softgj里面找到VMware，建议安装版本比较新的。因为低版本VMware可能不能安装新版本的linux内核的系统。\n\n安装操作步骤一步一步来即可。\n\n密钥【MC60H-DWHD5-H80U9-6V85M-8280D】\n\n\n\n# 安装ubuntu22.04系统\n\n## 系统选择理由：\n\n参考[常见Linux发行版本有哪些？ - C语言中文网](https://c.biancheng.net/view/710.html)\n\nLinux 的发行版本众多，下面给选择 Linux 发行版本犯愁的朋友一点建议：\n\n1. 如果你需要的是一个服务器系统，而且已经厌烦了各种 Linux 的配置，只是想要一个比较稳定的服务器系统，那么建议你选择 CentOS 或 RHEL。\n2. 如果你只是需要一个桌面系统，而且既不想使用盗版，又不想花大价钱购买商业软件，不想自己定制，也不想在系统上浪费太多时间，则可以选择 Ubuntu。\n3. 如果你想深入摸索一下 Linux 各个方面的知识，而且还想非常灵活地定制自己的 Linux 系统，那就选择 Gentoo 吧，尽情享受 Gentoo 带来的自由快感。\n4. 如果你对系统稳定性要求很高，则可以考虑 FreeBSD。\n5. 如果你需要使用数据库高级服务和电子邮件网络应用，则可以选择 SuSE。\n\n以上纯属个人化建议，非官方指导意见。其实 Linux 的发行版本众多，但是系统的核心——内核却系出同门，所以只要学会使用其中一种，即可触类旁通。\n\n\n\n根据我在网上搜索，发现linux的教程以及大多数人下载的有两个发行版：CentOS、Ubuntu。CentOS（已被替代为 AlmaLinux/Rocky）\n\n考虑到我对linux内核完全不熟悉，所以选择Ubuntu，因为他有桌面系统。等我上手熟悉之后再学习使用别的发行版。**因为命令行界面是 Linux 的精髓之一。善于使用命令行，可以大大提升效率。**所以，一开始可以依赖\"图形界面\"；但如果要想提升，必须让自己逐步适应\"命令行界面\"。\n\n选择22.04是因为现在最新的是24.04，但是我的教程里面是18.04，18.04官方支持已于 2023 年 5 月结束。折中选择了一个22.04（稳定，资源多）\n\n\n\n## 安装步骤：\n\n### 1.下载镜像文件\n\n在ubuntu官网找到之前的版本下载（其他下载）,注意这里下载的是桌面版不是服务器版，因为我是个人使用学习。\n\n![](虚拟机安装Linux系统/2.png)\n\n### 2.具体安装步骤\n\n参考[VMware创建虚拟机，安装Linux系统——Ubuntu22.04版本_sysin 提取码-CSDN博客](https://blog.csdn.net/jacknbv/article/details/124640386?ops_request_misc=elastic_search_misc&request_id=2297913f792d18bdb58604eff7bc251d&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~ElasticSearch~search_v2-14-124640386-null-null.142^v102^pc_search_result_base9&utm_term=linux ubuntu22.04系统安装&spm=1018.2226.3001.4187)\n\n参考softgj安装linux操作系统内核ubuntu的教程\n\n其实两个都差不多，但是CSDN博客悠悠海风介绍的更加详细，我主要参考ta的。\n\n#### 2.1创建虚拟机\n\n注意创建虚拟机我是选的第一个选项，而参考选择的第二个\n\n![](虚拟机安装Linux系统/3.png)\n\n![](虚拟机安装Linux系统/4.png)\n\n![](虚拟机安装Linux系统/5.png)![](虚拟机安装Linux系统/6.png)\n\n\n\n**我设置的CPU和内存都是4**\n\n\n\n![](虚拟机安装Linux系统/7.png)![](虚拟机安装Linux系统/8.png)![](虚拟机安装Linux系统/9.png)![](虚拟机安装Linux系统/10.png)![](虚拟机安装Linux系统/11.png)![](虚拟机安装Linux系统/12.png)![](虚拟机安装Linux系统/13.png)\n\n\n\n\n\n#### 2.2安装Ubuntu系统\n\n![](虚拟机安装Linux系统/14.png)\n\n我确实没有出现下面的情况。\n\n我安装系统的时候，会出现BIOS配置，可能你们的不会出现，在这个界面中，利用方向键切换主菜单（Boot所在的那一栏）的选项，选择驱动程序-->Hard Drive。\n\n![](虚拟机安装Linux系统/15.png)\n\n\n\n![](虚拟机安装Linux系统/16.png)\n\n\n\n**注意：这里进去可能要很久 鼠标是一个⭕ 就是正在加载，要等一下。**\n\n\n\n![](虚拟机安装Linux系统/17.png)\n\n![](虚拟机安装Linux系统/18.png)\n\n![](虚拟机安装Linux系统/19.png)\n\n![](虚拟机安装Linux系统/20.png)\n\n![](虚拟机安装Linux系统/21.png)\n\n![](虚拟机安装Linux系统/22.png)\n\n![](虚拟机安装Linux系统/23.png)\n\n安装的时间可能需要二三十分钟。\n这样就安装完了。\n\n","tags":["虚拟机","Linux内核","ubuntu"],"categories":["软件安装"]},{"title":"机器人模型描述格式URDF","url":"/2025/08/02/机器人模型描述格式URDF/","content":"\n\n\n<!--more-->\n\n参考：\n\n[ROS机器人建模与仿真（一）——URDF模型的建立和改进-CSDN博客](https://blog.csdn.net/qq_43551910/article/details/121773348)\n\n[(68 封私信 / 20 条消息) 开源URDF文件数据集 - 知乎](https://zhuanlan.zhihu.com/p/1889001005816976558)\n\n\n\n# 什么是URDF格式\n\nURDF，全称是Unified Robot Description Format，统一机器人描述格式。URDF文件格式用于描述机器人最早是由机器人操作系统（ROS）的开发人员在2009年引入，是一种描述机器人的运动学、动力学和几何形状的通用格式文件，独立于软件程序，方便不同的软件工具以及开发人员共享机器人数据模型。URDF文件重要的一点是其可读性，因为它是XML类型的文本文件。URDF文件中可以描述机器人的运动学结构、动力学参数、视觉外观（通过引用其它文件）和几何碰撞边界（通过引用其它文件）。\n\nURDF 是 ROS 中机器人模型的描述格式，包含对机器人刚体外观、物体属性、关节类型等方面的描述。URDF（Unified Robot Description Format，统一机器人描述格式）是 ROS 中一个非常重要的机器人模型描述格式，ROS 同时也提供 URDF 文件的 C++ 解析器，可以解析 URDF 文件中使用 XML 格式描述的机器人模型。\n\n\n\n\n# 1 URDF 文件中常用的标签\n\n## 1.1 < link > 标签\n\n< link >标签用于描述机器人某个刚体部分的**外观和物理属性**，包括尺寸（size）、颜色（color）、形状（shape）、惯性矩阵（inertial matrix）、碰撞参数（collision properties）等。\n\n```\n<link name = \"<link name>\"> \n<inertial> ------------</inertial>\n\t<visual>-------------</visual>\n\t<collision>--------- </collision>\n</link>\n```\n\n< visual >用于描述机器人link部分的外观参数，< inertial >标签用于描述link的惯性参数，而< collision >标签用于描述link的碰撞属性。**一般来说，检测碰撞的link区域大于外观可视的区域，也就是说有一定的安全空间**\n\n## 1.2 < joint >标签\n\n< joint >标签用于描述机器人**关节的运动学和动力学属性**，包括关节运动的位置和速度限制。机器人关节的主要作用是连接两个刚体link，这两个link分别称为 parent link 和 child link。\n\n```\n<joint name=\"<name of the joint>\">\n\t<parent link = \"parent_link\" />\n\t<child  link = \"child_link\" />\n\t<calibration ---- />\n\t<dynamics damping ---- />\n\t<limit effort ---- />\n</joint>\n```\n\n其中必须指定joint的parent link 和 child link，还可以设置关节的其他属性。\n< calibration > : 关节的参考位置，用来校准关节的绝对位置\n< dynamics > : 用于描述关节的物理属性，例如阻尼值、物理经摩擦力等，经常在运动学仿真中用到。\n< limit > : 用于描述运动的一些极限值，包括关节运动的上下限位置、速度限制、力矩限制等。\n< mimic > : 用于描述该关节与已有关节的关系。\n< safety_controller > : 用于描述安全控制器的参数。\n\n## 1.3 < robot > 标签\n\n< robot > 是完整机器人模型的最顶层标签，< link > 和 < joint > 标签都必须包含在< robot >标签内。一个完整的机器人模型由一系列的< link > 和 < joint > 组成。\n\n< robot >标签语法如下：\n\n```\n<robot name = \"<name of the robot>\">\n\t<link> -------</link>\n\t<link> -------</link>\n\t<joint>-------</joint>\n\t<joint>-------</joint>\n</robot>\n```\n\n## 1.4 < gazebo >标签\n\n< gazebo >标签用于描述机器人模型在Gazebo中仿真所需要的参数，包括机器人材料的属性、Gzaebo 插件等。该标签不是机器人模型必须的部分，只有在 Gazebo 仿真时才需加入。\n\n< gazebo >标签的基本语法如下:\n\n```\n<gazebo reference = \"link_1\">\n\t<material> Gazebo/Black</material>\n</gazebo>\n```\n\n# 2 创建一个机器人URDF 模型\n\n## 2.1 准备工作（创建功能包和文件夹）\n\n创建test_mrobot_description功能包，依赖urdf，xacro\n在其下创建4个文件夹urdf、meshes、launch和config\n\nurdf : 用于存放机器人模型的 URDF 或 xacro 文件\nmeshes : 用于存放URDF中引用的模型渲染文件\nlaunch : 用于存放相关启动文件\nconfig : 用于存放日 rviz 的配置文件\n\n**(经过测试，URDF文件不能加入中文字符，写程序时注意将中文注释去掉！！！)**\n\n\n\n\n\n# 3.URDF文件解析\n\nURDF文件重要的一点是其可读性，因为它是**XML类型的文本文件**。可以通过tinyXML解析，OCC也有解析的能力，有自带 `XmlDrivers` / `XmlMDF` 模块，也可用 `xerces-c` 等库，不直接支持 URDF，需要自行读取 XML + 构建模型。所以可以集成起来。\n","tags":["机器人","URDF"],"categories":["机器人"]},{"title":"机器人运动学","url":"/2025/08/02/机器人运动学/","content":"\n\n\n<!--more-->\n\n**主要学习资料、参考资料**\n\n1.机器人学导论(John J. Craig 贠超 王伟)\n\n2.机器人动力学与控制（霍伟编著）\n\n3.[机器人学基础（1）-位置运动学-正运动学、逆运动学方程建立及其求解-CSDN博客](https://blog.csdn.net/Bellwen/article/details/129182436)\n\n4.[机器人学：（3）机器人运动学-CSDN博客](https://blog.csdn.net/weixin_43724057/article/details/129739113)\n\n\n\n# 一、正运动学\n\n**正运动学可以理解为，已知机械臂各个关节θ，求机械臂手末端的位置和姿态。**\n\n核心是坐标系变换链：\n`T = A1(θ1) * A2(θ2) * ... * An(θn)`\n其中每个`Ai`是关节的变换矩阵\n\n\n\n# 二、逆运动学\n\n**逆运动学可以理解为，已知机械臂末端的位置和姿态(T)，求机械臂各个关节θ**\n\n\n\n# 三、MDH和DH方法的区别\n\n1955年，**Denavit和Hartenberg**提出一种基于齐次变换矩阵的低副机构建模方法，该方法为每个连杆固连了一个坐标系，用 4x4 的变换矩阵描述相邻连杆的位姿关系，通过齐次变换建立运动学模型，被称为Denavit-Hartenberg参数模型，简称D-H模型，这种建模方法被称为D-H法。\n\n目前，D-H建模方法主要有两种：**标准 D-H 方法（Standard D-H method）**和**改进的 D-H 方法（Modified D-H method）**。这两种方法**主要区别**在于**坐标系建立的位置不同**。\n\nMDH（修正Denavit–Hartenberg）和DH（标准Denavit–Hartenberg）方法都是用于建立**串联机器人机械臂的运动学模型**的建模方法，它们的目标相同：**建立各连杆之间的坐标变换关系**。\n\n\n\n![](机器人运动学/DH.png)\n\n\n\n\n\n\n\n![](机器人运动学/MDH的特点.png)\n\n\n\n![](机器人运动学/MDH.png)\n\n## 联系（相同点）\n\n| 项目     | 内容                                                     |\n| -------- | -------------------------------------------------------- |\n| 目的     | 建立各关节坐标系之间的齐次变换，用于正逆运动学求解       |\n| 参数数量 | 都使用4个参数描述两坐标系之间的位置与方向关系（θ,d,a,α） |\n| 应用场景 | 都广泛应用于**串联**型机械臂的建模                       |\n| 变换结构 | **本质都是通过旋转和平移组合实现坐标系变换**             |\n\n\n\n参数的定义：杆件长度 a、杆件扭角 α、关节距离 d、关节转角 θ\n\n\n\n## 区别（关键差异）\n\n| 比较项         | **标准 DH 方法**                                 |            **修正 MDH 方法**            |\n| -------------- | ------------------------------------------------ | :-------------------------------------: |\n| 坐标系设置     | 旋转轴Z与下一个坐标系的Z轴共线                   | Z轴仍为关节轴，但采用不同坐标系放置规则 |\n| 坐标系放置方式 | z 轴定义关节轴，x 轴沿两 z 轴的共同垂线方向      | x 轴平行于前一坐标系的 z 轴，定义略不同 |\n| 齐次变换矩阵   | AiDH=Rz(θ)Tz(d)Tx(a)Rx(α)                        |       AiMDH=Tx(a)Rx(α)Tz(d)Rz(θ)        |\n| 适用结构       | 通用，但对某些结构建模较复杂（如冗余或特殊结构） |  更灵活，适合于复杂结构和软件自动建模   |\n| 工业应用       | 比如《机器人学：建模与控制》中大量使用DH法       |      ROS、某些仿真软件更偏好MDH法       |\n\n\n\n### 总结：\n\n标准 DH 法适合教材与理论分析，**MDH 更适合实际工程建模和复杂结构**；两者变换本质一致，仅坐标系定义与变换顺序不同。\n\n\n参数的定义：杆件长度 a、杆件扭角 α、关节距离 d、关节转角 θ\n\n**DH和MDH的四个参数的具体定义不一样（主要是对杆件长度和杆件扭角的定义不一样），齐次变换矩阵不一样（顺序不一样）。**\n\nDH参数与MDH 参数间，除 i = 0 和i = n 的某些特殊情况外，**一般地有以下关系：**\nD H 参数｛a i ，αi ，di ，θi｝ = 修改的 D H 参数｛a i₊₁ ，αi₊₁ ，di ，θi｝\n\n\n\nDH的变换矩阵是    d θ a α\n\nMDH的变换矩阵是  a α d θ\n\n<img src=\"机器人运动学/DH建模.png\" style=\"zoom:50%;\" />\n\n<img src=\"机器人运动学/mDH建模.png\" style=\"zoom:50%;\" />\n","tags":["C++","Qt","机器人运动学","研究生期间"],"categories":["机器人"]},{"title":"替换css文件之后没有重新加载样式","url":"/2025/07/31/替换css文件之后没有重新加载样式/","content":"\n\n\n<!--more-->\n\n使用的是 Qt 的 `qrc` 资源系统（比如 `\":/qss/style.qss\"`），那么只是替换文件是不够的，你需要**重新编译资源文件**。\n\n修改 `.qrc` 文件后重新运行 `rcc` 或者 **重新构建项目**。\n","tags":["C++","Qt","CSS"],"categories":["报错"]},{"title":"错误LNK2001,无法解析的外部符号，static QMetaObject","url":"/2025/07/31/QMetaObject/","content":"\n\n\n<!--more-->\n\n严重性\t代码\t说明\t项目\t文件\t行\t禁止显示状态 错误\tLNK2001\t无法解析的外部符号 \"public: static struct QMetaObject const xxxxx::staticMetaObject\" (?staticMetaObject@xxxxx@@2UQMetaObject@@B)\t\n\n# **出现场景：**\n\n在新电脑安装VS2019,和QT VS TOOLS插件之后，代码是可以正常运行生成的。后面安装了番茄助手，然后QT VS TOOLS 的插件就不见了（暂时没有找到原因） 。就出现了这个报错。\n\n\n\n这个链接错误（`LNK2001: 无法解析的外部符号 staticMetaObject`）通常是由于 **Qt 宏**（如 `Q_OBJECT`）使用不当或相关的 moc 文件没有被正确生成/链接导致的。\n\n# **常见原因及解决方案：**\n\n **1.类中使用了 `Q_OBJECT` 宏，但未运行 `moc`（Meta-Object Compiler）**\n\n​\t检查你的类 `xxxxx` 的头文件是否包含了 `Q_OBJECT` 宏。\n\n**2.头文件未被正确包含在构建系统中（尤其是非 Qt Creator 的项目）**\n\n​\t确保你的类头文件 `xxx` 已添加到项目中，而不是仅仅被引用（否则 VS 不会触发 moc）。\n\n​\t**右键 `.h` 文件 → 属性 → 设置为 “使用 MOC 编译器” 或确保 Qt VS Tools 插件启用。**\n\n![图片](QMetaObject/1.png)\n\n\n在设置之后代码可以生成，但是我觉得很奇怪为什么之前添加新文件不会需要手动修改类型呢？后面发现是QT VS TOOLS插件的问题。\n\n我重新安装之后，解决方案里面有些项目被卸载。又卸载重新安装了一次，把被卸载的项目先移除然后再添加进来。\n","tags":["C++","Qt"],"categories":["报错"]},{"title":"VS2019番茄助手安装","url":"/2025/07/29/VS2019番茄助手安装/","content":"\n\n\n<!--more-->\n\n每次安装都会忘记一些关键步骤，写下来！\n\n参考：[给 VS2019 安装个 Visual Assist x 插件 - ALLEN_2008 - 博客园](https://www.cnblogs.com/allen-blog/articles/17324636.html#!comments)\n\n[VS2019 安装番茄助手（Visual Assist x 插件）攻略_vs2019番茄助手-CSDN博客](https://blog.csdn.net/No_21name/article/details/135392409?ops_request_misc=&request_id=&biz_id=102&utm_term=番茄助手VS2019&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-8-135392409.142^v102^pc_search_result_base9&spm=1018.2226.3001.4187)\n\n\n\n## 相应环境\n\n- 系统平台：WIN11\n- VS：VS2019\n- VAX版本：Visual Assist X 10.9.2406.0（其他版本也可对应操作）\n\n## 重点说明：\n\n1. 安装VA_X_Setup2440_0.exe前，先要右键exe文件勾选兼容性。在 win7 下，Visual Assist x 可能需要兼容运行（右击，属性，兼容性设置），因为直接双击可能就给你红框崩溃。\n2. 去掉 VS2019 插件更新勾选框和 VAX 更新勾选框。（这个我没用到）\n\n## 安装步骤\n\n先上一张安装文件源图\n\n![图片](VS2019番茄助手安装/11.png)\n\n双击直接安装VA_X_Setup2406_0.exe，在装到VS2019时会发生错误，提示安装不成功（不用管，接着让它装）。**就是一直不管它，一开始会retry，后面会说错误**\n此时，\n\n​\t用 everything（一个软件，可以在网上下载） 在 Temp 文件夹找到与 VS2019 匹配的安装版本，这里是 VaXSetup.vsix，拷贝到桌面（ 重点！在出现错误窗口的时候，不要关！不要关！不要关！这个时候用everything去搜 VaXSetup.vsix ）\n\n​\t等原文件 VA_X_Setup2406_0.exe 安装完之后（VA_X_Setup2406_0.exe等它报错才能删除），会在C:\\Users\\用户\\AppData\\Local\\Microsoft\\VisualStudio\\16.0_5b3ff307（这个地方每个人是不同的，但是都是16.0_开头）\\Extensions 下产生文件。删除这个目录下所有文件夹和文件。（这个路径不一定是完全相同的）\n\n​\t使用 VaXSetup.vsix 重新安装，此时是安装到 VS2019，最终会提示安装成功。同时会在 Extensions 目录生成新的文件夹和文件。（其实对于 VS2019， VAX 是安装 Extensions 目录下的，所以如果 VAX 插件出现问题，则可以多次删除，多次重装。2010 及之前版本则不同。）\n\n​\t用破解的 VA_X64.dll 和 PiaoYun64.dll 拷贝到 Extensions/随机文件夹(就一个文件夹，名字是随机的)/ ，路径下（简单一点的话就用everything搜VA_X.dll,找到类似这个路径，把VA_X64.dll 和 PiaoYun64.dll 拷贝进去）。\n\n​\t找到 VS2019 的安装目录。具体为：右击 VS2019 图标->属性，在快捷方式栏找到“目标”，“目标”后面的文本框就是 [VS2019 安装](https://so.csdn.net/so/search?q=VS2019 安装&spm=1001.2101.3001.7020)目录.（如图）\n\n![图片](VS2019番茄助手安装/22.png)\n\n​\t按住win+R，输入cmd打开，在命令行切换到 5（第五步） 的目录，运行命令：devenv.exe /safemode，回车（安全模式下运行一回）（如图）。此时在 VS2019 插件管理有 Visual Assist x 插件，但不能用。直接关闭 VS2019。\n\n怎么用命令行进入：\n\n默认是在C盘 所以先输入 d: 进入D盘\n\n然后使用cd可以进入目标目录（或者文件夹打开之后会自动进去像我的一样）\n\n![图片](VS2019番茄助手安装/44.png)\n\n<img src=\"VS2019番茄助手安装/33.png\" alt=\"图片\" style=\"zoom:80%;\" />\n\n​\t这次正常打开 VS2019，最终会看到 extension 菜单下出现 Visual Assist x。\n\n​\t这还没完。需要去掉插件更新和 Visual Assist x 更新勾选。具体为：\n　　* ​\t拓展->管理拓展->已安装->弹出对话框的右上角，具体下图。\n\n![图片](VS2019番茄助手安装/55.png)\n\n![图片](VS2019番茄助手安装/66.png)\n\nVisual Assist x options 对话框左边->startup，见下图。\n\n![图片](VS2019番茄助手安装/77.png)\n\n![图片](VS2019番茄助手安装/88.png)\n\n\n\n在这里可以设置快捷键生成注释块\n\n\n\n\n\n![图片](VS2019番茄助手安装/99.png)\n\n\n\n![图片](VS2019番茄助手安装/100.png)\n","tags":["C++","软件安装","番茄助手"],"categories":["软件安装"]},{"title":"std::greater()和std::less()在排序和建堆的应用以及自定义比较函数的规则","url":"/2025/07/28/std-greater-和std-less-在排序和建堆的应用以及自定义比较函数的规则/","content":"\n<!--more-->\n\n\n\n# 解释\n\n## 比较规则：strict weak ordering\n\n`std::greater()`、`std::less()`、自定义比较函数，这些都其实是用作比较的，要遵从c++制定的比较规则。\n\n![图片](std-greater-和std-less-在排序和建堆的应用以及自定义比较函数的规则/compare.png)\n\n需要满足三种特性要求，否则使用中会报错：\n\n- 反自反性：`false`\n- `true`的互斥性：`true`则`false`（但不要求`false`则怎么样）\n- 传递性：`true`＋`true`则`true`\n\n## less和greater其实是什么\n\n两个函数的头文件是functional\n\n比如`less`\n\n```\ntemplate <class T> struct less {\n  bool operator() (const T& x, const T& y) const {return x<y;}\n  typedef T first_argument_type;\n  typedef T second_argument_type;\n  typedef bool result_type;\n};\n```\n\n可以看到关键就是**bool operator()**和**return x<y;**\n\n**bool operator()**：要的就是这个返回值bool，**决定比较是否要交换。这个结果用在排序和建堆中就表示是否要交换。**\n**return x<y;**：可以看到其实就是使用<之类的操作符重载，这就是怎么排序的规则。\nPS：但这产生了限制，基本的元素int之类的，自然可以直接比较；但复杂类型如自定义一个类，里面有多个数据，我们就还得定义重载操作符比较，要不然编译器不知道该比较什么。\n\n\n\n## bool返回值和比较操作符\n\n### 规则\n\n`bool comp(a, b)`意思是：返回的值指示作为第一个参数传递的元素是否被视为在其定义的特定严格弱排序中位于第二个参数之前。\n\n- 返回`true`：表示`ab`(`a`在`b`前）\n- 返回`false`：表示`ba`（a`在`b`后）\n\n![图片](std-greater-和std-less-在排序和建堆的应用以及自定义比较函数的规则/11.png)\n\n### 并不是想当然的位置交换\n\ncomp(a, b)虽然会交换a和b，但你不能想当然地认为位置就该怎么样，到底数组中谁会是a，谁会是b，这要看调用的算法的。\n\n比如，[a < b]  [6 < 1] : 0，其实是算法调用时a是6，b是1，而非看到数组中原来的顺序就想当然的a是1，b是6。\n\n\n\n\n\n\n# 知识基础\n\n## 参考我的[priority_queue]()博客\n\n这里简略再复述一些助于理解的关键信息。\n\n什么是**优先级队列**呢？\n\n其实***就是一个披着队列外衣的堆***，因为优先级队列对外接口只是从队头取元素，从队尾添加元素，再无其他取元素的方式，看起来就是一个队列。\n\n优先级队列内部元素是自动依照元素的**权值**排列。\n\n所以大家经常说的**大顶堆**（堆头是最大元素），**小顶堆**（堆头是最小元素），如果懒得自己实现的话，**就直接用priority_queue（优先级队列）就可以了，底层实现都是一样的**，从小到大排就是小顶堆，从大到小排就是大顶堆。\n\npriority_queue 容器适配器模拟的也是队列这种存储结构，即使用此容器适配器存储元素只能“从一端进（称为队尾），从另一端出（称为队头）”，且每次只能访问 priority_queue 中位于队头的元素。\n\n但是，priority_queue 容器适配器中元素的存和取，遵循的并不是 “First in,First out”（先入先出）原则，而是“***\\*First in，Largest out\\****”原则。直白的翻译，指的就是先进队列的元素并不一定先出队列，而是优先级最大的元素最先出队列。（**Largest out**是指权重最大）\n\n**通过以上的内容，我们可以用priority_queue来理解下面的内容。**\n\n<img src=\"std-greater-和std-less-在排序和建堆的应用以及自定义比较函数的规则/priority_queue.png\" alt=\"图片\" style=\"zoom:75%;\" />\n\n# 结论\n\n## 排序和建堆的效果\n\n### 排序：\n\nless<T>变成**升序**（从左到右遍历下标时，数组元素是**从小到大**）\ngreater<T>变成**降序**（从左到右遍历下标时，数组元素是**从大到小**）\n\n### 建堆：\n\nless<T>变成**大顶堆**（从上层到下层，堆元素是从大到小，同层之间随便）\ngreater<T>变成小顶堆（从上层到下层，堆元素是从小到大，同层之间随便）\n\n### 默认情况下：\n\n**建堆**的时候，默认是**大根堆**（堆头是最大元素），第三个参数用greater<T>会变成小根堆；\n\n**排序**的时候，默认是**从小到大**，但是第三个参数用greater<T>会变成从大到小\n\n可以看到默认情况下都是用**less**，但是**看起来是“反转”的**。这其实是两种操作的本质逻辑不同导致的\n\n\n\n## 解释结论\n\n我觉得下面解释的还是有点不好理解。以下是我**个人的理解**。从模拟过程和bool返回值来分析。\n\n我们在**排序**一个数组{a,b,c,d}的时候，如果是自己去实现排序（升序）的功能，大致的思路是，**从头到尾**每次遍历两个元素，如果a>b，less返回false不满足less函数的x<y。不满足升序要求，需要交换两个数的位置，使其要满足x<y。所以是从小到大，升序。\n\n对于 `std::sort` 默认使用的升序排序，它会判断 `less(x, y)` 是否为 true，即 `x < y`。如果返回 **false**，说明当前两个元素顺序**不对**，就会交换，从而实现升序排列。\n\n如果是**priority_queue**，priority_queue不是算法，是容器适配器，是优先级队列。**它的“优先级”是由 Compare 来定义的。**它需要在编译期确定比较器类型，并实例化一个对象在内部反复调用，它初始化的时候就要确定Compare是什么。因为priority_queue<T,Container,Compare>。Compare去决定它的优先级设置方法。\n\n想象一下在priority_queue（大顶堆）插入一个新元素a，从队尾push，priority_queue会更具Compare（less）制定的排序规则判断优先级。如果是a<top，那less返回true，就不用交换两个数的位置。所以是大顶堆\n\n比如你用 `less<int>`，即 `x < y`，那么在比较时，如果 **`less(a, top)` == true**，说明 a 比 top 小，优先级低，就不需要上浮 a；\n\n如果 **`less(top, a)` == true**，说明 a 优先级高（大顶堆），需要上浮。\n\n### **排序（`std::sort`）**\n\n默认行为：`std::less<T>` → **升序**\n\n```\nstd::vector<int> v = {3, 1, 4, 2};\nstd::sort(v.begin(), v.end(), std::less<int>()); // 默认就是升序\n// 结果：1, 2, 3, 4\n```\n\n- **比较逻辑**：`std::less` 比较 `a < b`，**如果 `true`，则 `a` 应该排在 `b` 前面。**\n- **效果**：较小的元素在前，整体是升序。\n\n使用 `std::greater<T>` → **降序**\n\n```\nstd::sort(v.begin(), v.end(), std::greater<int>());\n// 结果：4, 3, 2, 1\n```\n\n- **比较逻辑**：`std::greater` 比较 `a > b`，如果 `true`，则 `a` 应该排在 `b` 前面。\n- **效果**：较大的元素在前，整体是降序。\n\n**结论**：在排序中，`std::less` → 升序，`std::greater` → 降序，符合直觉。\n\n\n\n### **建堆（`std::priority_queue` 或堆算法）**\n\n默认行为：`std::less<T>` → **大顶堆**\n\n```\nstd::priority_queue<int> pq; // 默认是 std::less<int>，大顶堆\npq.push(3); pq.push(1); pq.push(4);\n// 弹出的顺序是 4, 3, 1\n```\n\n- **堆的性质**：父节点 >= 子节点（堆顶是最大值）。\n- **比较逻辑**：`std::less` 比较 `a < b`，**如果 `true`，则 `b` 优先级更高（会被放到堆顶）**。\n  - **为什么看起来是“反转”的？**\n    因为 `std::priority_queue` 的设计是“优先级高的先弹出”，而默认情况下它用 `std::less` 来决定谁“优先级更高”。\n  - 默认 `std::less` 表示“更小的值优先级更低”，因此更大的值优先级更高，会放在堆顶。\n    - 如果 `a < b` 为 `true`，说明 `b` 比 `a` 大，所以 `b` 应该排在更前面（堆顶）。\n\n使用 `std::greater<T>` → **小顶堆**\n\n```\nstd::priority_queue<int, std::vector<int>, std::greater<int>> pq; // 小顶堆\npq.push(3); pq.push(1); pq.push(4);\n// 弹出的顺序是 1, 3, 4\n```\n\n- **堆的性质**：父节点 <= 子节点（堆顶是最小值）。\n- **比较逻辑**：**`std::greater` 比较 `a > b`，如果 `true`，则 `b` 优先级更高（会被放到堆顶）。**\n  - 如果 `a > b` 为 `true`，说明 `b` 比 `a` 小，所以 `b` 应该排在更前面（堆顶）。\n\n**结论**：在建堆中，`std::less` → 大顶堆，`std::greater` → 小顶堆，看起来和排序是“反转”的。\n\n\n\n\n\n\n\n\n\n# 自定义\n\n符合两个条件：\n\n​\tbool：返回值bool\n​\treturn x<y;：重载<之类的操作符，并且要决定比较什么元素。\n​\tPS：建议还要常引用，保险，禁止发生修改要比较的元素可能。\n\n## 数组\n\n**函数：使用时不加括号，加了报错。写成 `bool cmp(const T&, const T&)` 是因为 `sort` 要传入一个 **函数指针**。**\n**类的对象（仿函数）：注意，排序时的类必须使用类的对象才对，直接使用类报错。重载 `()` 是因为 `sort` 接受“可调用对象”，仿函数对象本质上是**重载了括号运算符的类对象**。**不能传入类名，而是类的实例**：类名是类型，不能调用 `operator()`，而类对象才是“可调用的”。**\n\n\n\n```\n#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\n// 重写排序函数\nbool cmpfunc(const int &a, const int &b)\n{\n    return a < b;\n    // < 升序; > 降序\n}\n\n// 模仿less、greater构建类\nstruct cmpClass\n{\n    bool operator()(const int &i, const int &j)\n    {\n        return (i < j);\n    }\n}cmpClassObject;\t\t// 注意，排序时的类必须使用类的对象才对，使用类报错。\n\nint main()\n{\n\t// 使用函数\n    vector<int> v1 = {2, 3, 1, 6, 2, 5, 4};\n    // 使用时不加括号，加了报错\n    sort(v1.begin(), v1.end(), cmpfunc);\n    for (int i = 0; i < v1.size(); i++)\n    {\n        cout << v1[i] << \" \";\n    }\n    cout << endl;\n    // 1 2 2 3 4 5 6\n    \n    // 使用类的对象\n    vector<int> v2 = {2, 3, 1, 6, 2, 5, 4};\n    sort(v2.begin(), v2.end(), cmpClassObject);\n    for (int i = 0; i < v2.size(); i++)\n    {\n        cout << v2[i] << \" \";\n    }\n    cout << endl;\n    // 1 2 2 3 4 5 6\n    return 0;\n```\n\n\n\n## 优先级队列\n\n### `priority_queue<T, Container, Compare>`\n\n这里 `Compare` 是一个**仿函数类型**，用于控制“谁优先”。\n\n比较对象 **必须是 `()` 重载形式**（即仿函数），因为 STL 库底层会调用 `comp(a, b)`。\n\n### 为什么 `priority_queue` 的比较器不能写成函数？\n\n因为它需要在编译期确定比较器类型，并实例化一个对象在内部反复调用：\n\n```\npriority_queue<T, vector<T>, cmpClass> q;\n```\n\n\n\n- 定义类时同时定义**操作符重载函数**：操作符重载函数，必须是具体的**操作符<**之类的，写()报错------一个自定义类 重载函数<在类内\n- 自定义类，**自定义比较函数**：操作符重载函数，必须是具体的**操作符<**之类的，写()报错---------------一个自定义类  重载函数<在类外\n- 自定义类，自定义包含**比较函数的结构体**：**操作符重载函数，必须是写()**-----------------------------------一个自定义类，一个比较函数的结构体（）\n\n```\n#include <iostream>\n#include <queue>\nusing namespace std;\n\n/******** 定义类时同时定义操作符重载函数 ********/\nstruct Node1\n{\n    // 要比较的元素\n    int x;\n    // 构造函数\n    Node1(int x) { this->x = x; }\n    // 操作符重载函数，必须是具体的操作符<之类的，写()报错\n    bool operator<(const Node1 &b) const\n    {\n        // 实现less中需要的<,大顶堆\n        return x < b.x;\n    }\n};\n\n/******** 自定义类，自定义比较函数 ********/\nstruct Node2\n{\n    // 要比较的元素\n    int x;\n    // 构造函数\n    Node2(int x) { this->x = x; }\n};\n\n// 操作符重载函数，必须是具体的操作符<之类的，写()报错\nbool operator<(const Node2 &a, const Node2 &b)\n{\n    // less,大顶堆\n    return a.x < b.x;\n}\n\n/******** 自定义类，自定义包含比较函数的结构体 ********/\nstruct Node3\n{\n    // 要比较的元素\n    int x;\n    // 构造函数\n    Node3(int x) { this->x = x; }\n};\n\nstruct cmpClass\n{\n    // 操作符重载函数，必须是写()\n    bool operator()(const Node3 &a, const Node3 &b)\n    {\n        // less,大顶堆\n        return a.x < b.x;\n    }\n};\n\nint main()\n{\n    /******** 初始化优先级队列的对象p ********/\n    // Node1类型，默认使用vector，小顶堆，同 priority_queue<Node1, vector<Node1>, less<Node1> > p;\n    priority_queue<Node1> p;\n    // 乱序入队\np.emplace(1);\np.emplace(3);\np.emplace(2);\n\n// 弹出队首\nwhile (!p.empty())\n{\n    cout << p.top().x << \" \";\n    p.pop();\n}\ncout << endl;\n// 3 2 1\n\n/******** 初始化优先级队列的对象q ********/\n// 同 priority_queue<Node2> q;\npriority_queue<Node2, vector<Node2>, less<Node2>> q;\n\n// 乱序入队\nq.emplace(1);\nq.emplace(3);\nq.emplace(2);\n\n// 弹出队首\nwhile (!q.empty())\n{\n    cout << q.top().x << \" \";\n    q.pop();\n}\ncout << endl;\n// 3 2 1\n\n/******** 初始化优先级队列的对象r ********/\npriority_queue<Node3, vector<Node3>, cmpClass> r;\n\n// 乱序入队\nr.emplace(1);\nr.emplace(3);\nr.emplace(2);\n\n// 弹出队首\nwhile (!r.empty())\n{\n    cout << r.top().x << \" \";\n    r.pop();\n}\ncout << endl;\n// 3 2 1\nreturn 0;\n```\n\n\n参考：[C++：std::greater()、std::less()、自定义比较函数的规则-CSDN博客](https://blog.csdn.net/sandalphon4869/article/details/105419706)\n","tags":["C++","排序","堆","优先队列","priority_queue","比较函数"],"categories":["C++"]},{"title":"堆(heap)结构","url":"/2025/07/28/堆结构/","content":"\n<!--more-->\n\n","tags":["堆","数据结构","完全二叉树"],"categories":["数据结构"]},{"title":"priority_queue","url":"/2025/07/28/priority-queue/","content":"\n<!--more-->\n\n参考：[C++ STL priority_queue容器适配器详解 - C语言中文网](https://c.biancheng.net/view/6987.html)\n\n[代码随想录](https://www.programmercarl.com/0347.前K个高频元素.html#算法公开课)\n\n## **优先级队列**\n\n### 以下参考代码**随想录**\n\n什么是优先级队列呢？\n\n其实**就是一个披着队列外衣的堆**，因为优先级队列对外接口只是从队头取元素，从队尾添加元素，再无其他取元素的方式，看起来就是一个队列。\n\n而且优先级队列内部元素是自动依照元素的权值排列。那么它是如何有序排列的呢？\n\n缺省情况下priority_queue利用max-heap（大顶堆）完成对元素的排序，这个大顶堆是以vector为表现形式的complete binary tree（完全二叉树）。\n\n什么是堆呢？\n\n**堆是一棵完全二叉树，树中每个结点的值都不小于（或不大于）其左右孩子的值。** 如果父亲结点是大于等于左右孩子就是大顶堆，小于等于左右孩子就是小顶堆。\n\n所以大家经常说的大顶堆（堆头是最大元素），小顶堆（堆头是最小元素），如果懒得自己实现的话，就直接用priority_queue（优先级队列）就可以了，底层实现都是一样的，从小到大排就是小顶堆，从大到小排就是大顶堆。\n\n\n\n### 以下参考**C语言中文网**\n\npriority_queue 容器适配器模拟的也是队列这种存储结构，即使用此容器适配器存储元素只能“从一端进（称为队尾），从另一端出（称为队头）”，且每次只能访问 priority_queue 中位于队头的元素。\n\n但是，priority_queue 容器适配器中元素的存和取，遵循的并不是 “First in,First out”（先入先出）原则，而是“**First in，Largest out**”原则。直白的翻译，指的就是先进队列的元素并不一定先出队列，而是优先级最大的元素最先出队列。\n\n> 注意，“First in，Largest out”原则是笔者为了总结 priority_queue 存取元素的特性自创的一种称谓，仅为了方便读者理解。\n\n那么，priority_queue 容器适配器中存储的元素，优先级是如何评定的呢？很简单，每个 priority_queue 容器适配器在创建时，都制定了一种排序规则。根据此规则，该容器适配器中存储的元素就有了优先级高低之分。\n\n举个例子，假设当前有一个 priority_queue 容器适配器，其制定的排序规则是按照元素值从大到小进行排序。根据此规则，自然是 priority_queue 中值最大的元素的优先级最高。\n\npriority_queue 容器适配器为了保证每次从队头移除的都是当前优先级最高的元素，每当有新元素进入，它都会根据既定的排序规则找到优先级最高的元素，并将其移动到队列的队头；同样，当 priority_queue 从队头移除出一个元素之后，它也会再找到当前优先级最高的元素，并将其移动到队头。\n\n基于 priority_queue 的这种特性，因此该容器适配器有被称为**优先级队列**。\n\n> priority_queue 容器适配器“First in，Largest out”的特性，和它底层采用**堆结构**存储数据是分不开的。有关该容器适配器的底层实现，后续章节会进行深度剖析。\n\n[STL](https://c.biancheng.net/stl/) 中，priority_queue 容器适配器的定义如下：\n\n```\ntemplate <typename T,\n        typename Container=std::vector<T>,\n        typename Compare=std::less<T> >\nclass priority_queue{\n    //......\n}\n```\n\n可以看到，priority_queue 容器适配器模板类最多可以传入 3 个参数，它们各自的含义如下：\n\n- typename T：指定存储元素的具体类型；\n\n- typename Container：指定 priority_queue 底层使用的基础容器，默认使用 vector 容器。\n\n  > 作为 priority_queue 容器适配器的底层容器，其必须包含 empty()、size()、front()、push_back()、pop_back() 这几个成员函数，[STL](https://c.biancheng.net/stl/) 序列式容器中只有 vector 和 deque 容器符合条件。\n\n- typename Compare：指定容器中评定元素优先级所遵循的排序规则，默认使用\n\n  ```\n  std::less<T>\n  ```\n\n  ##### 按照元素值从大到小进行排序，还可以使用\n\n  ```\n  std::greater<T>\n  ```\n\n  按照元素值从小到大排序，但更多情况下是使用自定义的排序规则。\n\n  > 其中，std::less<T> 和 std::greater<T> 都是以函数对象的方式定义在 <function> 头文件中。关于如何自定义排序规则，后续章节会做详细介绍。\n\n#### 创建priority_queue的几种方式\n\n由于 priority_queue 容器适配器模板位于`<queue>`头文件中，并定义在 std 命名空间里，因此在试图创建该类型容器之前，程序中需包含以下 2 行代码：\n\n```\n#include <queue>\nusing namespace std;\n```\n\n创建 priority_queue 容器适配器的方法，大致有以下几种。\n\n1) 创建一个空的 priority_queue 容器适配器，第底层采用默认的 vector 容器，排序方式也采用默认的 std::less<T> 方法：\n\n```\nstd::priority_queue<int> values;\n```\n\n2) 可以使用普通数组或其它容器中指定范围内的数据，对 priority_queue 容器适配器进行初始化：\n\n```\n//使用普通数组\nint values[]{4,1,3,2};\nstd::priority_queue<int>copy_values(values,values+4);//{4,2,3,1}\n//使用序列式容器\nstd::array<int,4>values{ 4,1,3,2 };\nstd::priority_queue<int>copy_values(values.begin(),values.end());//{4,2,3,1}\n```\n\n注意，**以上 2 种方式必须保证数组或容器中存储的元素类型和 priority_queue 指定的存储类型相同**。另外，用来初始化的数组或容器中的数据不需要有序，priority_queue 会自动对它们进行排序。\n\n3) 还可以手动指定 priority_queue 使用的底层容器以及排序规则，比如：\n\n```\nint values[]{ 4,1,2,3 };\nstd::priority_queue<int, std::deque<int>, std::greater<int> >copy_values(values, values+4);//{1,3,2,4}\n```\n\n事实上，std::less<T> 和 std::greater<T> 适用的场景是有限的，更多场景中我们会使用自定义的排序规则。\n\n> 由于自定义排序规则的方式不只一种，因此这部分知识将在后续章节做详细介绍。\n\n\n\n#### priority_queue提供的成员函数\n\npriority_queue 容器适配器提供了表 2 所示的这些成员函数。\n\n\n\n| 成员函数                       | 功能                                                         |\n| ------------------------------ | ------------------------------------------------------------ |\n| empty()                        | 如果 priority_queue 为空的话，返回 true；反之，返回 false。  |\n| size()                         | 返回 priority_queue 中存储元素的个数。                       |\n| top()                          | 返回 priority_queue 中第一个元素的引用形式。                 |\n| push(const T& obj)             | 根据既定的排序规则，将元素 obj 的副本存储到 priority_queue 中适当的位置。 |\n| push(T&& obj)                  | 根据既定的排序规则，将元素 obj 移动存储到 priority_queue 中适当的位置。 |\n| emplace(Args&&... args)        | Args&&... args 表示构造一个存储类型的元素所需要的数据（对于类对象来说，可能需要多个数据构造出一个对象）。此函数的功能是根据既定的排序规则，在容器适配器适当的位置直接生成该新元素。 |\n| pop()                          | 移除 priority_queue 容器适配器中第一个元素。                 |\n| swap(priority_queue<T>& other) | 将两个 priority_queue 容器适配器中的元素进行互换，需要注意的是，进行互换的 2 个 priority_queue 容器适配器中存储的元素类型以及底层采用的基础容器类型，都必须相同。 |\n\n> 和 queue 一样，priority_queue 也没有迭代器，因此访问元素的唯一方式是遍历容器，通过不断移除访问过的元素，去访问下一个元素。\n\n\n\n\n\n## 在 C++ 中，`emplace` 和 `push` 的区别\n\n`emplace` 和 `push` 都可以用来向容器中添加元素，但它们的工作方式有所不同。在这个特定的代码中，使用 `emplace` 比 `push` 更高效，原因如下：\n\n###  **`emplace` 直接构造元素**\n\n- `q.emplace(nums[i], i)` 会直接在优先队列的内存中构造一个 `pair<int, int>` 对象，避免了临时对象的创建和拷贝/移动操作。\n- 它等价于 `q.push(std::pair<int, int>(nums[i], i))`，但更高效，因为 `emplace` 直接在容器内部构造对象，省去了额外的拷贝或移动开销。\n\n### **`push` 需要构造临时对象**\n\n- 如果使用 `push`，你需要显式构造一个 `pair` 对象，如 `q.push(make_pair(nums[i], i))` 或 `q.push({nums[i], i)})`。\n- 这会先创建一个临时 `pair` 对象，然后将其拷贝或移动到优先队列中，多了一次不必要的构造和拷贝/移动操作。\n\n### **性能优势**\n\n- 对于像 `pair<int, int>` 这样的简单类型，`emplace` 和 `push` 的性能差异可能不大，但在更复杂的场景（如构造含多个参数的对象）时，`emplace` 能显著减少开销。\n- 由于 `emplace` 是 C++11 引入的优化方式，它更符合现代 C++ 的高效编程风格。\n\n### 代码对比\n\ncpp\n\n```\n// 使用 emplace（推荐）\nq.emplace(nums[i], i);  // 直接在优先队列中构造 pair\n\n// 使用 push（需要构造临时对象）\nq.push(std::make_pair(nums[i], i));  // 先构造临时 pair，再拷贝/移动到队列\n```\n","tags":["C++","C++基础","STL","容器适配器"],"categories":["C++"]},{"title":"C++数字与字符串互相转换","url":"/2025/07/28/C-零碎知识/","content":"\n<!--more-->\n\n\n\n# C/C++数字与字符串互相转换\n\n参考：原文链接：https://blog.csdn.net/m0_73633807/article/details/140817283\n\n### 字符串转为数字\n\n#### 一、利用ASCII\n\n我们知道每个字符都有一个ASCII码，利用这一点可以将字符-'0'转为数字。在[字母大小写转换](https://so.csdn.net/so/search?q=字母大小写转换&spm=1001.2101.3001.7020)时也可以利用这个性质。\n\n![图片](C-零碎知识/ASCII.png)\n\n```\n#include<iostream>\n#include<cstring>\nusing namespace std;\nchar ch[]={'1','2','3','4','5'};\nint main(){\n\tfor(int i=0;i<strlen(ch);i++){\n\t\tcout<<ch[i]-'0'<<\" \";\n\t}\n\treturn 0;\n}\n```\n\n#### 二、stoi()\n\n**stoi**函数是C++标准库中的一个函数，用于将字符串转换为整数，针对于string类型的。stoi函数是C++11引入的，因此只有在C++11及以上的版本中才能使用该函数。如果你的编译器版本较老，不支持C++11，那么就无法使用stoi函数。学校机房的dev-C++一般是C98标准的，需要自己手动改成C11。\n\n```\nint num=stoi(const string&  str, size_t* idx = 0, int base = 10);\n```\n\n其中，str是需要转换的字符串；idx是一个指向size_t类型的指针，用于保存转换结束的位置；base是进制，默认为10进制。一般只给传第一个参数即可，也可以利用此函数实现进制转换。\n\n类似的还有**stol()、stof()、stod(),**分别将字符串类型转换成long long、float、double类型。\n\n\n```\n#include<iostream>\n#include<cstring>\n \nusing namespace std;\nstring s=\"12345\";\nint main(){\n\tint a=stoi(s);\n\tlong long b=stol(s);\n\tdouble c=stod(s);\n\tfloat d=stof(s);\n\tcout<<\"int:\"<<a<<endl;\n\tcout<<\"long long:\"<<b<<endl;\n\tcout<<\"double:\"<<c<<endl;\n\tcout<<\"float:\"<<d<<endl;\n\treturn 0;\n}\n```\n\n#### 三、atoi()\n\natoi()函数是C语言中的一个函数，主要用于将字符串转换为整数。针对于字符数组,类似的还有atol()、atof()、atod()。\n\n```\nint num=atoi(const char *str);\n```\n\n其中，str是一个以null结尾的字符串，表示要转换的整数。\n\n该函数将从字符串的开头开始解析，直到遇到第一个非数字字符为止。如果开头是一个正号或负号，它也会解析为整数的一部分。如果字符串中的第一个非空格字符不是有效的数字字符或正负号，则返回0。\n\n#### 四、sscanf()\n\nsscanf函数是一个用来将字符串按照指定格式解析的函数。它接受一个输入字符串和一个格式字符串作为参数，并根据格式字符串的指示将字符串中的数据解析为对应的变量中。主要是针对于字符数组。\n\n```\nsscanf(str,\"%d\",&num);//str字符数组,%dint类型,num转换完成数字\n```\n\n#### 五、stringstream\n\nstringstream是C++中的一个类，可以用来对字符串进行输入输出操作。它是基于字符串的流，可以用来将字符串转换为其他类型的数据，以及将其他类型的数据转换为字符串。stringstream类的头文件是<sstream>，我们需要包含这个头文件才能使用stringstream类。\n\n```\n#include<iostream>\n#include<sstream>\n#include<cstring>\n#include<typeinfo>\n \nusing namespace std;\nint main(){\n\tstringstream ss;\n\tstring s=\"12345\";\n\tint num;\n\tss<<s;//将字符串读入字符串流 \n\tss>>num;//从字符串流中读取数据转换为整数\n\tcout<<typeid(num).name()<<\" \"<<num<<endl;\n\treturn 0; \n}\n```\n\n\n\n### 数字转为字符串\n\n#### 一、利用ASCII\n\n字符转数字可以-'0'，数字转字符那么就可以+'0'，还是利用了ASCII码值的特性。\n\n```\n#include<iostream>\n#include<cstring>\nusing namespace std;\nint nums[]={1,2,3,4,5};\nint main(){\n\tfor(int i=0;i<sizeof(nums)/sizeof(int);i++){\n\t\tcout<<nums[i]+'0'<<\" \";\n\t}\n\treturn 0;\n}\n```\n\n注意：转换结果为49 50 51 52 53 ，对应ASCII码值，因为原理就是用[ASCII码转换](https://so.csdn.net/so/search?q=ASCII码转换&spm=1001.2101.3001.7020)的。\n\n#### 二、to_string()\n\nto_string函数是C++标准库提供的一个函数，用于将不同类型的数据转换为字符串。可以将int、float、double、long long等类型转换为string类型。**需要包含头文件#include<cstring>**\n\n```\n#include<iostream>\n#include<cstring>\nusing namespace std;\nint a=24;\nlong long b=12345678;\ndouble c=3.1415;\nstring s;\nint main(){\n\ts=to_string(a);\n\tcout<<s<<endl;\n\ts=to_string(b);\n\tcout<<s<<endl;\n\ts=to_string(c);\n\tcout<<s<<endl;\n\treturn 0;\n}\n```\n\n#### 三、itoa()\n\nitoa函数用于将整数转换为字符串。类似的还有ltoa、ftoa、dtoa分别将long long、float、double转换为字符串类型。针对于字符数组。\n\n```\nitoa(num,str,10);\n```\n\n第一个参数是待转换的数字，第二个参数是转换完成的字符数组，第三个是转换的进制数，默认10进制。\n\n```\n#include<iostream>\n#include<cstring>\nusing namespace std;\nint n=12345;\nchar str[10];\nint main(){\n\titoa(n,str,10); \n\tcout<<str<<endl;\n\treturn 0;\n}\n```\n\n#### 四、sprintf()\n\nsprintf()函数是c语言库中的函数，可以将数字转换为字符串类型，一般转换为字符数组。\n\n```\nsprintf(str,\"%d\",num);\n```\n\nstr是转换完成的字符数组，%d是类型，num是待转换的数字。 \n\n```\n#include<iostream>\n#include<cstring>\nusing namespace std;\nint n=12345;\nchar str[10];\nint main(){\n\tsprintf(str,\"%d\",n); \n\tcout<<str<<endl;\n\treturn 0;\n}\n```\n\n#### 五、stringstream\n\n与字符串转数字的一样，可以互相转换，同时还是要包含**头文件<sstream>，具体使用如下**\n\n```cpp\n#include<iostream>\n#include<sstream>\n#include<cstring>\n#include<typeinfo>\n \nusing namespace std;\nint main(){\n\tstringstream ss;\n\tstring s=\"12345\";\n\tint num=54321;\n\tss<<num;//将int类型的数据写入字符串流中\n\ts=ss.str();//将字符串流中的数据转换为string类型\n\tcout<<typeid(s).name()<<\" \"<<num<<endl;\n\treturn 0; \n}\n```\n\n\n\n\n\n# 个人总结：\n\n在C++中：\n\n**字符串转数字**：常用ASCII、stoi()\\stod()\\stol()\\stoll()。 ASCII只能是一位数字，stoi()\\stod()\\stol()\\stoll()适用于各种类型。\n\nstoi-----string to int\n\n\n\n**数字转为字符串**：常用ASCII、**to_string()**（要包含头文件#include<cstring>）\n","tags":["C++","刷题"],"categories":["C++"]},{"title":"无法打开“mscoree.lib”错误","url":"/2025/07/24/无法打开“mscoree-lib”错误/","content":"\n\n\n<!--moore-->\n\n需要在下载VS的时候加插件\n\n下载了的也可以直接打开VS Install修复\n\n![图片](无法打开“mscoree-lib”错误/2.png)\n\n\n\n需要添加\n\n![图片](无法打开“mscoree-lib”错误/1.jpg)\n\n\n\n同时，我还安装了.NET Framework 4.8 SDK\n\n在单个组件里面。\n","tags":["C++","VS","C#","hsl库"],"categories":["报错"]},{"title":"QtInstallation问题","url":"/2025/07/24/QtInstallation问题/","content":"\n\n\n<!--more-->\n\n​\t在安装好VS2019和Qt5.14.2之后，我准备跑之前的代码，打开代码之后vs提示的错误如下：\n\n![图片](QtInstallation问题/1.png)\n\n\n\n这里主要解决第一个。\n\nThe project's'Qt Installation' property is not set correctly.Please specify a valid Qt version or path.\n\n\n\n在vs 点击“扩展“ --> ”Qt VS Tools“--->\"Qt Versions\"或者\"Options\"\n\n![图片](QtInstallation问题/2.png)\n\n\n\n在name 输入 自己qt的版本 和操作系统位数\n\n在Location 选择qt的安装路径\n\n​\t进入选择对话框后，按照安装路径进入以下文件夹，选择qmake.exe,点击打开\n\n注意： 这里要区分32位和64位\n\n![图片](QtInstallation问题/3.png)\n","tags":["Qt","QtInstallation","VS2019"],"categories":["Qt"]},{"title":"安装win11系统","url":"/2025/07/24/安装win11系统/","content":"\n<!--more-->\n\n 安装win11系统。\n\n参考的视频[【干货】WIN11系统安装重装教程、全程干货13分钟搞定，小白也能自己重装系统！超详细解说~_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1oG4y1d7Dv/?spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=a858a9df12a9613b40ef1eefb011b473)\n\n\n\n\n\n# 1.在U盘下载好系统\n\n## 1.1格式化U盘\n\n\n\n## 1.2搜索win11 进入官方网站\n\n[下载 Windows 11](https://www.microsoft.com/zh-cn/software-download/windows11)\n\n\n\n![图片](安装win11系统/1.png)\n\n\n\n下载第二个\n\n![图片](安装win11系统/Snipaste_2025-07-24_16-16-13.png)\n\n\n\n会下载一个文件，下载好之后打开 按照提示下载到U盘\n\n\n\n# 2.搜索电脑启动BIOS的快捷键\n\n最快的办法是百度搜索或者直接问客服\n\n联想ThinkPad 是 F12 \n\n\n\n \n\n# 3.在打开电脑但是并没有开机的时候狂按快捷键，使用U盘启动\n\n\n\n# 4.点击下一步即可\n\n这里选择第二个\n\n![图片](安装win11系统/2.png)\n\n分区可以先全部删除，进入系统之后再分区\n\n系统盘建议安装在ssd固态硬盘\n\n\n\n# 5.跳过联网\n\nshift + F10\n\n输入 oobe\\bypassnro.cmd\n\n回车之后电脑会重启\n\n之后可以进行分区和联网下载电脑驱动\n","tags":["电脑刷机"],"categories":["安装win11"]},{"title":"hexo如何添加图片","url":"/2025/07/07/hexo如何添加图片/","content":"\n\n<!--more-->\n\n\n\n\n参考Kathy's Blog [在hexo博客中插入图片的方法 | Kathy's Blog](https://kathy-kx.github.io/2023/04/16/在hexo博客中插入图片的方法/)\n\n## 如果图片保存在本地\n\n### 方法一：全局资源文件夹\n\n即，将所有文章的资源统一用一个全局资源文件夹管理。\n此方法的优点是比较**简便**，并且当多篇文章需要引用同一资源时，也比较方便。缺点是当文章很多时，各个文章的图片都在同一文件夹，**不便管理**。\n具体方法：\n在hexo文件夹下的source目录下，新建一个文件夹叫images(名字随意)，将要插入的图片放在该文件夹中。\nmd文档内，使用`![图片](图片链接地址 \"图片title\")`的格式，圆括号内的链接地址写(/images/name.jpeg)。\n这里的 / 指的是根目录，对于hexo，资源文件的根目录就是source。\n例如，在md文档中写：\n`![图片](/images/20.jpeg \"甘雨\")`\n同时将“20.jpeg”这个图片文件放在hexo文件夹/source/images下。\n\n---这个我没有使用\n\n\n\n### 方法二：文章资源文件夹\n\n即，对于每篇文章，使用一个文件夹管理资源。\n此方法的优点是，当文章很多时，**便于结构化管理**。缺点是，比方法一麻烦一点。\n具体方法：\n2.1 修改hexo文件夹中的_config.yml文件，如下：\n\n```\npost_asset_folder: true\nmarked:\n  prependRoot: true\n  postAsset: true\n```\n\n2.2 在终端cd到hexo文件夹，`hexo new [layout] <title>` 命令创建一篇新文章，此时会在hexo文件夹的source目录下，自动创建一个文件夹和.md文件。\n注：这句命令中的layout可暂时不写，使用默认的。title就是你的新文章的名字。如果文章名中有**空格**，务必将整个文章名用双引号引起来。如果文章名中没有空格，可以加双引号，也可以不加。\n例如，执行`hexo new \"hexo如何添加图片\"`，如下：\n\n![图片](hexo如何添加图片/1.png)\n\n\n\n会在source/_post文件夹下生成一个”hexo如何添加图片.md”文件。同时还生成了一个同名的资源文件夹。\n\n2.3 我们可以将所有与该文章有关的资源（包括图片）放在这个关联文件夹中\n2.4 通过相对路径来引用图片资源。\n例如，将“1.jpeg”这个图片资源放在该文件夹中，并在.md文件中像这样引用图片：`![图片](1.jpeg)`，这个方法在资源较多时方便管理。\n\n如下图所示写\n\n![图片](hexo如何添加图片/2.png)\n\n注意：要注意斜杠的方向是/ 不是\\\n\n\n\n\n\n另附**Typora编辑器中不显示图片**的解决方案：\n安装下面的插件，可以使Typora等Markdown编辑器预览以及Hexo发布预览时，均能正常显示图片。\n`npm install hexo-asset-img --save`\n这样，如果你使用Typora编辑markdown文档，在typora内也可以显示图片了。\n","tags":["hexo"],"categories":["hexo"]},{"title":"HEXO的Next主题设置以及个性化设置","url":"/2025/07/05/HEXO的Next主题设置以及个性化设置/","content":"\n<!--more-->\n\n在已经搭建Hexo个人博客的基础上，设置next的主题和个性化设置。\n\n搭建Hexo个人博客可以参考Fiveth的博客“如何用Hexo搭建个人博客”。[如何用Hexo搭建个人博客?](https://blog.fiveth.cc/p/bb32/)\n\n\n\n# 1.设置next主题\n\n进入hexo官网，点击“主题”，在搜索的地方输入“next”，点击“nexT”进入到github里面。下面有官方的详细安装介绍。\n\n我使用的是 clone ssh的方法。将文件夹放在themes目录下。\n\n然后在 _config.yml 文件设置theme: next\n\n最后hexo clean && hexo g && hexo s\n\n即可生成\n\n注意：这里的theme: next应该与文件夹的名称相同，如果下载的文件是hexo-theme-next，可以改文件夹的名称也可以改theme: next为 theme: hexo-theme-next\n\n\n\n# 2.个性化next主题\n\n根据clone下来的next文件里面的 _config.yml 可以得知\n\n===============================================================\n\nIt's recommended to use Alternate Theme Config to configure NexT\n\nModifying this file may result in merge conflict\n\nSee: https://theme-next.js.org/docs/getting-started/configuration\n\n===============================================================\n\nTheme Core Configuration Settings\n\nSee: https://theme-next.js.org/docs/theme-settings/\n\n\n\n进入网站可以知道，NexT 目前支持两种推荐的配置方式，你只需要**选择其中一种**：\n\n​\t传统方式是修改 `themes/next/_config.yml`，但这个文件会在更新主题时被覆盖，所以 NexT 主题现在推荐使用 **Hexo 的“主题配置重载（Alternate Theme Config）”功能**。\n\n​\t它允许你在 Hexo 根目录创建一个 `_config.[theme_name].yml` 文件（NexT 默认的 theme 名是 `next`，所以就是 `_config.next.yml`）。\n\n​\tHexo 会优先加载这个文件的配置，并覆盖掉默认的主题配置。\n\n\n\n​\t**theme_config 模式** —— 把 NexT 配置直接写在主配置文件 `_config.yml` 中。\n\n我使用的第一种方法。将其copy即可。\n\n```\n# Installed through npm\ncp node_modules/hexo-theme-next/_config.yml _config.next.yml\n# Installed through Git\ncp themes/next/_config.yml _config.next.yml\n```\n\n\n\n## 2.1设置Scheme\n\n\\# Schemes\n\n\\#scheme: Muse\n\n\\#scheme: Mist\n\n\\#scheme: Pisces\n\nscheme: Gemini\n\n取消井号键即可，其他的注释掉。\n\n\n\n## 2.2设置分类和标签以及关于\n\n在博客根目录下打开git bash here \n\n```\nhexo new page categories\nhexo new page tags\nhexo new page about\n```\n\n然后找到blog/source/categories/index.md\n\n路径下的index.md文件\n\n```\n---\ntitle: 分类\ndate: 2025-07-04 15:16:40\ntype: \"categories\"\n---\n```\n\n```\n---\ntitle: 标签\ndate: 2025-07-04 15:16:23\ntype: \"tags\"\n---\n```\n\n之后写文章的时候添加即可。\n\n```\ntitle: HEXO的Next主题设置以及个性化设置\ndescription: 我的hexo界面设置\ndate: 2025-07-05 14:39:54\ntags:\n  - hexo\n  - next主题\ncategories:\n  - hexo\n```\n\n\n\n在about文件夹里面的index.md编辑就可以了。\n\n\n\n## 2.3设置阅读全文\n\n1.在文章中使用`< !--more-->` 手动进行截断\n\n2.文章简介可以写在开头\n\n```\ndescription: 我的hexo界面设置\n```\n\n3.在**主题配置文件**中添加 ，默认截取的长度为 150 字符，可以根据需要自行设定,直接复制到 _config 文件的底部\n\n```\nauto_excerpt:\n  enable: true\n  length: 150\n```\n\n\n\n## 2.4设置显示字数统计和阅读时长\n\n在博客目录下安装`npm install hexo-symbols-count-time --save`\n\n在`_config.yml`中加入配置\n\n```\nsymbols_count_time:\n #文章内是否显示\n  symbols: true\n  time: true\n # 网页底部是否显示\n  total_symbols: true\n  total_time: true\n```\n\n\n\n## 2.5设置站内搜索\n\n在博客目录下安装`npm install hexo-generator-searchdb --save`，此时使用`hexo cl && hexo g`就会在博客public目录下生成一个search.json，在使用`hexo d`部署上去搜索就可以用了\n\n```\nsearch:\n  path: search.json\n  field: post\n```\n\n在_config.next.yml\n\n里面将local_search: \n\n```\nlocal_search:\n  enable: true\n```\n\n","tags":["hexo","next主题"],"categories":["hexo"]},{"title":"DIY主机","url":"/2025/07/03/DIY主机/","content":"<!--more-->\n​\t刚刚结束自己主机的安装，来记录一下经验和历程，方便之后自己需要再次配主机或者帮朋友看配置。\n\n# 如何写适合自己的配置单\n+\n## 1.确定预算和需求\n\n​\t配电脑主机也是买东西，最重要的当然是准备花多少钱和主要用来干什么。\n\n​\t**预算**可以分为几个档：3000以下，3000-4000，4000-5000，5000-6000，以及更高。感觉不是重度生产力用户，在4000-5000都是够用的。我为什么这么说呢？因为10块和100块的东西使用差别可能很明显，像杂牌有线耳机和苹果有线耳机你用起来能够很明显的感受到区别。那100块的和1000块的呢？当然也有区别，但是在普通人的感官下没有10元和100元的大，还有更贵的耳机和1000元的对比，当然也有区别，但是我应该很难对比感受出来。从够用的情况来说5000左右的电脑主机已经非常够了。在这里我只讨论一手商品。\n\n​\t**需求**主要分为工作和游戏。\n\n​\t工作也有细分，以我写代码编程来说，我需要好一点点的CPU，更多的线程和更快的处理速度。至于其他的工作需求，我就不是很懂了。\n\n​\t游戏大概分为网游、单机、3a、fps。网游相对于其他的更加看重cpu一点。当然显卡也很重要。\n\n​\t**我的需求**：流程的编程，以及游戏，游戏主要玩英雄联盟和地平线4。所以我的cpu和显卡都不用特别好也不要特别差就可以了。\n\n​\t**我的预算：**4000-5000\n\n\n\n## 2.根据预算和需求写配置单\n\n### \t2.1主机有八大组成部分：**CPU、主板、散热、显卡、内存、硬盘、机箱、电源**\n\n​\t \tCPU：是电脑的处理器，用来处理数据\n\n​\t\t主板：我认为是整个电脑的载体，连接起整个电脑。\n\n​\t\t散热：散热主要是安装在CPU上面的散热，还有机箱风扇。顾名思义就是用来散热，让电脑不会太烫。\n\n​\t\t显卡：我认为主要作用就是和显示相关，比如游戏和三维建模的显示和加载速度。\n\n​\t\t内存：内存和我们平时问“欸，你手机多大内存？”的内存不一样，内存是电脑临时存储数据的地方，越大就放的越多处理越快。一般来说最好是双通道（也就是两根一起），现在常见的有8+8，16+16。内存有很多参数，比如颗粒，时序，频率。据我的了解，颗粒最重要，好的颗粒会更加耐用也更贵。时序是越小越好，频率是越高越好。但是！我觉得像我这种普通人C18的时序和C16时序，频率3200和3600很难用出区别。根据预算选择即可。\n\n​\t\t硬盘：就是电脑的存储空间。现在的内存分为固态硬盘和机械硬盘，固态的读写速度很快，体积也小，但是一但损坏数据不可恢复。机械硬盘读写速度相对于更慢，体积更大，数据更容易恢复。硬盘大小主要分为：512G，1T，2T。\n\n​\t\t机箱：能把这些配件装在一起的容器。要注意机箱能不能装下这些配件，根据预算选择，有海景房和普通的。\n\n​\t\t电源：电源是电脑的心脏，用来给电脑供电。最好稍微买大一点点。选择好一点的品牌。网上会有很多测评，选一个比较好的即可。\n\n\n\n​\t了解完八大件，就可以写配置单了。以我的预算为例：4000-5000，最后实际花费4500+\n\n### \t2.2首先确定 CPU、主板、显卡 三个（不分先后）。\n\n​\t\t**显卡：**一般来说**显卡**可能占到预算的50%左右，那我大概就是2000左右，显卡有N卡和A卡，N卡是英伟达生产的，A卡是AMD。N卡更贵一点，但是市面上很多游戏和软件更支持N卡，A卡便宜一些，但是有掉驱动的风险和市面支持度小于N卡。 \n\n​\t\t显卡由两大公司生产，然后下发给其他厂家组装。一线品牌有华硕、微星、技嘉（蓝宝石不知道算不算）。二线就是其他了。但是我认为区别不会很大，因为最核心的东西不是他们生产的，根据预算买就可以了。\n\n​\t\t我买的是A卡：7650gre 品牌蓝宝石 具体型号为7650gre极地版。2000左右的显卡都是入门级别也叫甜品卡。建议买新款显卡。pdd购入价格1889。\n\n​\t\t**CPU和主板：**CPU两大生产商为Intel和AMD，Intel在之前市场占有率大于AMD但是现在慢慢也差不多了。可以看CPU天梯图，但是我个人观察下来，觉得Intel的选择更多，和显卡一样，买新不买旧。主板可以和CPU一起买，价格会更便宜。一般来说，这两个的价格会差不多，也是根据预算选择，其实预算确定之后选择就比较少了。需要注意的是，主板能不能跑满cpu，怎么看呢？网上搜一下就知道了。其实我觉得主板还是比较重要的，它是整个电脑的载体，提供八大件接口。建议买华硕，微星，技嘉。\n\n​\t\t我买的13490f和技嘉的B760M GAMING AC DDR4一共1379，pdd平台购入。\n\n###  \t2.3 其他配件\n\n​\t\t内存：建议双通道，然后再选一个性价比比较高的即可。比如现在的DDR4比DDR5便宜很多。\n\n​\t\t硬盘：一定要有一个固态硬盘，用来安装系统。游戏和办公软件也建议安装在固态硬盘，最好是1T。选性价比高即可，这种很难用坏。也要注意颗粒，现在来说最好避免QLC颗粒。机械硬盘根据需求可加可不加。\n\n​\t\t散热：在网上看一下测评，选择一个使用得多并且品牌售后好的常用的即可。要注意能不能压住cpu的散热（搜索即可知道）。\n\n​\t\t机箱：在能把所有东西放进去的前提下，依据个人喜好选择。我比较重视机箱前面的接口数量和类型，但是我的主板并没有前置typeC的接口，很可惜我的价位没有这种配置。\n\n​\t\t电源：尽量选择网上评价好的，这一部分不能省钱。电源瓦数根据整个主机来算，不会算就可以看网上其他人差不多配置买多大的就可以了。电源品牌的选择也可以网上搜索评价较好的。\n\n​\t\t\n\n### \t2.4我的配置单\n\n![图片](DIY主机/装机配置.png)\n\n\n\n# 装机\n\n## 1.准备工作\n\n​\t要先熟悉整个装机的过程，推荐B站硬件茶谈和天才赵德驻，可以各看一遍，并且做好笔记。除了这些也可以去小红书，抖音搜索一些技巧。\n\n​\t还要吃饱饭！\n\n## 2.我的装机历程。\n\n我提前一天看了B站的视频并且做了步骤的PPT和注意事项，搜索了各大平台。\n\n主要参考豆瓣两位姐妹的文章\n\n[12600KF+5060成果展示！附从选购到点亮全流程经验](https://www.douban.com/group/topic/326821051/?_spm_id=OTM4NjgwMDE&dt_dapp=1&dt_platform=wechat_friends&_i=1534451iG_Juqn)\n\n[教你从0开始打造自己的电竞书桌——新手小白618装机全流程攻略](https://www.douban.com/group/topic/328560793/?_spm_id=MTQ4NzM5MzI0&dt_dapp=1&dt_platform=wechat_friends&_i=1534526iG_Juqn)\n\n\n\n我录制了每一个的拆箱视频。\n\n\n\nCPU-内存-硬盘-散热-显卡（暂时）-电源（全模组接线）--尝试点亮--拆掉显卡和电源线--拆机箱--安装主板--接线--安装显卡--安装风扇\n\n需要注意的是，主板供电的24pin接口特别难插拔，最好上下晃动不要左右。\n\n先点亮再接线\n\n点不了看赵德驻\n\n我是主板放进机箱之前点亮之后没有拆掉主板24pin的电线，直接接入主机，这样也很方便，觉得甚至cpu供电也可以这样因为cpu供电在主板进入机箱之后不好插。\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["装机","电脑","DIY"],"categories":["电脑"]},{"title":"第一篇博客","url":"/2025/07/02/第一篇博客/","content":"<!--more-->\n​\tDaiYueJuan.github.io这是我的博客网站！\n\n​\t这是我第一篇博客。记录一下为什么会有想写博客的念头。\n\n​\t在我研究生的学习过程之中，在我遇到问题的时候我会上网搜索。在CSDN，Google，百度，stackoverflow，还有GPT等等平台直到解决我遇到的问题。搜索的过程并不难，但是如果间隔很久再遇见同样的问题，我可能还是要整个平台再找一遍，这样效率很低。而人的记忆力也不是无限的，所以我决定写博客。\n\n    为什么选择hexo，hexo是部署在github上面的，不会像CSDN一样突然收费或者文章不可见，并且是免费的。\n\n​\t记录我在学习的笔记以及遇到的问题和解决方法。学习永无止境。\n\n"},{"title":"Hello World","url":"/2025/07/02/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n<!--more-->\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"}]