[{"title":"C++数字与字符串互相转换","url":"/2025/07/28/C-%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86/","content":"\n\n\n\nC&#x2F;C++数字与字符串互相转换参考：原文链接：https://blog.csdn.net/m0_73633807/article/details/140817283\n字符串转为数字一、利用ASCII我们知道每个字符都有一个ASCII码，利用这一点可以将字符-‘0’转为数字。在字母大小写转换时也可以利用这个性质。\n\n#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;char ch[]=&#123;&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;4&#x27;,&#x27;5&#x27;&#125;;int main()&#123;\tfor(int i=0;i&lt;strlen(ch);i++)&#123;\t\tcout&lt;&lt;ch[i]-&#x27;0&#x27;&lt;&lt;&quot; &quot;;\t&#125;\treturn 0;&#125;\n\n二、stoi()stoi函数是C++标准库中的一个函数，用于将字符串转换为整数，针对于string类型的。stoi函数是C++11引入的，因此只有在C++11及以上的版本中才能使用该函数。如果你的编译器版本较老，不支持C++11，那么就无法使用stoi函数。学校机房的dev-C++一般是C98标准的，需要自己手动改成C11。\nint num=stoi(const string&amp;  str, size_t* idx = 0, int base = 10);\n\n其中，str是需要转换的字符串；idx是一个指向size_t类型的指针，用于保存转换结束的位置；base是进制，默认为10进制。一般只给传第一个参数即可，也可以利用此函数实现进制转换。\n类似的还有**stol()、stof()、stod(),**分别将字符串类型转换成long long、float、double类型。\n#include&lt;iostream&gt;#include&lt;cstring&gt; using namespace std;string s=&quot;12345&quot;;int main()&#123;\tint a=stoi(s);\tlong long b=stol(s);\tdouble c=stod(s);\tfloat d=stof(s);\tcout&lt;&lt;&quot;int:&quot;&lt;&lt;a&lt;&lt;endl;\tcout&lt;&lt;&quot;long long:&quot;&lt;&lt;b&lt;&lt;endl;\tcout&lt;&lt;&quot;double:&quot;&lt;&lt;c&lt;&lt;endl;\tcout&lt;&lt;&quot;float:&quot;&lt;&lt;d&lt;&lt;endl;\treturn 0;&#125;\n\n三、atoi()atoi()函数是C语言中的一个函数，主要用于将字符串转换为整数。针对于字符数组,类似的还有atol()、atof()、atod()。\nint num=atoi(const char *str);\n\n其中，str是一个以null结尾的字符串，表示要转换的整数。\n该函数将从字符串的开头开始解析，直到遇到第一个非数字字符为止。如果开头是一个正号或负号，它也会解析为整数的一部分。如果字符串中的第一个非空格字符不是有效的数字字符或正负号，则返回0。\n四、sscanf()sscanf函数是一个用来将字符串按照指定格式解析的函数。它接受一个输入字符串和一个格式字符串作为参数，并根据格式字符串的指示将字符串中的数据解析为对应的变量中。主要是针对于字符数组。\nsscanf(str,&quot;%d&quot;,&amp;num);//str字符数组,%dint类型,num转换完成数字\n\n五、stringstreamstringstream是C++中的一个类，可以用来对字符串进行输入输出操作。它是基于字符串的流，可以用来将字符串转换为其他类型的数据，以及将其他类型的数据转换为字符串。stringstream类的头文件是，我们需要包含这个头文件才能使用stringstream类。\n#include&lt;iostream&gt;#include&lt;sstream&gt;#include&lt;cstring&gt;#include&lt;typeinfo&gt; using namespace std;int main()&#123;\tstringstream ss;\tstring s=&quot;12345&quot;;\tint num;\tss&lt;&lt;s;//将字符串读入字符串流 \tss&gt;&gt;num;//从字符串流中读取数据转换为整数\tcout&lt;&lt;typeid(num).name()&lt;&lt;&quot; &quot;&lt;&lt;num&lt;&lt;endl;\treturn 0; &#125;\n\n\n\n数字转为字符串一、利用ASCII字符转数字可以-‘0’，数字转字符那么就可以+’0’，还是利用了ASCII码值的特性。\n#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;int nums[]=&#123;1,2,3,4,5&#125;;int main()&#123;\tfor(int i=0;i&lt;sizeof(nums)/sizeof(int);i++)&#123;\t\tcout&lt;&lt;nums[i]+&#x27;0&#x27;&lt;&lt;&quot; &quot;;\t&#125;\treturn 0;&#125;\n\n注意：转换结果为49 50 51 52 53 ，对应ASCII码值，因为原理就是用ASCII码转换的。\n二、to_string()to_string函数是C++标准库提供的一个函数，用于将不同类型的数据转换为字符串。可以将int、float、double、long long等类型转换为string类型。需要包含头文件#include\n#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;int a=24;long long b=12345678;double c=3.1415;string s;int main()&#123;\ts=to_string(a);\tcout&lt;&lt;s&lt;&lt;endl;\ts=to_string(b);\tcout&lt;&lt;s&lt;&lt;endl;\ts=to_string(c);\tcout&lt;&lt;s&lt;&lt;endl;\treturn 0;&#125;\n\n三、itoa()itoa函数用于将整数转换为字符串。类似的还有ltoa、ftoa、dtoa分别将long long、float、double转换为字符串类型。针对于字符数组。\nitoa(num,str,10);\n\n第一个参数是待转换的数字，第二个参数是转换完成的字符数组，第三个是转换的进制数，默认10进制。\n#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;int n=12345;char str[10];int main()&#123;\titoa(n,str,10); \tcout&lt;&lt;str&lt;&lt;endl;\treturn 0;&#125;\n\n四、sprintf()sprintf()函数是c语言库中的函数，可以将数字转换为字符串类型，一般转换为字符数组。\nsprintf(str,&quot;%d&quot;,num);\n\nstr是转换完成的字符数组，%d是类型，num是待转换的数字。 \n#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;int n=12345;char str[10];int main()&#123;\tsprintf(str,&quot;%d&quot;,n); \tcout&lt;&lt;str&lt;&lt;endl;\treturn 0;&#125;\n\n五、stringstream与字符串转数字的一样，可以互相转换，同时还是要包含头文件，具体使用如下\n#include&lt;iostream&gt;#include&lt;sstream&gt;#include&lt;cstring&gt;#include&lt;typeinfo&gt; using namespace std;int main()&#123;\tstringstream ss;\tstring s=&quot;12345&quot;;\tint num=54321;\tss&lt;&lt;num;//将int类型的数据写入字符串流中\ts=ss.str();//将字符串流中的数据转换为string类型\tcout&lt;&lt;typeid(s).name()&lt;&lt;&quot; &quot;&lt;&lt;num&lt;&lt;endl;\treturn 0; &#125;\n\n\n\n\n\n个人总结：在C++中：\n字符串转数字：常用ASCII、stoi()\\stod()\\stol()\\stoll()。 ASCII只能是一位数字，stoi()\\stod()\\stol()\\stoll()适用于各种类型。\nstoi—–string to int\n数字转为字符串：常用ASCII、to_string()（要包含头文件#include）\n","categories":["C++"],"tags":["C++","刷题"]},{"title":"HEXO的Next主题设置以及个性化设置","url":"/2025/07/05/HEXO%E7%9A%84Next%E4%B8%BB%E9%A2%98%E8%AE%BE%E7%BD%AE%E4%BB%A5%E5%8F%8A%E4%B8%AA%E6%80%A7%E5%8C%96%E8%AE%BE%E7%BD%AE/","content":"\n\n在已经搭建Hexo个人博客的基础上，设置next的主题和个性化设置。\n搭建Hexo个人博客可以参考Fiveth的博客“如何用Hexo搭建个人博客”。如何用Hexo搭建个人博客?\n1.设置next主题进入hexo官网，点击“主题”，在搜索的地方输入“next”，点击“nexT”进入到github里面。下面有官方的详细安装介绍。\n我使用的是 clone ssh的方法。将文件夹放在themes目录下。\n然后在 _config.yml 文件设置theme: next\n最后hexo clean &amp;&amp; hexo g &amp;&amp; hexo s\n即可生成\n注意：这里的theme: next应该与文件夹的名称相同，如果下载的文件是hexo-theme-next，可以改文件夹的名称也可以改theme: next为 theme: hexo-theme-next\n2.个性化next主题根据clone下来的next文件里面的 _config.yml 可以得知\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\nIt’s recommended to use Alternate Theme Config to configure NexT\nModifying this file may result in merge conflict\nSee: https://theme-next.js.org/docs/getting-started/configuration\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\nTheme Core Configuration Settings\nSee: https://theme-next.js.org/docs/theme-settings/\n进入网站可以知道，NexT 目前支持两种推荐的配置方式，你只需要选择其中一种：\n​\t传统方式是修改 themes/next/_config.yml，但这个文件会在更新主题时被覆盖，所以 NexT 主题现在推荐使用 Hexo 的“主题配置重载（Alternate Theme Config）”功能。\n​\t它允许你在 Hexo 根目录创建一个 _config.[theme_name].yml 文件（NexT 默认的 theme 名是 next，所以就是 _config.next.yml）。\n​\tHexo 会优先加载这个文件的配置，并覆盖掉默认的主题配置。\n​\ttheme_config 模式 —— 把 NexT 配置直接写在主配置文件 _config.yml 中。\n我使用的第一种方法。将其copy即可。\n# Installed through npmcp node_modules/hexo-theme-next/_config.yml _config.next.yml# Installed through Gitcp themes/next/_config.yml _config.next.yml\n\n\n\n2.1设置Scheme# Schemes\n#scheme: Muse\n#scheme: Mist\n#scheme: Pisces\nscheme: Gemini\n取消井号键即可，其他的注释掉。\n2.2设置分类和标签以及关于在博客根目录下打开git bash here \nhexo new page categorieshexo new page tagshexo new page about\n\n然后找到blog&#x2F;source&#x2F;categories&#x2F;index.md\n路径下的index.md文件\n---title: 分类date: 2025-07-04 15:16:40type: &quot;categories&quot;---\n\n---title: 标签date: 2025-07-04 15:16:23type: &quot;tags&quot;---\n\n之后写文章的时候添加即可。\ntitle: HEXO的Next主题设置以及个性化设置description: 我的hexo界面设置date: 2025-07-05 14:39:54tags:  - hexo  - next主题categories:  - hexo\n\n\n\n在about文件夹里面的index.md编辑就可以了。\n2.3设置阅读全文1.在文章中使用&lt; !--more--&gt; 手动进行截断\n2.文章简介可以写在开头\ndescription: 我的hexo界面设置\n\n3.在主题配置文件中添加 ，默认截取的长度为 150 字符，可以根据需要自行设定,直接复制到 _config 文件的底部\nauto_excerpt:  enable: true  length: 150\n\n\n\n2.4设置显示字数统计和阅读时长在博客目录下安装npm install hexo-symbols-count-time --save\n在_config.yml中加入配置\nsymbols_count_time: #文章内是否显示  symbols: true  time: true # 网页底部是否显示  total_symbols: true  total_time: true\n\n\n\n2.5设置站内搜索在博客目录下安装npm install hexo-generator-searchdb --save，此时使用hexo cl &amp;&amp; hexo g就会在博客public目录下生成一个search.json，在使用hexo d部署上去搜索就可以用了\nsearch:  path: search.json  field: post\n\n在_config.next.yml\n里面将local_search: \nlocal_search:  enable: true\n\n","categories":["hexo"],"tags":["hexo","next主题"]},{"title":"DIY主机","url":"/2025/07/03/DIY%E4%B8%BB%E6%9C%BA/","content":"\n​\t刚刚结束自己主机的安装，来记录一下经验和历程，方便之后自己需要再次配主机或者帮朋友看配置。\n如何写适合自己的配置单\n\n\n1.确定预算和需求​\t配电脑主机也是买东西，最重要的当然是准备花多少钱和主要用来干什么。\n​\t预算可以分为几个档：3000以下，3000-4000，4000-5000，5000-6000，以及更高。感觉不是重度生产力用户，在4000-5000都是够用的。我为什么这么说呢？因为10块和100块的东西使用差别可能很明显，像杂牌有线耳机和苹果有线耳机你用起来能够很明显的感受到区别。那100块的和1000块的呢？当然也有区别，但是在普通人的感官下没有10元和100元的大，还有更贵的耳机和1000元的对比，当然也有区别，但是我应该很难对比感受出来。从够用的情况来说5000左右的电脑主机已经非常够了。在这里我只讨论一手商品。\n​\t需求主要分为工作和游戏。\n​\t工作也有细分，以我写代码编程来说，我需要好一点点的CPU，更多的线程和更快的处理速度。至于其他的工作需求，我就不是很懂了。\n​\t游戏大概分为网游、单机、3a、fps。网游相对于其他的更加看重cpu一点。当然显卡也很重要。\n​\t我的需求：流程的编程，以及游戏，游戏主要玩英雄联盟和地平线4。所以我的cpu和显卡都不用特别好也不要特别差就可以了。\n​\t**我的预算：**4000-5000\n2.根据预算和需求写配置单2.1主机有八大组成部分：CPU、主板、散热、显卡、内存、硬盘、机箱、电源​\t \tCPU：是电脑的处理器，用来处理数据\n​\t\t主板：我认为是整个电脑的载体，连接起整个电脑。\n​\t\t散热：散热主要是安装在CPU上面的散热，还有机箱风扇。顾名思义就是用来散热，让电脑不会太烫。\n​\t\t显卡：我认为主要作用就是和显示相关，比如游戏和三维建模的显示和加载速度。\n​\t\t内存：内存和我们平时问“欸，你手机多大内存？”的内存不一样，内存是电脑临时存储数据的地方，越大就放的越多处理越快。一般来说最好是双通道（也就是两根一起），现在常见的有8+8，16+16。内存有很多参数，比如颗粒，时序，频率。据我的了解，颗粒最重要，好的颗粒会更加耐用也更贵。时序是越小越好，频率是越高越好。但是！我觉得像我这种普通人C18的时序和C16时序，频率3200和3600很难用出区别。根据预算选择即可。\n​\t\t硬盘：就是电脑的存储空间。现在的内存分为固态硬盘和机械硬盘，固态的读写速度很快，体积也小，但是一但损坏数据不可恢复。机械硬盘读写速度相对于更慢，体积更大，数据更容易恢复。硬盘大小主要分为：512G，1T，2T。\n​\t\t机箱：能把这些配件装在一起的容器。要注意机箱能不能装下这些配件，根据预算选择，有海景房和普通的。\n​\t\t电源：电源是电脑的心脏，用来给电脑供电。最好稍微买大一点点。选择好一点的品牌。网上会有很多测评，选一个比较好的即可。\n​\t了解完八大件，就可以写配置单了。以我的预算为例：4000-5000，最后实际花费4500+\n2.2首先确定 CPU、主板、显卡 三个（不分先后）。​\t\t显卡：一般来说显卡可能占到预算的50%左右，那我大概就是2000左右，显卡有N卡和A卡，N卡是英伟达生产的，A卡是AMD。N卡更贵一点，但是市面上很多游戏和软件更支持N卡，A卡便宜一些，但是有掉驱动的风险和市面支持度小于N卡。 \n​\t\t显卡由两大公司生产，然后下发给其他厂家组装。一线品牌有华硕、微星、技嘉（蓝宝石不知道算不算）。二线就是其他了。但是我认为区别不会很大，因为最核心的东西不是他们生产的，根据预算买就可以了。\n​\t\t我买的是A卡：7650gre 品牌蓝宝石 具体型号为7650gre极地版。2000左右的显卡都是入门级别也叫甜品卡。建议买新款显卡。pdd购入价格1889。\n​\t\t**CPU和主板：**CPU两大生产商为Intel和AMD，Intel在之前市场占有率大于AMD但是现在慢慢也差不多了。可以看CPU天梯图，但是我个人观察下来，觉得Intel的选择更多，和显卡一样，买新不买旧。主板可以和CPU一起买，价格会更便宜。一般来说，这两个的价格会差不多，也是根据预算选择，其实预算确定之后选择就比较少了。需要注意的是，主板能不能跑满cpu，怎么看呢？网上搜一下就知道了。其实我觉得主板还是比较重要的，它是整个电脑的载体，提供八大件接口。建议买华硕，微星，技嘉。\n​\t\t我买的13490f和技嘉的B760M GAMING AC DDR4一共1379，pdd平台购入。\n2.3 其他配件​\t\t内存：建议双通道，然后再选一个性价比比较高的即可。比如现在的DDR4比DDR5便宜很多。\n​\t\t硬盘：一定要有一个固态硬盘，用来安装系统。游戏和办公软件也建议安装在固态硬盘，最好是1T。选性价比高即可，这种很难用坏。也要注意颗粒，现在来说最好避免QLC颗粒。机械硬盘根据需求可加可不加。\n​\t\t散热：在网上看一下测评，选择一个使用得多并且品牌售后好的常用的即可。要注意能不能压住cpu的散热（搜索即可知道）。\n​\t\t机箱：在能把所有东西放进去的前提下，依据个人喜好选择。我比较重视机箱前面的接口数量和类型，但是我的主板并没有前置typeC的接口，很可惜我的价位没有这种配置。\n​\t\t电源：尽量选择网上评价好的，这一部分不能省钱。电源瓦数根据整个主机来算，不会算就可以看网上其他人差不多配置买多大的就可以了。电源品牌的选择也可以网上搜索评价较好的。\n​\t\t\n2.4我的配置单\n装机1.准备工作​\t要先熟悉整个装机的过程，推荐B站硬件茶谈和天才赵德驻，可以各看一遍，并且做好笔记。除了这些也可以去小红书，抖音搜索一些技巧。\n​\t还要吃饱饭！\n2.我的装机历程。我提前一天看了B站的视频并且做了步骤的PPT和注意事项，搜索了各大平台。\n主要参考豆瓣两位姐妹的文章\n12600KF+5060成果展示！附从选购到点亮全流程经验\n教你从0开始打造自己的电竞书桌——新手小白618装机全流程攻略\n我录制了每一个的拆箱视频。\nCPU-内存-硬盘-散热-显卡（暂时）-电源（全模组接线）–尝试点亮–拆掉显卡和电源线–拆机箱–安装主板–接线–安装显卡–安装风扇\n需要注意的是，主板供电的24pin接口特别难插拔，最好上下晃动不要左右。\n先点亮再接线\n点不了看赵德驻\n我是主板放进机箱之前点亮之后没有拆掉主板24pin的电线，直接接入主机，这样也很方便，觉得甚至cpu供电也可以这样因为cpu供电在主板进入机箱之后不好插。\n","categories":["电脑"],"tags":["装机","电脑","DIY"]},{"title":"错误LNK2001,无法解析的外部符号，static QMetaObject","url":"/2025/07/31/QMetaObject/","content":"\n\n严重性\t代码\t说明\t项目\t文件\t行\t禁止显示状态 错误\tLNK2001\t无法解析的外部符号 “public: static struct QMetaObject const xxxxx::staticMetaObject” (?staticMetaObject@xxxxx@@2UQMetaObject@@B)\t\n出现场景：在新电脑安装VS2019,和QT VS TOOLS插件之后，代码是可以正常运行生成的。后面安装了番茄助手，然后QT VS TOOLS 的插件就不见了（暂时没有找到原因） 。就出现了这个报错。\n这个链接错误（LNK2001: 无法解析的外部符号 staticMetaObject）通常是由于 Qt 宏（如 Q_OBJECT）使用不当或相关的 moc 文件没有被正确生成&#x2F;链接导致的。\n常见原因及解决方案： 1.类中使用了 Q_OBJECT 宏，但未运行 moc（Meta-Object Compiler）\n​\t检查你的类 xxxxx 的头文件是否包含了 Q_OBJECT 宏。\n2.头文件未被正确包含在构建系统中（尤其是非 Qt Creator 的项目）\n​\t确保你的类头文件 xxx 已添加到项目中，而不是仅仅被引用（否则 VS 不会触发 moc）。\n​\t右键 .h 文件 → 属性 → 设置为 “使用 MOC 编译器” 或确保 Qt VS Tools 插件启用。\n\n在设置之后代码可以生成，但是我觉得很奇怪为什么之前添加新文件不会需要手动修改类型呢？后面发现是QT VS TOOLS插件的问题。\n我重新安装之后，解决方案里面有些项目被卸载。又卸载重新安装了一次，把被卸载的项目先移除然后再添加进来。\n","categories":["报错"],"tags":["C++","Qt"]},{"title":"QtInstallation问题","url":"/2025/07/24/QtInstallation%E9%97%AE%E9%A2%98/","content":"\n\n​\t在安装好VS2019和Qt5.14.2之后，我准备跑之前的代码，打开代码之后vs提示的错误如下：\n\n这里主要解决第一个。\nThe project’s’Qt Installation’ property is not set correctly.Please specify a valid Qt version or path.\n在vs 点击“扩展“ –&gt; ”Qt VS Tools“—&gt;”Qt Versions”或者”Options”\n\n在name 输入 自己qt的版本 和操作系统位数\n在Location 选择qt的安装路径\n​\t进入选择对话框后，按照安装路径进入以下文件夹，选择qmake.exe,点击打开\n注意： 这里要区分32位和64位\n\n","categories":["Qt"],"tags":["Qt","QtInstallation","VS2019"]},{"title":"Hello World","url":"/2025/07/02/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\n\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"VS2019番茄助手安装","url":"/2025/07/29/VS2019%E7%95%AA%E8%8C%84%E5%8A%A9%E6%89%8B%E5%AE%89%E8%A3%85/","content":"\n\n每次安装都会忘记一些关键步骤，写下来！\n参考：给 VS2019 安装个 Visual Assist x 插件 - ALLEN_2008 - 博客园\nVS2019 安装番茄助手（Visual Assist x 插件）攻略_vs2019番茄助手-CSDN博客\n相应环境\n系统平台：WIN11\nVS：VS2019\nVAX版本：Visual Assist X 10.9.2406.0（其他版本也可对应操作）\n\n重点说明：\n安装VA_X_Setup2440_0.exe前，先要右键exe文件勾选兼容性。在 win7 下，Visual Assist x 可能需要兼容运行（右击，属性，兼容性设置），因为直接双击可能就给你红框崩溃。\n去掉 VS2019 插件更新勾选框和 VAX 更新勾选框。（这个我没用到）\n\n安装步骤先上一张安装文件源图\n\n双击直接安装VA_X_Setup2406_0.exe，在装到VS2019时会发生错误，提示安装不成功（不用管，接着让它装）。就是一直不管它，一开始会retry，后面会说错误此时，\n​\t用 everything（一个软件，可以在网上下载） 在 Temp 文件夹找到与 VS2019 匹配的安装版本，这里是 VaXSetup.vsix，拷贝到桌面（ 重点！在出现错误窗口的时候，不要关！不要关！不要关！这个时候用everything去搜 VaXSetup.vsix ）\n​\t等原文件 VA_X_Setup2406_0.exe 安装完之后（VA_X_Setup2406_0.exe等它报错才能删除），会在C:\\Users\\用户\\AppData\\Local\\Microsoft\\VisualStudio\\16.0_5b3ff307（这个地方每个人是不同的，但是都是16.0_开头）\\Extensions 下产生文件。删除这个目录下所有文件夹和文件。（这个路径不一定是完全相同的）\n​\t使用 VaXSetup.vsix 重新安装，此时是安装到 VS2019，最终会提示安装成功。同时会在 Extensions 目录生成新的文件夹和文件。（其实对于 VS2019， VAX 是安装 Extensions 目录下的，所以如果 VAX 插件出现问题，则可以多次删除，多次重装。2010 及之前版本则不同。）\n​\t用破解的 VA_X64.dll 和 PiaoYun64.dll 拷贝到 Extensions&#x2F;随机文件夹(就一个文件夹，名字是随机的)&#x2F; ，路径下（简单一点的话就用everything搜VA_X.dll,找到类似这个路径，把VA_X64.dll 和 PiaoYun64.dll 拷贝进去）。\n​\t找到 VS2019 的安装目录。具体为：右击 VS2019 图标-&gt;属性，在快捷方式栏找到“目标”，“目标”后面的文本框就是 [VS2019 安装](https://so.csdn.net/so/search?q=VS2019 安装&amp;spm&#x3D;1001.2101.3001.7020)目录.（如图）\n\n​\t按住win+R，输入cmd打开，在命令行切换到 5（第五步） 的目录，运行命令：devenv.exe &#x2F;safemode，回车（安全模式下运行一回）（如图）。此时在 VS2019 插件管理有 Visual Assist x 插件，但不能用。直接关闭 VS2019。\n怎么用命令行进入：\n默认是在C盘 所以先输入 d: 进入D盘\n然后使用cd可以进入目标目录（或者文件夹打开之后会自动进去像我的一样）\n\n.vllwczfkxmao{zoom:80%;}\n\n​\t这次正常打开 VS2019，最终会看到 extension 菜单下出现 Visual Assist x。\n​\t这还没完。需要去掉插件更新和 Visual Assist x 更新勾选。具体为：　　* ​\t拓展-&gt;管理拓展-&gt;已安装-&gt;弹出对话框的右上角，具体下图。\n\n\nVisual Assist x options 对话框左边-&gt;startup，见下图。\n\n\n在这里可以设置快捷键生成注释块\n\n\n","categories":["软件安装"],"tags":["C++","软件安装","番茄助手"]},{"title":"hexo如何添加图片","url":"/2025/07/07/hexo%E5%A6%82%E4%BD%95%E6%B7%BB%E5%8A%A0%E5%9B%BE%E7%89%87/","content":"\n\n\n\n\n参考Kathy’s Blog 在hexo博客中插入图片的方法 | Kathy’s Blog\n如果图片保存在本地方法一：全局资源文件夹即，将所有文章的资源统一用一个全局资源文件夹管理。此方法的优点是比较简便，并且当多篇文章需要引用同一资源时，也比较方便。缺点是当文章很多时，各个文章的图片都在同一文件夹，不便管理。具体方法：在hexo文件夹下的source目录下，新建一个文件夹叫images(名字随意)，将要插入的图片放在该文件夹中。md文档内，使用![图片](图片链接地址 &quot;图片title&quot;)的格式，圆括号内的链接地址写(&#x2F;images&#x2F;name.jpeg)。这里的 &#x2F; 指的是根目录，对于hexo，资源文件的根目录就是source。例如，在md文档中写：![图片](/images/20.jpeg &quot;甘雨&quot;)同时将“20.jpeg”这个图片文件放在hexo文件夹&#x2F;source&#x2F;images下。\n—这个我没有使用\n方法二：文章资源文件夹即，对于每篇文章，使用一个文件夹管理资源。此方法的优点是，当文章很多时，便于结构化管理。缺点是，比方法一麻烦一点。具体方法：2.1 修改hexo文件夹中的_config.yml文件，如下：\npost_asset_folder: truemarked:  prependRoot: true  postAsset: true\n\n2.2 在终端cd到hexo文件夹，hexo new [layout] &lt;title&gt; 命令创建一篇新文章，此时会在hexo文件夹的source目录下，自动创建一个文件夹和.md文件。注：这句命令中的layout可暂时不写，使用默认的。title就是你的新文章的名字。如果文章名中有空格，务必将整个文章名用双引号引起来。如果文章名中没有空格，可以加双引号，也可以不加。例如，执行hexo new &quot;hexo如何添加图片&quot;，如下：\n\n会在source&#x2F;_post文件夹下生成一个”hexo如何添加图片.md”文件。同时还生成了一个同名的资源文件夹。\n2.3 我们可以将所有与该文章有关的资源（包括图片）放在这个关联文件夹中2.4 通过相对路径来引用图片资源。例如，将“1.jpeg”这个图片资源放在该文件夹中，并在.md文件中像这样引用图片：![图片](1.jpeg)，这个方法在资源较多时方便管理。\n如下图所示写\n\n注意：要注意斜杠的方向是&#x2F; 不是\\\n另附Typora编辑器中不显示图片的解决方案：安装下面的插件，可以使Typora等Markdown编辑器预览以及Hexo发布预览时，均能正常显示图片。npm install hexo-asset-img --save这样，如果你使用Typora编辑markdown文档，在typora内也可以显示图片了。\n","categories":["hexo"],"tags":["hexo"]},{"title":"priority_queue","url":"/2025/07/28/priority-queue/","content":"\n\n参考：C++ STL priority_queue容器适配器详解 - C语言中文网\n代码随想录\n优先级队列以下参考代码随想录什么是优先级队列呢？\n其实就是一个披着队列外衣的堆，因为优先级队列对外接口只是从队头取元素，从队尾添加元素，再无其他取元素的方式，看起来就是一个队列。\n而且优先级队列内部元素是自动依照元素的权值排列。那么它是如何有序排列的呢？\n缺省情况下priority_queue利用max-heap（大顶堆）完成对元素的排序，这个大顶堆是以vector为表现形式的complete binary tree（完全二叉树）。\n什么是堆呢？\n堆是一棵完全二叉树，树中每个结点的值都不小于（或不大于）其左右孩子的值。 如果父亲结点是大于等于左右孩子就是大顶堆，小于等于左右孩子就是小顶堆。\n所以大家经常说的大顶堆（堆头是最大元素），小顶堆（堆头是最小元素），如果懒得自己实现的话，就直接用priority_queue（优先级队列）就可以了，底层实现都是一样的，从小到大排就是小顶堆，从大到小排就是大顶堆。\n以下参考C语言中文网priority_queue 容器适配器模拟的也是队列这种存储结构，即使用此容器适配器存储元素只能“从一端进（称为队尾），从另一端出（称为队头）”，且每次只能访问 priority_queue 中位于队头的元素。\n但是，priority_queue 容器适配器中元素的存和取，遵循的并不是 “First in,First out”（先入先出）原则，而是“First in，Largest out”原则。直白的翻译，指的就是先进队列的元素并不一定先出队列，而是优先级最大的元素最先出队列。\n\n注意，“First in，Largest out”原则是笔者为了总结 priority_queue 存取元素的特性自创的一种称谓，仅为了方便读者理解。\n\n那么，priority_queue 容器适配器中存储的元素，优先级是如何评定的呢？很简单，每个 priority_queue 容器适配器在创建时，都制定了一种排序规则。根据此规则，该容器适配器中存储的元素就有了优先级高低之分。\n举个例子，假设当前有一个 priority_queue 容器适配器，其制定的排序规则是按照元素值从大到小进行排序。根据此规则，自然是 priority_queue 中值最大的元素的优先级最高。\npriority_queue 容器适配器为了保证每次从队头移除的都是当前优先级最高的元素，每当有新元素进入，它都会根据既定的排序规则找到优先级最高的元素，并将其移动到队列的队头；同样，当 priority_queue 从队头移除出一个元素之后，它也会再找到当前优先级最高的元素，并将其移动到队头。\n基于 priority_queue 的这种特性，因此该容器适配器有被称为优先级队列。\n\npriority_queue 容器适配器“First in，Largest out”的特性，和它底层采用堆结构存储数据是分不开的。有关该容器适配器的底层实现，后续章节会进行深度剖析。\n\nSTL 中，priority_queue 容器适配器的定义如下：\ntemplate &lt;typename T,        typename Container=std::vector&lt;T&gt;,        typename Compare=std::less&lt;T&gt; &gt;class priority_queue&#123;    //......&#125;\n\n可以看到，priority_queue 容器适配器模板类最多可以传入 3 个参数，它们各自的含义如下：\n\ntypename T：指定存储元素的具体类型；\n\ntypename Container：指定 priority_queue 底层使用的基础容器，默认使用 vector 容器。\n\n作为 priority_queue 容器适配器的底层容器，其必须包含 empty()、size()、front()、push_back()、pop_back() 这几个成员函数，STL 序列式容器中只有 vector 和 deque 容器符合条件。\n\n\ntypename Compare：指定容器中评定元素优先级所遵循的排序规则，默认使用\nstd::less&lt;T&gt;\n\n按照元素值从大到小进行排序，还可以使用std::greater&lt;T&gt;\n\n按照元素值从小到大排序，但更多情况下是使用自定义的排序规则。\n\n其中，std::less 和 std::greater 都是以函数对象的方式定义在  头文件中。关于如何自定义排序规则，后续章节会做详细介绍。\n\n\n\n创建priority_queue的几种方式由于 priority_queue 容器适配器模板位于&lt;queue&gt;头文件中，并定义在 std 命名空间里，因此在试图创建该类型容器之前，程序中需包含以下 2 行代码：\n#include &lt;queue&gt;using namespace std;\n\n创建 priority_queue 容器适配器的方法，大致有以下几种。\n\n创建一个空的 priority_queue 容器适配器，第底层采用默认的 vector 容器，排序方式也采用默认的 std::less 方法：\n\nstd::priority_queue&lt;int&gt; values;\n\n\n可以使用普通数组或其它容器中指定范围内的数据，对 priority_queue 容器适配器进行初始化：\n\n//使用普通数组int values[]&#123;4,1,3,2&#125;;std::priority_queue&lt;int&gt;copy_values(values,values+4);//&#123;4,2,3,1&#125;//使用序列式容器std::array&lt;int,4&gt;values&#123; 4,1,3,2 &#125;;std::priority_queue&lt;int&gt;copy_values(values.begin(),values.end());//&#123;4,2,3,1&#125;\n\n注意，以上 2 种方式必须保证数组或容器中存储的元素类型和 priority_queue 指定的存储类型相同。另外，用来初始化的数组或容器中的数据不需要有序，priority_queue 会自动对它们进行排序。\n\n还可以手动指定 priority_queue 使用的底层容器以及排序规则，比如：\n\nint values[]&#123; 4,1,2,3 &#125;;std::priority_queue&lt;int, std::deque&lt;int&gt;, std::greater&lt;int&gt; &gt;copy_values(values, values+4);//&#123;1,3,2,4&#125;\n\n事实上，std::less 和 std::greater 适用的场景是有限的，更多场景中我们会使用自定义的排序规则。\n\n由于自定义排序规则的方式不只一种，因此这部分知识将在后续章节做详细介绍。\n\npriority_queue提供的成员函数priority_queue 容器适配器提供了表 2 所示的这些成员函数。\n\n\n\n成员函数\n功能\n\n\n\nempty()\n如果 priority_queue 为空的话，返回 true；反之，返回 false。\n\n\nsize()\n返回 priority_queue 中存储元素的个数。\n\n\ntop()\n返回 priority_queue 中第一个元素的引用形式。\n\n\npush(const T&amp; obj)\n根据既定的排序规则，将元素 obj 的副本存储到 priority_queue 中适当的位置。\n\n\npush(T&amp;&amp; obj)\n根据既定的排序规则，将元素 obj 移动存储到 priority_queue 中适当的位置。\n\n\nemplace(Args&amp;&amp;… args)\nArgs&amp;&amp;… args 表示构造一个存储类型的元素所需要的数据（对于类对象来说，可能需要多个数据构造出一个对象）。此函数的功能是根据既定的排序规则，在容器适配器适当的位置直接生成该新元素。\n\n\npop()\n移除 priority_queue 容器适配器中第一个元素。\n\n\nswap(priority_queue&amp; other)\n将两个 priority_queue 容器适配器中的元素进行互换，需要注意的是，进行互换的 2 个 priority_queue 容器适配器中存储的元素类型以及底层采用的基础容器类型，都必须相同。\n\n\n\n和 queue 一样，priority_queue 也没有迭代器，因此访问元素的唯一方式是遍历容器，通过不断移除访问过的元素，去访问下一个元素。\n\n在 C++ 中，emplace 和 push 的区别emplace 和 push 都可以用来向容器中添加元素，但它们的工作方式有所不同。在这个特定的代码中，使用 emplace 比 push 更高效，原因如下：\nemplace 直接构造元素\nq.emplace(nums[i], i) 会直接在优先队列的内存中构造一个 pair&lt;int, int&gt; 对象，避免了临时对象的创建和拷贝&#x2F;移动操作。\n它等价于 q.push(std::pair&lt;int, int&gt;(nums[i], i))，但更高效，因为 emplace 直接在容器内部构造对象，省去了额外的拷贝或移动开销。\n\npush 需要构造临时对象\n如果使用 push，你需要显式构造一个 pair 对象，如 q.push(make_pair(nums[i], i)) 或 q.push(&#123;nums[i], i)&#125;)。\n这会先创建一个临时 pair 对象，然后将其拷贝或移动到优先队列中，多了一次不必要的构造和拷贝&#x2F;移动操作。\n\n性能优势\n对于像 pair&lt;int, int&gt; 这样的简单类型，emplace 和 push 的性能差异可能不大，但在更复杂的场景（如构造含多个参数的对象）时，emplace 能显著减少开销。\n由于 emplace 是 C++11 引入的优化方式，它更符合现代 C++ 的高效编程风格。\n\n代码对比cpp\n// 使用 emplace（推荐）q.emplace(nums[i], i);  // 直接在优先队列中构造 pair// 使用 push（需要构造临时对象）q.push(std::make_pair(nums[i], i));  // 先构造临时 pair，再拷贝/移动到队列\n","categories":["C++"],"tags":["C++","C++基础","STL","容器适配器"]},{"title":"std::greater()和std::less()在排序和建堆的应用以及自定义比较函数的规则","url":"/2025/07/28/std-greater-%E5%92%8Cstd-less-%E5%9C%A8%E6%8E%92%E5%BA%8F%E5%92%8C%E5%BB%BA%E5%A0%86%E7%9A%84%E5%BA%94%E7%94%A8%E4%BB%A5%E5%8F%8A%E8%87%AA%E5%AE%9A%E4%B9%89%E6%AF%94%E8%BE%83%E5%87%BD%E6%95%B0%E7%9A%84%E8%A7%84%E5%88%99/","content":"\n\n\n\n解释比较规则：strict weak orderingstd::greater()、std::less()、自定义比较函数，这些都其实是用作比较的，要遵从c++制定的比较规则。\n\n需要满足三种特性要求，否则使用中会报错：\n\n反自反性：false\ntrue的互斥性：true则false（但不要求false则怎么样）\n传递性：true＋true则true\n\nless和greater其实是什么两个函数的头文件是functional\n比如less\ntemplate &lt;class T&gt; struct less &#123;  bool operator() (const T&amp; x, const T&amp; y) const &#123;return x&lt;y;&#125;  typedef T first_argument_type;  typedef T second_argument_type;  typedef bool result_type;&#125;;\n\n可以看到关键就是bool operator()和return x&lt;y;\nbool operator()：要的就是这个返回值bool，决定比较是否要交换。这个结果用在排序和建堆中就表示是否要交换。return x&lt;y;：可以看到其实就是使用&lt;之类的操作符重载，这就是怎么排序的规则。PS：但这产生了限制，基本的元素int之类的，自然可以直接比较；但复杂类型如自定义一个类，里面有多个数据，我们就还得定义重载操作符比较，要不然编译器不知道该比较什么。\nbool返回值和比较操作符规则bool comp(a, b)意思是：返回的值指示作为第一个参数传递的元素是否被视为在其定义的特定严格弱排序中位于第二个参数之前。\n\n返回true：表示ab(a在b前）\n返回false：表示ba（a在b&#96;后）\n\n\n并不是想当然的位置交换comp(a, b)虽然会交换a和b，但你不能想当然地认为位置就该怎么样，到底数组中谁会是a，谁会是b，这要看调用的算法的。\n比如，[a &lt; b]  [6 &lt; 1] : 0，其实是算法调用时a是6，b是1，而非看到数组中原来的顺序就想当然的a是1，b是6。\n知识基础参考我的priority_queue博客这里简略再复述一些助于理解的关键信息。\n什么是优先级队列呢？\n其实就是一个披着队列外衣的堆，因为优先级队列对外接口只是从队头取元素，从队尾添加元素，再无其他取元素的方式，看起来就是一个队列。\n优先级队列内部元素是自动依照元素的权值排列。\n所以大家经常说的大顶堆（堆头是最大元素），小顶堆（堆头是最小元素），如果懒得自己实现的话，就直接用priority_queue（优先级队列）就可以了，底层实现都是一样的，从小到大排就是小顶堆，从大到小排就是大顶堆。\npriority_queue 容器适配器模拟的也是队列这种存储结构，即使用此容器适配器存储元素只能“从一端进（称为队尾），从另一端出（称为队头）”，且每次只能访问 priority_queue 中位于队头的元素。\n但是，priority_queue 容器适配器中元素的存和取，遵循的并不是 “First in,First out”（先入先出）原则，而是“*First in，Largest out*”原则。直白的翻译，指的就是先进队列的元素并不一定先出队列，而是优先级最大的元素最先出队列。（Largest out是指权重最大）\n通过以上的内容，我们可以用priority_queue来理解下面的内容。\n.uwengunexogb{zoom:75%;}\n\n结论排序和建堆的效果排序：less变成升序（从左到右遍历下标时，数组元素是从小到大）greater变成降序（从左到右遍历下标时，数组元素是从大到小）\n建堆：less变成大顶堆（从上层到下层，堆元素是从大到小，同层之间随便）greater变成小顶堆（从上层到下层，堆元素是从小到大，同层之间随便）\n默认情况下：建堆的时候，默认是大根堆（堆头是最大元素），第三个参数用greater会变成小根堆；\n排序的时候，默认是从小到大，但是第三个参数用greater会变成从大到小\n可以看到默认情况下都是用less，但是看起来是“反转”的。这其实是两种操作的本质逻辑不同导致的\n解释结论我觉得下面解释的还是有点不好理解。以下是我个人的理解。从模拟过程和bool返回值来分析。\n我们在排序一个数组{a,b,c,d}的时候，如果是自己去实现排序（升序）的功能，大致的思路是，从头到尾每次遍历两个元素，如果a&gt;b，less返回false不满足less函数的x&lt;y。不满足升序要求，需要交换两个数的位置，使其要满足x&lt;y。所以是从小到大，升序。\n对于 std::sort 默认使用的升序排序，它会判断 less(x, y) 是否为 true，即 x &lt; y。如果返回 false，说明当前两个元素顺序不对，就会交换，从而实现升序排列。\n如果是priority_queue，priority_queue不是算法，是容器适配器，是优先级队列。**它的“优先级”是由 Compare 来定义的。**它需要在编译期确定比较器类型，并实例化一个对象在内部反复调用，它初始化的时候就要确定Compare是什么。因为priority_queue&lt;T,Container,Compare&gt;。Compare去决定它的优先级设置方法。\n想象一下在priority_queue（大顶堆）插入一个新元素a，从队尾push，priority_queue会更具Compare（less）制定的排序规则判断优先级。如果是a&lt;top，那less返回true，就不用交换两个数的位置。所以是大顶堆\n比如你用 less&lt;int&gt;，即 x &lt; y，那么在比较时，如果 less(a, top) &#x3D;&#x3D; true，说明 a 比 top 小，优先级低，就不需要上浮 a；\n如果 less(top, a) &#x3D;&#x3D; true，说明 a 优先级高（大顶堆），需要上浮。\n排序（std::sort）默认行为：std::less&lt;T&gt; → 升序\nstd::vector&lt;int&gt; v = &#123;3, 1, 4, 2&#125;;std::sort(v.begin(), v.end(), std::less&lt;int&gt;()); // 默认就是升序// 结果：1, 2, 3, 4\n\n\n比较逻辑：std::less 比较 a &lt; b，如果 true，则 a 应该排在 b 前面。\n效果：较小的元素在前，整体是升序。\n\n使用 std::greater&lt;T&gt; → 降序\nstd::sort(v.begin(), v.end(), std::greater&lt;int&gt;());// 结果：4, 3, 2, 1\n\n\n比较逻辑：std::greater 比较 a &gt; b，如果 true，则 a 应该排在 b 前面。\n效果：较大的元素在前，整体是降序。\n\n结论：在排序中，std::less → 升序，std::greater → 降序，符合直觉。\n建堆（std::priority_queue 或堆算法）默认行为：std::less&lt;T&gt; → 大顶堆\nstd::priority_queue&lt;int&gt; pq; // 默认是 std::less&lt;int&gt;，大顶堆pq.push(3); pq.push(1); pq.push(4);// 弹出的顺序是 4, 3, 1\n\n\n堆的性质：父节点 &gt;&#x3D; 子节点（堆顶是最大值）。\n比较逻辑：std::less 比较 a &lt; b，如果 true，则 b 优先级更高（会被放到堆顶）。\n为什么看起来是“反转”的？因为 std::priority_queue 的设计是“优先级高的先弹出”，而默认情况下它用 std::less 来决定谁“优先级更高”。\n默认 std::less 表示“更小的值优先级更低”，因此更大的值优先级更高，会放在堆顶。\n如果 a &lt; b 为 true，说明 b 比 a 大，所以 b 应该排在更前面（堆顶）。\n\n\n\n\n\n使用 std::greater&lt;T&gt; → 小顶堆\nstd::priority_queue&lt;int, std::vector&lt;int&gt;, std::greater&lt;int&gt;&gt; pq; // 小顶堆pq.push(3); pq.push(1); pq.push(4);// 弹出的顺序是 1, 3, 4\n\n\n堆的性质：父节点 &lt;&#x3D; 子节点（堆顶是最小值）。\n比较逻辑：std::greater 比较 a &gt; b，如果 true，则 b 优先级更高（会被放到堆顶）。\n如果 a &gt; b 为 true，说明 b 比 a 小，所以 b 应该排在更前面（堆顶）。\n\n\n\n结论：在建堆中，std::less → 大顶堆，std::greater → 小顶堆，看起来和排序是“反转”的。\n自定义符合两个条件：\n​\tbool：返回值bool​\treturn x&lt;y;：重载&lt;之类的操作符，并且要决定比较什么元素。​\tPS：建议还要常引用，保险，禁止发生修改要比较的元素可能。\n数组函数：使用时不加括号，加了报错。写成 bool cmp(const T&amp;, const T&amp;) 是因为 sort 要传入一个 函数指针。类的对象（仿函数）：注意，排序时的类必须使用类的对象才对，直接使用类报错。重载 () 是因为 sort 接受“可调用对象”，仿函数对象本质上是重载了括号运算符的类对象**。不能传入类名，而是类的实例：类名是类型，不能调用 operator()，而类对象才是“可调用的”。**\n#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;// 重写排序函数bool cmpfunc(const int &amp;a, const int &amp;b)&#123;    return a &lt; b;    // &lt; 升序; &gt; 降序&#125;// 模仿less、greater构建类struct cmpClass&#123;    bool operator()(const int &amp;i, const int &amp;j)    &#123;        return (i &lt; j);    &#125;&#125;cmpClassObject;\t\t// 注意，排序时的类必须使用类的对象才对，使用类报错。int main()&#123;\t// 使用函数    vector&lt;int&gt; v1 = &#123;2, 3, 1, 6, 2, 5, 4&#125;;    // 使用时不加括号，加了报错    sort(v1.begin(), v1.end(), cmpfunc);    for (int i = 0; i &lt; v1.size(); i++)    &#123;        cout &lt;&lt; v1[i] &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;    // 1 2 2 3 4 5 6        // 使用类的对象    vector&lt;int&gt; v2 = &#123;2, 3, 1, 6, 2, 5, 4&#125;;    sort(v2.begin(), v2.end(), cmpClassObject);    for (int i = 0; i &lt; v2.size(); i++)    &#123;        cout &lt;&lt; v2[i] &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;    // 1 2 2 3 4 5 6    return 0;\n\n\n\n优先级队列priority_queue&lt;T, Container, Compare&gt;这里 Compare 是一个仿函数类型，用于控制“谁优先”。\n比较对象 必须是 () 重载形式（即仿函数），因为 STL 库底层会调用 comp(a, b)。\n为什么 priority_queue 的比较器不能写成函数？因为它需要在编译期确定比较器类型，并实例化一个对象在内部反复调用：\npriority_queue&lt;T, vector&lt;T&gt;, cmpClass&gt; q;\n\n\n\n\n定义类时同时定义操作符重载函数：操作符重载函数，必须是具体的**操作符&lt;**之类的，写()报错——一个自定义类 重载函数&lt;在类内\n自定义类，自定义比较函数：操作符重载函数，必须是具体的**操作符&lt;**之类的，写()报错—————一个自定义类  重载函数&lt;在类外\n自定义类，自定义包含比较函数的结构体：操作符重载函数，必须是写()———————————–一个自定义类，一个比较函数的结构体（）\n\n#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;/******** 定义类时同时定义操作符重载函数 ********/struct Node1&#123;    // 要比较的元素    int x;    // 构造函数    Node1(int x) &#123; this-&gt;x = x; &#125;    // 操作符重载函数，必须是具体的操作符&lt;之类的，写()报错    bool operator&lt;(const Node1 &amp;b) const    &#123;        // 实现less中需要的&lt;,大顶堆        return x &lt; b.x;    &#125;&#125;;/******** 自定义类，自定义比较函数 ********/struct Node2&#123;    // 要比较的元素    int x;    // 构造函数    Node2(int x) &#123; this-&gt;x = x; &#125;&#125;;// 操作符重载函数，必须是具体的操作符&lt;之类的，写()报错bool operator&lt;(const Node2 &amp;a, const Node2 &amp;b)&#123;    // less,大顶堆    return a.x &lt; b.x;&#125;/******** 自定义类，自定义包含比较函数的结构体 ********/struct Node3&#123;    // 要比较的元素    int x;    // 构造函数    Node3(int x) &#123; this-&gt;x = x; &#125;&#125;;struct cmpClass&#123;    // 操作符重载函数，必须是写()    bool operator()(const Node3 &amp;a, const Node3 &amp;b)    &#123;        // less,大顶堆        return a.x &lt; b.x;    &#125;&#125;;int main()&#123;    /******** 初始化优先级队列的对象p ********/    // Node1类型，默认使用vector，小顶堆，同 priority_queue&lt;Node1, vector&lt;Node1&gt;, less&lt;Node1&gt; &gt; p;    priority_queue&lt;Node1&gt; p;    // 乱序入队p.emplace(1);p.emplace(3);p.emplace(2);// 弹出队首while (!p.empty())&#123;    cout &lt;&lt; p.top().x &lt;&lt; &quot; &quot;;    p.pop();&#125;cout &lt;&lt; endl;// 3 2 1/******** 初始化优先级队列的对象q ********/// 同 priority_queue&lt;Node2&gt; q;priority_queue&lt;Node2, vector&lt;Node2&gt;, less&lt;Node2&gt;&gt; q;// 乱序入队q.emplace(1);q.emplace(3);q.emplace(2);// 弹出队首while (!q.empty())&#123;    cout &lt;&lt; q.top().x &lt;&lt; &quot; &quot;;    q.pop();&#125;cout &lt;&lt; endl;// 3 2 1/******** 初始化优先级队列的对象r ********/priority_queue&lt;Node3, vector&lt;Node3&gt;, cmpClass&gt; r;// 乱序入队r.emplace(1);r.emplace(3);r.emplace(2);// 弹出队首while (!r.empty())&#123;    cout &lt;&lt; r.top().x &lt;&lt; &quot; &quot;;    r.pop();&#125;cout &lt;&lt; endl;// 3 2 1return 0;\n\n\n参考：C++：std::greater()、std::less()、自定义比较函数的规则-CSDN博客\n","categories":["C++"],"tags":["C++","排序","堆","优先队列","priority_queue","比较函数"]},{"title":"堆(heap)结构","url":"/2025/07/28/%E5%A0%86%E7%BB%93%E6%9E%84/","content":"\n\n","categories":["数据结构"],"tags":["堆","数据结构","完全二叉树"]},{"title":"安装win11系统","url":"/2025/07/24/%E5%AE%89%E8%A3%85win11%E7%B3%BB%E7%BB%9F/","content":"\n\n 安装win11系统。\n参考的视频【干货】WIN11系统安装重装教程、全程干货13分钟搞定，小白也能自己重装系统！超详细解说~_哔哩哔哩_bilibili\n1.在U盘下载好系统1.1格式化U盘1.2搜索win11 进入官方网站下载 Windows 11\n\n下载第二个\n\n会下载一个文件，下载好之后打开 按照提示下载到U盘\n2.搜索电脑启动BIOS的快捷键最快的办法是百度搜索或者直接问客服\n联想ThinkPad 是 F12 \n3.在打开电脑但是并没有开机的时候狂按快捷键，使用U盘启动4.点击下一步即可这里选择第二个\n\n分区可以先全部删除，进入系统之后再分区\n系统盘建议安装在ssd固态硬盘\n5.跳过联网shift + F10\n输入 oobe\\bypassnro.cmd\n回车之后电脑会重启\n之后可以进行分区和联网下载电脑驱动\n","categories":["安装win11"],"tags":["电脑刷机"]},{"title":"无法打开“mscoree.lib”错误","url":"/2025/07/24/%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80%E2%80%9Cmscoree-lib%E2%80%9D%E9%94%99%E8%AF%AF/","content":"\n\n需要在下载VS的时候加插件\n下载了的也可以直接打开VS Install修复\n\n需要添加\n\n同时，我还安装了.NET Framework 4.8 SDK\n在单个组件里面。\n","categories":["报错"],"tags":["C++","VS","C#","hsl库"]},{"title":"替换css文件之后没有重新加载样式","url":"/2025/07/31/%E6%9B%BF%E6%8D%A2css%E6%96%87%E4%BB%B6%E4%B9%8B%E5%90%8E%E6%B2%A1%E6%9C%89%E9%87%8D%E6%96%B0%E5%8A%A0%E8%BD%BD%E6%A0%B7%E5%BC%8F/","content":"\n\n使用的是 Qt 的 qrc 资源系统（比如 &quot;:/qss/style.qss&quot;），那么只是替换文件是不够的，你需要重新编译资源文件。\n修改 .qrc 文件后重新运行 rcc 或者 重新构建项目。\n","categories":["报错"],"tags":["C++","Qt","CSS"]},{"title":"第一篇博客","url":"/2025/07/02/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/","content":"\n​\tDaiYueJuan.github.io这是我的博客网站！\n​\t这是我第一篇博客。记录一下为什么会有想写博客的念头。\n​\t在我研究生的学习过程之中，在我遇到问题的时候我会上网搜索。在CSDN，Google，百度，stackoverflow，还有GPT等等平台直到解决我遇到的问题。搜索的过程并不难，但是如果间隔很久再遇见同样的问题，我可能还是要整个平台再找一遍，这样效率很低。而人的记忆力也不是无限的，所以我决定写博客。\n​\t记录我在学习的笔记以及遇到的问题和解决方法。\n"}]