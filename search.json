[{"title":"C++数字与字符串互相转换","url":"/2025/07/28/C-%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86/","content":"\n\n\n\nC&#x2F;C++数字与字符串互相转换参考：原文链接：https://blog.csdn.net/m0_73633807/article/details/140817283\n字符串转为数字一、利用ASCII我们知道每个字符都有一个ASCII码，利用这一点可以将字符-‘0’转为数字。在字母大小写转换时也可以利用这个性质。\n\n#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;char ch[]=&#123;&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;4&#x27;,&#x27;5&#x27;&#125;;int main()&#123;\tfor(int i=0;i&lt;strlen(ch);i++)&#123;\t\tcout&lt;&lt;ch[i]-&#x27;0&#x27;&lt;&lt;&quot; &quot;;\t&#125;\treturn 0;&#125;\n\n二、stoi()stoi函数是C++标准库中的一个函数，用于将字符串转换为整数，针对于string类型的。stoi函数是C++11引入的，因此只有在C++11及以上的版本中才能使用该函数。如果你的编译器版本较老，不支持C++11，那么就无法使用stoi函数。学校机房的dev-C++一般是C98标准的，需要自己手动改成C11。\nint num=stoi(const string&amp;  str, size_t* idx = 0, int base = 10);\n\n其中，str是需要转换的字符串；idx是一个指向size_t类型的指针，用于保存转换结束的位置；base是进制，默认为10进制。一般只给传第一个参数即可，也可以利用此函数实现进制转换。\n类似的还有**stol()、stof()、stod(),**分别将字符串类型转换成long long、float、double类型。\n#include&lt;iostream&gt;#include&lt;cstring&gt; using namespace std;string s=&quot;12345&quot;;int main()&#123;\tint a=stoi(s);\tlong long b=stol(s);\tdouble c=stod(s);\tfloat d=stof(s);\tcout&lt;&lt;&quot;int:&quot;&lt;&lt;a&lt;&lt;endl;\tcout&lt;&lt;&quot;long long:&quot;&lt;&lt;b&lt;&lt;endl;\tcout&lt;&lt;&quot;double:&quot;&lt;&lt;c&lt;&lt;endl;\tcout&lt;&lt;&quot;float:&quot;&lt;&lt;d&lt;&lt;endl;\treturn 0;&#125;\n\n三、atoi()atoi()函数是C语言中的一个函数，主要用于将字符串转换为整数。针对于字符数组,类似的还有atol()、atof()、atod()。\nint num=atoi(const char *str);\n\n其中，str是一个以null结尾的字符串，表示要转换的整数。\n该函数将从字符串的开头开始解析，直到遇到第一个非数字字符为止。如果开头是一个正号或负号，它也会解析为整数的一部分。如果字符串中的第一个非空格字符不是有效的数字字符或正负号，则返回0。\n四、sscanf()sscanf函数是一个用来将字符串按照指定格式解析的函数。它接受一个输入字符串和一个格式字符串作为参数，并根据格式字符串的指示将字符串中的数据解析为对应的变量中。主要是针对于字符数组。\nsscanf(str,&quot;%d&quot;,&amp;num);//str字符数组,%dint类型,num转换完成数字\n\n五、stringstreamstringstream是C++中的一个类，可以用来对字符串进行输入输出操作。它是基于字符串的流，可以用来将字符串转换为其他类型的数据，以及将其他类型的数据转换为字符串。stringstream类的头文件是，我们需要包含这个头文件才能使用stringstream类。\n#include&lt;iostream&gt;#include&lt;sstream&gt;#include&lt;cstring&gt;#include&lt;typeinfo&gt; using namespace std;int main()&#123;\tstringstream ss;\tstring s=&quot;12345&quot;;\tint num;\tss&lt;&lt;s;//将字符串读入字符串流 \tss&gt;&gt;num;//从字符串流中读取数据转换为整数\tcout&lt;&lt;typeid(num).name()&lt;&lt;&quot; &quot;&lt;&lt;num&lt;&lt;endl;\treturn 0; &#125;\n\n\n\n数字转为字符串一、利用ASCII字符转数字可以-‘0’，数字转字符那么就可以+’0’，还是利用了ASCII码值的特性。\n#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;int nums[]=&#123;1,2,3,4,5&#125;;int main()&#123;\tfor(int i=0;i&lt;sizeof(nums)/sizeof(int);i++)&#123;\t\tcout&lt;&lt;nums[i]+&#x27;0&#x27;&lt;&lt;&quot; &quot;;\t&#125;\treturn 0;&#125;\n\n注意：转换结果为49 50 51 52 53 ，对应ASCII码值，因为原理就是用ASCII码转换的。\n二、to_string()to_string函数是C++标准库提供的一个函数，用于将不同类型的数据转换为字符串。可以将int、float、double、long long等类型转换为string类型。需要包含头文件#include\n#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;int a=24;long long b=12345678;double c=3.1415;string s;int main()&#123;\ts=to_string(a);\tcout&lt;&lt;s&lt;&lt;endl;\ts=to_string(b);\tcout&lt;&lt;s&lt;&lt;endl;\ts=to_string(c);\tcout&lt;&lt;s&lt;&lt;endl;\treturn 0;&#125;\n\n三、itoa()itoa函数用于将整数转换为字符串。类似的还有ltoa、ftoa、dtoa分别将long long、float、double转换为字符串类型。针对于字符数组。\nitoa(num,str,10);\n\n第一个参数是待转换的数字，第二个参数是转换完成的字符数组，第三个是转换的进制数，默认10进制。\n#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;int n=12345;char str[10];int main()&#123;\titoa(n,str,10); \tcout&lt;&lt;str&lt;&lt;endl;\treturn 0;&#125;\n\n四、sprintf()sprintf()函数是c语言库中的函数，可以将数字转换为字符串类型，一般转换为字符数组。\nsprintf(str,&quot;%d&quot;,num);\n\nstr是转换完成的字符数组，%d是类型，num是待转换的数字。 \n#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;int n=12345;char str[10];int main()&#123;\tsprintf(str,&quot;%d&quot;,n); \tcout&lt;&lt;str&lt;&lt;endl;\treturn 0;&#125;\n\n五、stringstream与字符串转数字的一样，可以互相转换，同时还是要包含头文件，具体使用如下\n#include&lt;iostream&gt;#include&lt;sstream&gt;#include&lt;cstring&gt;#include&lt;typeinfo&gt; using namespace std;int main()&#123;\tstringstream ss;\tstring s=&quot;12345&quot;;\tint num=54321;\tss&lt;&lt;num;//将int类型的数据写入字符串流中\ts=ss.str();//将字符串流中的数据转换为string类型\tcout&lt;&lt;typeid(s).name()&lt;&lt;&quot; &quot;&lt;&lt;num&lt;&lt;endl;\treturn 0; &#125;\n\n\n\n\n\n个人总结：在C++中：\n字符串转数字：常用ASCII、stoi()\\stod()\\stol()\\stoll()。 ASCII只能是一位数字，stoi()\\stod()\\stol()\\stoll()适用于各种类型。\nstoi—–string to int\n数字转为字符串：常用ASCII、to_string()（要包含头文件#include）\n","categories":["C++"],"tags":["C++","刷题"]},{"title":"DIY主机","url":"/2025/07/03/DIY%E4%B8%BB%E6%9C%BA/","content":"\n​\t刚刚结束自己主机的安装，来记录一下经验和历程，方便之后自己需要再次配主机或者帮朋友看配置。\n如何写适合自己的配置单\n\n\n1.确定预算和需求​\t配电脑主机也是买东西，最重要的当然是准备花多少钱和主要用来干什么。\n​\t预算可以分为几个档：3000以下，3000-4000，4000-5000，5000-6000，以及更高。感觉不是重度生产力用户，在4000-5000都是够用的。我为什么这么说呢？因为10块和100块的东西使用差别可能很明显，像杂牌有线耳机和苹果有线耳机你用起来能够很明显的感受到区别。那100块的和1000块的呢？当然也有区别，但是在普通人的感官下没有10元和100元的大，还有更贵的耳机和1000元的对比，当然也有区别，但是我应该很难对比感受出来。从够用的情况来说5000左右的电脑主机已经非常够了。在这里我只讨论一手商品。\n​\t需求主要分为工作和游戏。\n​\t工作也有细分，以我写代码编程来说，我需要好一点点的CPU，更多的线程和更快的处理速度。至于其他的工作需求，我就不是很懂了。\n​\t游戏大概分为网游、单机、3a、fps。网游相对于其他的更加看重cpu一点。当然显卡也很重要。\n​\t我的需求：流程的编程，以及游戏，游戏主要玩英雄联盟和地平线4。所以我的cpu和显卡都不用特别好也不要特别差就可以了。\n​\t**我的预算：**4000-5000\n2.根据预算和需求写配置单2.1主机有八大组成部分：CPU、主板、散热、显卡、内存、硬盘、机箱、电源​\t \tCPU：是电脑的处理器，用来处理数据\n​\t\t主板：我认为是整个电脑的载体，连接起整个电脑。\n​\t\t散热：散热主要是安装在CPU上面的散热，还有机箱风扇。顾名思义就是用来散热，让电脑不会太烫。\n​\t\t显卡：我认为主要作用就是和显示相关，比如游戏和三维建模的显示和加载速度。\n​\t\t内存：内存和我们平时问“欸，你手机多大内存？”的内存不一样，内存是电脑临时存储数据的地方，越大就放的越多处理越快。一般来说最好是双通道（也就是两根一起），现在常见的有8+8，16+16。内存有很多参数，比如颗粒，时序，频率。据我的了解，颗粒最重要，好的颗粒会更加耐用也更贵。时序是越小越好，频率是越高越好。但是！我觉得像我这种普通人C18的时序和C16时序，频率3200和3600很难用出区别。根据预算选择即可。\n​\t\t硬盘：就是电脑的存储空间。现在的内存分为固态硬盘和机械硬盘，固态的读写速度很快，体积也小，但是一但损坏数据不可恢复。机械硬盘读写速度相对于更慢，体积更大，数据更容易恢复。硬盘大小主要分为：512G，1T，2T。\n​\t\t机箱：能把这些配件装在一起的容器。要注意机箱能不能装下这些配件，根据预算选择，有海景房和普通的。\n​\t\t电源：电源是电脑的心脏，用来给电脑供电。最好稍微买大一点点。选择好一点的品牌。网上会有很多测评，选一个比较好的即可。\n​\t了解完八大件，就可以写配置单了。以我的预算为例：4000-5000，最后实际花费4500+\n2.2首先确定 CPU、主板、显卡 三个（不分先后）。​\t\t显卡：一般来说显卡可能占到预算的50%左右，那我大概就是2000左右，显卡有N卡和A卡，N卡是英伟达生产的，A卡是AMD。N卡更贵一点，但是市面上很多游戏和软件更支持N卡，A卡便宜一些，但是有掉驱动的风险和市面支持度小于N卡。 \n​\t\t显卡由两大公司生产，然后下发给其他厂家组装。一线品牌有华硕、微星、技嘉（蓝宝石不知道算不算）。二线就是其他了。但是我认为区别不会很大，因为最核心的东西不是他们生产的，根据预算买就可以了。\n​\t\t我买的是A卡：7650gre 品牌蓝宝石 具体型号为7650gre极地版。2000左右的显卡都是入门级别也叫甜品卡。建议买新款显卡。pdd购入价格1889。\n​\t\t**CPU和主板：**CPU两大生产商为Intel和AMD，Intel在之前市场占有率大于AMD但是现在慢慢也差不多了。可以看CPU天梯图，但是我个人观察下来，觉得Intel的选择更多，和显卡一样，买新不买旧。主板可以和CPU一起买，价格会更便宜。一般来说，这两个的价格会差不多，也是根据预算选择，其实预算确定之后选择就比较少了。需要注意的是，主板能不能跑满cpu，怎么看呢？网上搜一下就知道了。其实我觉得主板还是比较重要的，它是整个电脑的载体，提供八大件接口。建议买华硕，微星，技嘉。\n​\t\t我买的13490f和技嘉的B760M GAMING AC DDR4一共1379，pdd平台购入。\n2.3 其他配件​\t\t内存：建议双通道，然后再选一个性价比比较高的即可。比如现在的DDR4比DDR5便宜很多。\n​\t\t硬盘：一定要有一个固态硬盘，用来安装系统。游戏和办公软件也建议安装在固态硬盘，最好是1T。选性价比高即可，这种很难用坏。也要注意颗粒，现在来说最好避免QLC颗粒。机械硬盘根据需求可加可不加。\n​\t\t散热：在网上看一下测评，选择一个使用得多并且品牌售后好的常用的即可。要注意能不能压住cpu的散热（搜索即可知道）。\n​\t\t机箱：在能把所有东西放进去的前提下，依据个人喜好选择。我比较重视机箱前面的接口数量和类型，但是我的主板并没有前置typeC的接口，很可惜我的价位没有这种配置。\n​\t\t电源：尽量选择网上评价好的，这一部分不能省钱。电源瓦数根据整个主机来算，不会算就可以看网上其他人差不多配置买多大的就可以了。电源品牌的选择也可以网上搜索评价较好的。\n​\t\t\n2.4我的配置单\n装机1.准备工作​\t要先熟悉整个装机的过程，推荐B站硬件茶谈和天才赵德驻，可以各看一遍，并且做好笔记。除了这些也可以去小红书，抖音搜索一些技巧。\n​\t还要吃饱饭！\n2.我的装机历程。我提前一天看了B站的视频并且做了步骤的PPT和注意事项，搜索了各大平台。\n主要参考豆瓣两位姐妹的文章\n12600KF+5060成果展示！附从选购到点亮全流程经验\n教你从0开始打造自己的电竞书桌——新手小白618装机全流程攻略\n我录制了每一个的拆箱视频。\nCPU-内存-硬盘-散热-显卡（暂时）-电源（全模组接线）–尝试点亮–拆掉显卡和电源线–拆机箱–安装主板–接线–安装显卡–安装风扇\n需要注意的是，主板供电的24pin接口特别难插拔，最好上下晃动不要左右。\n先点亮再接线\n点不了看赵德驻\n我是主板放进机箱之前点亮之后没有拆掉主板24pin的电线，直接接入主机，这样也很方便，觉得甚至cpu供电也可以这样因为cpu供电在主板进入机箱之后不好插。\n","categories":["电脑"],"tags":["装机","电脑","DIY"]},{"title":"C++命名规范","url":"/2025/08/09/C-%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/","content":"\n\n参考：\n看了这么多代码，谈一谈代码风格！ | 代码随想录\nGoogle C++ 编程风格指南\n前言：为什么会注意到C++命名规范呢？\n因为在我实习的过程中，无法避免地需要去阅读师兄师姐师弟师妹的代码。在我们软件中当然也有 JJ 师兄定制的代码规范，但是并不是很全面也不是所有人都会去遵循，这就导致有些代码可读性非常非常非常差。\n举例一个我刚刚实习看的业务代码让我很难阅读的地方：\n变量命名完全不规范，成员变量和局部变量混乱，成员变量有时候加m_ 有时候不加，局部变量也有时候加m_ 。尽管有IDE的帮助，阅读起来还是很费劲。\n我相信他自己回来重新看也会很费劲。\n为了提升自己代码的可读性，规范命名是很重要的。方便自己也方便共同开发的大家。\n简略内容变量的命名主流有如下三种变量规则：\n\n小驼峰、大驼峰命名法\n下划线命名法\n匈牙利命名法\n\n小驼峰，第一个单词首字母小写，后面其他单词首字母大写。例如 int myAge;\n大驼峰法把第一个单词的首字母也大写了。例如：int MyAge;\n通常来讲 java和go都使用驼峰，C++的函数和结构体命名也是用大驼峰，\n下划线命名法是名称中的每一个逻辑断点都用一个下划线来标记，例如：int my_age，下划线命名法是随着C语言的出现流行起来的，如果大家看过UNIX高级编程或者UNIX网络编程，就会发现大量使用这种命名方式。\n匈牙利命名法是：变量名 &#x3D; 属性 + 类型 + 对象描述，例如：int iMyAge，这种命名是一个来此匈牙利的程序员在微软内部推广起来，然后推广给了全世界的Windows开发人员。\n总结：尽管现在IDE很发达，我个人现在还是认为匈牙利命名法更加有可读性。水平留白（代码空格）操作符左右一定有空格，例如\ni = i + 1;\n\n分隔符（, 和;）前一位没有空格，后一位保持空格，例如：\nint i, j;for (int fastIndex = 0; fastIndex &lt; nums.size(); fastIndex++)\n\n大括号和函数保持同一行，并有一个空格例如：\nwhile (n) &#123;    n--;&#125;\n\n控制语句（while，if，for）后都有一个空格，例如：\nwhile (n) &#123;    if (k &gt; 0) return 9;    n--;&#125;\n\n以下是我刚写的力扣283.移动零的代码，大家可以看一下整体风格，注意空格的细节！\nclass Solution &#123;public:    void moveZeroes(vector&lt;int&gt;&amp; nums) &#123;        int slowIndex = 0;        for (int fastIndex = 0; fastIndex &lt; nums.size(); fastIndex++) &#123;            if (nums[fastIndex] != 0) &#123;                nums[slowIndex++] = nums[fastIndex];            &#125;        &#125;        for (int i = slowIndex; i &lt; nums.size(); i++) &#123;            nums[i] = 0;        &#125;    &#125;&#125;;\n\n\n\n总结：其实在使用VS2019写代码的时候，编译器都会自动调整，比如说 int a&#x3D;1;编译器会在你输入 ; 的时候自动修改为 int a &#x3D; 1;\n所以也说明这样的代码看上去更加规范，好阅读不会挤在一起。\nGoogleC++命名规范（详细）晚一点总结，里面内容很多。我还没有读完。\n","categories":["C++"],"tags":["C++","代码命名规范"]},{"title":"错误LNK2001,无法解析的外部符号，static QMetaObject","url":"/2025/07/31/QMetaObject/","content":"\n\n严重性\t代码\t说明\t项目\t文件\t行\t禁止显示状态 错误\tLNK2001\t无法解析的外部符号 “public: static struct QMetaObject const xxxxx::staticMetaObject” (?staticMetaObject@xxxxx@@2UQMetaObject@@B)\t\n出现场景：在新电脑安装VS2019,和QT VS TOOLS插件之后，代码是可以正常运行生成的。后面安装了番茄助手，然后QT VS TOOLS 的插件就不见了（暂时没有找到原因） 。就出现了这个报错。\n这个链接错误（LNK2001: 无法解析的外部符号 staticMetaObject）通常是由于 Qt 宏（如 Q_OBJECT）使用不当或相关的 moc 文件没有被正确生成&#x2F;链接导致的。\n常见原因及解决方案： 1.类中使用了 Q_OBJECT 宏，但未运行 moc（Meta-Object Compiler）\n​\t检查你的类 xxxxx 的头文件是否包含了 Q_OBJECT 宏。\n2.头文件未被正确包含在构建系统中（尤其是非 Qt Creator 的项目）\n​\t确保你的类头文件 xxx 已添加到项目中，而不是仅仅被引用（否则 VS 不会触发 moc）。\n​\t右键 .h 文件 → 属性 → 设置为 “使用 MOC 编译器” 或确保 Qt VS Tools 插件启用。\n\n在设置之后代码可以生成，但是我觉得很奇怪为什么之前添加新文件不会需要手动修改类型呢？后面发现是QT VS TOOLS插件的问题。\n我重新安装之后，解决方案里面有些项目被卸载。又卸载重新安装了一次，把被卸载的项目先移除然后再添加进来。\n","categories":["报错"],"tags":["C++","Qt"]},{"title":"HEXO的Next主题设置以及个性化设置","url":"/2025/07/05/HEXO%E7%9A%84Next%E4%B8%BB%E9%A2%98%E8%AE%BE%E7%BD%AE%E4%BB%A5%E5%8F%8A%E4%B8%AA%E6%80%A7%E5%8C%96%E8%AE%BE%E7%BD%AE/","content":"\n\n在已经搭建Hexo个人博客的基础上，设置next的主题和个性化设置。\n搭建Hexo个人博客可以参考Fiveth的博客“如何用Hexo搭建个人博客”。如何用Hexo搭建个人博客?\n1.设置next主题进入hexo官网，点击“主题”，在搜索的地方输入“next”，点击“nexT”进入到github里面。下面有官方的详细安装介绍。\n我使用的是 clone ssh的方法。将文件夹放在themes目录下。\n然后在 _config.yml 文件设置theme: next\n最后hexo clean &amp;&amp; hexo g &amp;&amp; hexo s\n即可生成\n注意：这里的theme: next应该与文件夹的名称相同，如果下载的文件是hexo-theme-next，可以改文件夹的名称也可以改theme: next为 theme: hexo-theme-next\n2.个性化next主题根据clone下来的next文件里面的 _config.yml 可以得知\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\nIt’s recommended to use Alternate Theme Config to configure NexT\nModifying this file may result in merge conflict\nSee: https://theme-next.js.org/docs/getting-started/configuration\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\nTheme Core Configuration Settings\nSee: https://theme-next.js.org/docs/theme-settings/\n进入网站可以知道，NexT 目前支持两种推荐的配置方式，你只需要选择其中一种：\n​\t传统方式是修改 themes/next/_config.yml，但这个文件会在更新主题时被覆盖，所以 NexT 主题现在推荐使用 Hexo 的“主题配置重载（Alternate Theme Config）”功能。\n​\t它允许你在 Hexo 根目录创建一个 _config.[theme_name].yml 文件（NexT 默认的 theme 名是 next，所以就是 _config.next.yml）。\n​\tHexo 会优先加载这个文件的配置，并覆盖掉默认的主题配置。\n​\ttheme_config 模式 —— 把 NexT 配置直接写在主配置文件 _config.yml 中。\n我使用的第一种方法。将其copy即可。\n# Installed through npmcp node_modules/hexo-theme-next/_config.yml _config.next.yml# Installed through Gitcp themes/next/_config.yml _config.next.yml\n\n\n\n2.1设置Scheme# Schemes\n#scheme: Muse\n#scheme: Mist\n#scheme: Pisces\nscheme: Gemini\n取消井号键即可，其他的注释掉。\n2.2设置分类和标签以及关于在博客根目录下打开git bash here \nhexo new page categorieshexo new page tagshexo new page about\n\n然后找到blog&#x2F;source&#x2F;categories&#x2F;index.md\n路径下的index.md文件\n---title: 分类date: 2025-07-04 15:16:40type: &quot;categories&quot;---\n\n---title: 标签date: 2025-07-04 15:16:23type: &quot;tags&quot;---\n\n之后写文章的时候添加即可。\ntitle: HEXO的Next主题设置以及个性化设置description: 我的hexo界面设置date: 2025-07-05 14:39:54tags:  - hexo  - next主题categories:  - hexo\n\n\n\n在about文件夹里面的index.md编辑就可以了。\n2.3设置阅读全文1.在文章中使用&lt; !--more--&gt; 手动进行截断\n2.文章简介可以写在开头\ndescription: 我的hexo界面设置\n\n3.在主题配置文件中添加 ，默认截取的长度为 150 字符，可以根据需要自行设定,直接复制到 _config 文件的底部\nauto_excerpt:  enable: true  length: 150\n\n\n\n2.4设置显示字数统计和阅读时长在博客目录下安装npm install hexo-symbols-count-time --save\n在_config.yml中加入配置\nsymbols_count_time: #文章内是否显示  symbols: true  time: true # 网页底部是否显示  total_symbols: true  total_time: true\n\n\n\n2.5设置站内搜索在博客目录下安装npm install hexo-generator-searchdb --save，此时使用hexo cl &amp;&amp; hexo g就会在博客public目录下生成一个search.json，在使用hexo d部署上去搜索就可以用了\nsearch:  path: search.json  field: post\n\n在_config.next.yml\n里面将local_search: \nlocal_search:  enable: true\n\n","categories":["hexo"],"tags":["hexo","next主题"]},{"title":"VMware17.6安装VMware Tools失败的原因以及解决方法","url":"/2025/09/08/VMwareTools%E5%AE%89%E8%A3%85%E5%A4%B1%E8%B4%A5%E7%9A%84%E5%8E%9F%E5%9B%A0%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/","content":"\n\n在VMware17.6里面 安装ubuntu 和 win11 都发现VMware Tools很难安装，一开始我以为是我系统安装的问题，后面经过搜索发现2025年有遇见同样的问题。\n原来是博通变更链接致 VMware 自动更新功能失效\n博通变更链接致 VMware 自动更新功能失效，用户被迫手动升级 - IT之家\n然后参考\n(68 封私信 &#x2F; 24 条消息) vmware解决更新Tools报错，无法连接更新服务器。请检查您的 Internet 设置或联系您的系统管理员 - 知乎\n【解决方案】Windows11 Vmware 17.6.0更新Tools报错，无法连接更新服务器。请检查您的 Internet 设置或联系您的系统管理员。_无法解析更新服务器。请检查您的 internet 设置或联系您的系统管理员。-CSDN博客\n解决方法为：\n在虚拟机下载VMware Tools工具 安装。\n下载地址：\nhttps://packages.vmware.com/too\n然后一直点下一步安装即可。\n","categories":["虚拟机"],"tags":["虚拟机","解决问题"]},{"title":"QtInstallation问题","url":"/2025/07/24/QtInstallation%E9%97%AE%E9%A2%98/","content":"\n\n​\t在安装好VS2019和Qt5.14.2之后，我准备跑之前的代码，打开代码之后vs提示的错误如下：\n\n这里主要解决第一个。\nThe project’s’Qt Installation’ property is not set correctly.Please specify a valid Qt version or path.\n在vs 点击“扩展“ –&gt; ”Qt VS Tools“—&gt;”Qt Versions”或者”Options”\n\n在name 输入 自己qt的版本 和操作系统位数\n在Location 选择qt的安装路径\n​\t进入选择对话框后，按照安装路径进入以下文件夹，选择qmake.exe,点击打开\n注意： 这里要区分32位和64位\n\n","categories":["Qt"],"tags":["Qt","QtInstallation","VS2019"]},{"title":"VS2019番茄助手安装","url":"/2025/07/29/VS2019%E7%95%AA%E8%8C%84%E5%8A%A9%E6%89%8B%E5%AE%89%E8%A3%85/","content":"\n\n每次安装都会忘记一些关键步骤，写下来！\n参考：给 VS2019 安装个 Visual Assist x 插件 - ALLEN_2008 - 博客园\nVS2019 安装番茄助手（Visual Assist x 插件）攻略_vs2019番茄助手-CSDN博客\n相应环境\n系统平台：WIN11\nVS：VS2019\nVAX版本：Visual Assist X 10.9.2406.0（其他版本也可对应操作）\n\n重点说明：\n安装VA_X_Setup2440_0.exe前，先要右键exe文件勾选兼容性。在 win7 下，Visual Assist x 可能需要兼容运行（右击，属性，兼容性设置），因为直接双击可能就给你红框崩溃。\n去掉 VS2019 插件更新勾选框和 VAX 更新勾选框。（这个我没用到）\n\n安装步骤先上一张安装文件源图\n\n双击直接安装VA_X_Setup2406_0.exe，在装到VS2019时会发生错误，提示安装不成功（不用管，接着让它装）。就是一直不管它，一开始会retry，后面会说错误此时，\n​\t用 everything（一个软件，可以在网上下载） 在 Temp 文件夹找到与 VS2019 匹配的安装版本，这里是 VaXSetup.vsix，拷贝到桌面（ 重点！在出现错误窗口的时候，不要关！不要关！不要关！这个时候用everything去搜 VaXSetup.vsix ）\n​\t等原文件 VA_X_Setup2406_0.exe 安装完之后（VA_X_Setup2406_0.exe等它报错才能删除），会在C:\\Users\\用户\\AppData\\Local\\Microsoft\\VisualStudio\\16.0_5b3ff307（这个地方每个人是不同的，但是都是16.0_开头）\\Extensions 下产生文件。删除这个目录下所有文件夹和文件。（这个路径不一定是完全相同的）\n​\t使用 VaXSetup.vsix 重新安装，此时是安装到 VS2019，最终会提示安装成功。同时会在 Extensions 目录生成新的文件夹和文件。（其实对于 VS2019， VAX 是安装 Extensions 目录下的，所以如果 VAX 插件出现问题，则可以多次删除，多次重装。2010 及之前版本则不同。）\n​\t用破解的 VA_X64.dll 和 PiaoYun64.dll 拷贝到 Extensions&#x2F;随机文件夹(就一个文件夹，名字是随机的)&#x2F; ，路径下（简单一点的话就用everything搜VA_X.dll,找到类似这个路径，把VA_X64.dll 和 PiaoYun64.dll 拷贝进去）。\n​\t找到 VS2019 的安装目录。具体为：右击 VS2019 图标-&gt;属性，在快捷方式栏找到“目标”，“目标”后面的文本框就是 [VS2019 安装](https://so.csdn.net/so/search?q=VS2019 安装&amp;spm&#x3D;1001.2101.3001.7020)目录.（如图）\n\n​\t按住win+R，输入cmd打开，在命令行切换到 5（第五步） 的目录，运行命令：devenv.exe &#x2F;safemode，回车（安全模式下运行一回）（如图）。此时在 VS2019 插件管理有 Visual Assist x 插件，但不能用。直接关闭 VS2019。\n怎么用命令行进入：\n默认是在C盘 所以先输入 d: 进入D盘\n然后使用cd可以进入目标目录（或者文件夹打开之后会自动进去像我的一样）\n\n.xkyamoyjllee{zoom:80%;}\n\n​\t这次正常打开 VS2019，最终会看到 extension 菜单下出现 Visual Assist x。\n​\t这还没完。需要去掉插件更新和 Visual Assist x 更新勾选。具体为：　　* ​\t拓展-&gt;管理拓展-&gt;已安装-&gt;弹出对话框的右上角，具体下图。\n\n\nVisual Assist x options 对话框左边-&gt;startup，见下图。\n\n\n在这里可以设置快捷键生成注释块\n\n\n","categories":["软件安装"],"tags":["C++","软件安装","番茄助手"]},{"title":"Hello World","url":"/2025/07/02/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\n\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"priority_queue","url":"/2025/07/28/priority-queue/","content":"\n\n参考：C++ STL priority_queue容器适配器详解 - C语言中文网\n代码随想录\n优先级队列以下参考代码随想录什么是优先级队列呢？\n其实就是一个披着队列外衣的堆，因为优先级队列对外接口只是从队头取元素，从队尾添加元素，再无其他取元素的方式，看起来就是一个队列。\n而且优先级队列内部元素是自动依照元素的权值排列。那么它是如何有序排列的呢？\n缺省情况下priority_queue利用max-heap（大顶堆）完成对元素的排序，这个大顶堆是以vector为表现形式的complete binary tree（完全二叉树）。\n什么是堆呢？\n堆是一棵完全二叉树，树中每个结点的值都不小于（或不大于）其左右孩子的值。 如果父亲结点是大于等于左右孩子就是大顶堆，小于等于左右孩子就是小顶堆。\n所以大家经常说的大顶堆（堆头是最大元素），小顶堆（堆头是最小元素），如果懒得自己实现的话，就直接用priority_queue（优先级队列）就可以了，底层实现都是一样的，从小到大排就是小顶堆，从大到小排就是大顶堆。\n以下参考C语言中文网priority_queue 容器适配器模拟的也是队列这种存储结构，即使用此容器适配器存储元素只能“从一端进（称为队尾），从另一端出（称为队头）”，且每次只能访问 priority_queue 中位于队头的元素。\n但是，priority_queue 容器适配器中元素的存和取，遵循的并不是 “First in,First out”（先入先出）原则，而是“First in，Largest out”原则。直白的翻译，指的就是先进队列的元素并不一定先出队列，而是优先级最大的元素最先出队列。\n\n注意，“First in，Largest out”原则是笔者为了总结 priority_queue 存取元素的特性自创的一种称谓，仅为了方便读者理解。\n\n那么，priority_queue 容器适配器中存储的元素，优先级是如何评定的呢？很简单，每个 priority_queue 容器适配器在创建时，都制定了一种排序规则。根据此规则，该容器适配器中存储的元素就有了优先级高低之分。\n举个例子，假设当前有一个 priority_queue 容器适配器，其制定的排序规则是按照元素值从大到小进行排序。根据此规则，自然是 priority_queue 中值最大的元素的优先级最高。\npriority_queue 容器适配器为了保证每次从队头移除的都是当前优先级最高的元素，每当有新元素进入，它都会根据既定的排序规则找到优先级最高的元素，并将其移动到队列的队头；同样，当 priority_queue 从队头移除出一个元素之后，它也会再找到当前优先级最高的元素，并将其移动到队头。\n基于 priority_queue 的这种特性，因此该容器适配器有被称为优先级队列。\n\npriority_queue 容器适配器“First in，Largest out”的特性，和它底层采用堆结构存储数据是分不开的。有关该容器适配器的底层实现，后续章节会进行深度剖析。\n\nSTL 中，priority_queue 容器适配器的定义如下：\ntemplate &lt;typename T,        typename Container=std::vector&lt;T&gt;,        typename Compare=std::less&lt;T&gt; &gt;class priority_queue&#123;    //......&#125;\n\n可以看到，priority_queue 容器适配器模板类最多可以传入 3 个参数，它们各自的含义如下：\n\ntypename T：指定存储元素的具体类型；\n\ntypename Container：指定 priority_queue 底层使用的基础容器，默认使用 vector 容器。\n\n作为 priority_queue 容器适配器的底层容器，其必须包含 empty()、size()、front()、push_back()、pop_back() 这几个成员函数，STL 序列式容器中只有 vector 和 deque 容器符合条件。\n\n\ntypename Compare：指定容器中评定元素优先级所遵循的排序规则，默认使用\nstd::less&lt;T&gt;\n\n按照元素值从大到小进行排序，还可以使用std::greater&lt;T&gt;\n\n按照元素值从小到大排序，但更多情况下是使用自定义的排序规则。\n\n其中，std::less 和 std::greater 都是以函数对象的方式定义在  头文件中。关于如何自定义排序规则，后续章节会做详细介绍。\n\n\n\n创建priority_queue的几种方式由于 priority_queue 容器适配器模板位于&lt;queue&gt;头文件中，并定义在 std 命名空间里，因此在试图创建该类型容器之前，程序中需包含以下 2 行代码：\n#include &lt;queue&gt;using namespace std;\n\n创建 priority_queue 容器适配器的方法，大致有以下几种。\n\n创建一个空的 priority_queue 容器适配器，第底层采用默认的 vector 容器，排序方式也采用默认的 std::less 方法：\n\nstd::priority_queue&lt;int&gt; values;\n\n\n可以使用普通数组或其它容器中指定范围内的数据，对 priority_queue 容器适配器进行初始化：\n\n//使用普通数组int values[]&#123;4,1,3,2&#125;;std::priority_queue&lt;int&gt;copy_values(values,values+4);//&#123;4,2,3,1&#125;//使用序列式容器std::array&lt;int,4&gt;values&#123; 4,1,3,2 &#125;;std::priority_queue&lt;int&gt;copy_values(values.begin(),values.end());//&#123;4,2,3,1&#125;\n\n注意，以上 2 种方式必须保证数组或容器中存储的元素类型和 priority_queue 指定的存储类型相同。另外，用来初始化的数组或容器中的数据不需要有序，priority_queue 会自动对它们进行排序。\n\n还可以手动指定 priority_queue 使用的底层容器以及排序规则，比如：\n\nint values[]&#123; 4,1,2,3 &#125;;std::priority_queue&lt;int, std::deque&lt;int&gt;, std::greater&lt;int&gt; &gt;copy_values(values, values+4);//&#123;1,3,2,4&#125;\n\n事实上，std::less 和 std::greater 适用的场景是有限的，更多场景中我们会使用自定义的排序规则。\n\n由于自定义排序规则的方式不只一种，因此这部分知识将在后续章节做详细介绍。\n\npriority_queue提供的成员函数priority_queue 容器适配器提供了表 2 所示的这些成员函数。\n\n\n\n成员函数\n功能\n\n\n\nempty()\n如果 priority_queue 为空的话，返回 true；反之，返回 false。\n\n\nsize()\n返回 priority_queue 中存储元素的个数。\n\n\ntop()\n返回 priority_queue 中第一个元素的引用形式。\n\n\npush(const T&amp; obj)\n根据既定的排序规则，将元素 obj 的副本存储到 priority_queue 中适当的位置。\n\n\npush(T&amp;&amp; obj)\n根据既定的排序规则，将元素 obj 移动存储到 priority_queue 中适当的位置。\n\n\nemplace(Args&amp;&amp;… args)\nArgs&amp;&amp;… args 表示构造一个存储类型的元素所需要的数据（对于类对象来说，可能需要多个数据构造出一个对象）。此函数的功能是根据既定的排序规则，在容器适配器适当的位置直接生成该新元素。\n\n\npop()\n移除 priority_queue 容器适配器中第一个元素。\n\n\nswap(priority_queue&amp; other)\n将两个 priority_queue 容器适配器中的元素进行互换，需要注意的是，进行互换的 2 个 priority_queue 容器适配器中存储的元素类型以及底层采用的基础容器类型，都必须相同。\n\n\n\n和 queue 一样，priority_queue 也没有迭代器，因此访问元素的唯一方式是遍历容器，通过不断移除访问过的元素，去访问下一个元素。\n\n在 C++ 中，emplace 和 push 的区别emplace 和 push 都可以用来向容器中添加元素，但它们的工作方式有所不同。在这个特定的代码中，使用 emplace 比 push 更高效，原因如下：\nemplace 直接构造元素\nq.emplace(nums[i], i) 会直接在优先队列的内存中构造一个 pair&lt;int, int&gt; 对象，避免了临时对象的创建和拷贝&#x2F;移动操作。\n它等价于 q.push(std::pair&lt;int, int&gt;(nums[i], i))，但更高效，因为 emplace 直接在容器内部构造对象，省去了额外的拷贝或移动开销。\n\npush 需要构造临时对象\n如果使用 push，你需要显式构造一个 pair 对象，如 q.push(make_pair(nums[i], i)) 或 q.push(&#123;nums[i], i)&#125;)。\n这会先创建一个临时 pair 对象，然后将其拷贝或移动到优先队列中，多了一次不必要的构造和拷贝&#x2F;移动操作。\n\n性能优势\n对于像 pair&lt;int, int&gt; 这样的简单类型，emplace 和 push 的性能差异可能不大，但在更复杂的场景（如构造含多个参数的对象）时，emplace 能显著减少开销。\n由于 emplace 是 C++11 引入的优化方式，它更符合现代 C++ 的高效编程风格。\n\n代码对比cpp\n// 使用 emplace（推荐）q.emplace(nums[i], i);  // 直接在优先队列中构造 pair// 使用 push（需要构造临时对象）q.push(std::make_pair(nums[i], i));  // 先构造临时 pair，再拷贝/移动到队列\n","categories":["C++"],"tags":["C++","C++基础","STL","容器适配器"]},{"title":"static和const修饰符被设计的原因和使用方法","url":"/2025/09/16/static%E5%92%8Cconst%E4%BF%AE%E9%A5%B0%E7%AC%A6%E8%A2%AB%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%92%8C%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/","content":"\n\n背景：写代码这一年多以来，或多或少都有在使用这些修饰符。但是感觉还是却一点什么东西，有点好奇为什么要有这些修饰符，没有会怎么样。于是有了这篇博客。做一次总结。\nstatic：static 在 C++ 中确实非常重要，它并不是随意设计的语法糖，而是解决了 C 语言（C++ 的祖先）在存储期、作用域、链接属性上的一系列核心问题。\nstatic 被创造的原因static 最早出现在 C 语言里，C++ 沿用了它。它的主要目的是在编译期&#x2F;链接期明确某个符号或变量的存储周期和可见性，以解决三个核心问题：\n变量的生命周期问题\n\n默认情况下，局部变量在函数调用时创建、函数退出时销毁。\n但有时我们希望“函数的某些状态”能跨调用保存，而又不想放到全局变量里（污染命名空间）。\nstatic 局部变量 &#x3D; 只初始化一次，直到程序结束才销毁。\n\n👉 这是为了支持状态保持（stateful function）。\n符号的可见性问题\n\n在 C 语言里，多个 .c 文件会链接在一起。\n如果你在多个文件里都定义了一个同名函数或全局变量，会冲突。\nstatic 修饰全局变量或函数 → 让它们只在本翻译单元（.cpp 文件）可见，避免链接冲突。\n\n👉 这是为了支持模块化编程。\n与类的结合（C++ 新增的语义）\n\nC++ 里引入了类，static 成为了类成员的重要修饰符：\nstatic 成员变量 → 属于类而不是对象（所有对象共享一份）。\nstatic 成员函数 → 不依赖对象实例即可调用。\n\n\n\n👉 这是为了支持面向对象中的共享数据与工具函数。\n总结：static 在C语言中是为了解决变量周期和同名函数或者变量的冲突问题而设计的。而在C++中又有与类的结合，实现不依赖对象而属于类的成员变量和成员函数。\nstatic的重要性static 之所以被创造并保留到现在，是因为它解决了模块化编程和状态管理的核心痛点：\n\n没有 static，所有函数和变量要么全局可见（容易冲突），要么局部且无法持久（无法跨调用保存状态）。\nstatic 刚好填补了这两者之间的空缺：\n局部但持久（局部 static 变量）；\n全局但私有（文件内 static 全局变量&#x2F;函数）；\n类级别共享（static 类成员）。\n\n\n\n可以说，没有 static，C++ 的模块化和面向对象都会大打折扣。\nstatic常见的使用场景static对于局部变量在局部变量之前加上关键字static，局部变量就被定义成为一个局部静态变量。\n内存中的位置：data段\n初始化：局部的静态变量只能被初始化一次\n作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域随之结束。\n\n当static用来修饰局部变量的时候，它就改变了局部变量的存储位置（从原来的栈中存放改为静态存储区）及其生命周期（局部静态变量在离开作用域之后，并没有被销毁，而是仍然驻留在内存当中，直到程序结束，只不过我们不能再对他进行访问），但未改变其作用域。\n\ne.g.\nvoid f() &#123;\tint a = 0;\tstatic int b = 0;\ta++;\tb++;\tstd::cout &lt;&lt;  a &lt;&lt; &quot;,&quot; &lt;&lt; b &lt;&lt; std::endl;&#125;void demo()&#123;\tf();\tf();\tf();&#125;\n\n输出\n1，11，21，3\n\nstatic对于全局变量&#x2F;函数在全局变量之前加上关键字static，全局变量就被定义成为一个全局静态变量。\n内存中的位置：静态存储区（静态存储区在整个程序运行期间都存在）\n初始化：未经初始化的全局静态变量会被程序自动初始化为0\n作用域：全局静态变量在声明他的文件之外是不可见的。准确地讲从定义之处开始到文件结尾**。(只能在本文件中存在和使用**)\n\n 全局变量本身就是静态存储方式， 静态全局变量当然也是静态存储方式。两者的区别在于非静态全局变量的作用域是整个源程序， 当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的（在其他源文件中使用时加上extern关键字重新声明即可）。 而静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它。\n\n修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static。（和全局变量一样限制了作用域而已）\nstatic对于类\n成员变量\n用static修饰类的数据成员实际使其成为类的全局变量，会被类的所有对象共享，包括派生类的对象。\n因此，static成员必须在类外进行初始化，而不能在构造函数内进行初始化。不过也可以用const修饰static数据成员在类内初始化 。\n\n成员函数\n用static修饰成员函数，使这个类只存在这一份函数，所有对象共享该函数，不含this指针。\n静态成员是可以独立访问的，也就是说，无须创建任何对象实例就可以访问。\n不可以同时用const和static修饰成员函数。\n\n\nconst:—只读const 被创造的原因在 C 语言早期，所有变量几乎都是可修改的，这带来了几个问题：\n\n表达力不足\n程序员想要声明一个“常量”（例如 π&#x3D;3.14159），结果只能用 #define PI 3.14159。\n但是 #define 只是预处理替换，没有类型检查，很危险。\nconst 被创造出来，就是为了提供 类型安全的常量。\n\n\n接口安全\n在函数参数中，如果只需要读数据，但又传了个指针&#x2F;引用，调用者可能无意修改数据。\nconst 可以在函数签名中表达只读约束，避免误改，提高安全性。\n\n\n编译器优化\n如果某个变量被标记为 const，编译器就能大胆地进行优化（例如放在只读区，寄存器优化，消除冗余写操作）。\n\n\n\n👉 总结一句：const 被创造出来是为了解决 “定义真正的常量 + 限制不必要的修改 + 提升类型安全与优化空间”。\n总结：const在定义常量方面比#define好，因为能够进行类型检查，const能区分函数&#x2F;对象是否会修改数据，增强了代码的可读性、可维护性，能够提高编译器的优化机会。\nconst常见的使用场景定义常量const修饰变量：限定变量为不可修改。\nconst double PI = 3.14159;  \n\n\n场景：替代 #define，用于数学常量、配置参数等。\n意义：\n类型安全（编译器能检查类型）\n有作用域，不会全局污染\n不可修改，避免误操作\n\n\n\n指针修饰：区分只读数据 vs 固定地址const int* p1;   // 不能改 *p1----常量指针int* const p2;   // 不能改 p2-----指针常量const int* const p3; // 两者都不能改\n\n\n场景：\nconst int* → 指向只读数据（保护数据）\nint* const → 固定指针（保证地址不变）\n\n\n意义：更精确地表达“修改权限”。\n\n注意：左定值右定向\nconst和函数：函数参数：只读引用void print(const std::string&amp; s) &#123;    std::cout &lt;&lt; s &lt;&lt; std::endl;&#125;\n\n\n场景：函数只需要读取数据，不会修改它（打印、计算哈希等）。\n意义：\n避免拷贝，提高效率\n明确告诉调用者“不会修改”\n调用者更放心传对象\n\n\n\nconst int&amp; fun(int&amp; a); //修饰返回值--------返回值是一个const修饰的变量\n\nconst和类：①const修饰成员变量，在某个对象的声明周期内是常量，但是对于整个类而言是可以改变的。因为类可以创建多个对象，不同的对象其const成员变量的值是不同的。\n切记，不能在类内初始化const成员变量，因为类的对象没创建前，编译器并不知道const成员变量是什么，因此const数据成员只能在初始化列表中初始化。\nclass A &#123;    const int id;   // 必须在构造函数初始化public:    A(int i) : id(i) &#123;&#125;&#125;;\n\n②const修饰成员函数，主要目的是防止成员函数修改成员变量的值，即该成员函数并不能修改成员变量。\nint&amp; fun(int&amp; a) const&#123;&#125; //const成员函数----函数不会修改成员变量\n\n\n\nconst 对象：const Person p(&quot;Alice&quot;);  p.getName();   // ✅p.setName(&quot;Bob&quot;); // ❌\n\n\n场景：当你只需要读取对象，不希望修改它。\n意义：\n强制接口使用只读模式\n提高代码的健壮性\n\n\n\n总结：const修饰是用来表达  只读 的。能修饰变量、指针、类的成员函数、函数的返回值等等。能够明确表达“不变性”\n总结：static的意义是，为了解决变量周期和同名函数或者变量的冲突问题\nconst的意义是，定义能够进行类型检查常量，c区分函数&#x2F;对象是否会修改数据，增强了代码的可读性、可维护性，能够提高编译器的优化机会。\n使用方面要从修饰的不同类型来分析。都是 变量、指针、函数、以及在类中的使用。\n","categories":["C++"],"tags":["C++"]},{"title":"hexo如何添加图片","url":"/2025/07/07/hexo%E5%A6%82%E4%BD%95%E6%B7%BB%E5%8A%A0%E5%9B%BE%E7%89%87/","content":"\n\n\n\n\n参考Kathy’s Blog 在hexo博客中插入图片的方法 | Kathy’s Blog\n如果图片保存在本地方法一：全局资源文件夹即，将所有文章的资源统一用一个全局资源文件夹管理。此方法的优点是比较简便，并且当多篇文章需要引用同一资源时，也比较方便。缺点是当文章很多时，各个文章的图片都在同一文件夹，不便管理。具体方法：在hexo文件夹下的source目录下，新建一个文件夹叫images(名字随意)，将要插入的图片放在该文件夹中。md文档内，使用![图片](图片链接地址 &quot;图片title&quot;)的格式，圆括号内的链接地址写(&#x2F;images&#x2F;name.jpeg)。这里的 &#x2F; 指的是根目录，对于hexo，资源文件的根目录就是source。例如，在md文档中写：![图片](/images/20.jpeg &quot;甘雨&quot;)同时将“20.jpeg”这个图片文件放在hexo文件夹&#x2F;source&#x2F;images下。\n—这个我没有使用\n方法二：文章资源文件夹即，对于每篇文章，使用一个文件夹管理资源。此方法的优点是，当文章很多时，便于结构化管理。缺点是，比方法一麻烦一点。具体方法：2.1 修改hexo文件夹中的_config.yml文件，如下：\npost_asset_folder: truemarked:  prependRoot: true  postAsset: true\n\n2.2 在终端cd到hexo文件夹，hexo new [layout] &lt;title&gt; 命令创建一篇新文章，此时会在hexo文件夹的source目录下，自动创建一个文件夹和.md文件。注：这句命令中的layout可暂时不写，使用默认的。title就是你的新文章的名字。如果文章名中有空格，务必将整个文章名用双引号引起来。如果文章名中没有空格，可以加双引号，也可以不加。例如，执行hexo new &quot;hexo如何添加图片&quot;，如下：\n\n会在source&#x2F;_post文件夹下生成一个”hexo如何添加图片.md”文件。同时还生成了一个同名的资源文件夹。\n2.3 我们可以将所有与该文章有关的资源（包括图片）放在这个关联文件夹中2.4 通过相对路径来引用图片资源。例如，将“1.jpeg”这个图片资源放在该文件夹中，并在.md文件中像这样引用图片：![图片](1.jpeg)，这个方法在资源较多时方便管理。\n如下图所示写\n\n注意：要注意斜杠的方向是&#x2F; 不是\\\n另附Typora编辑器中不显示图片的解决方案：安装下面的插件，可以使Typora等Markdown编辑器预览以及Hexo发布预览时，均能正常显示图片。npm install hexo-asset-img --save这样，如果你使用Typora编辑markdown文档，在typora内也可以显示图片了。\n","categories":["hexo"],"tags":["hexo"]},{"title":"std::greater()和std::less()在排序和建堆的应用以及自定义比较函数的规则","url":"/2025/07/28/std-greater-%E5%92%8Cstd-less-%E5%9C%A8%E6%8E%92%E5%BA%8F%E5%92%8C%E5%BB%BA%E5%A0%86%E7%9A%84%E5%BA%94%E7%94%A8%E4%BB%A5%E5%8F%8A%E8%87%AA%E5%AE%9A%E4%B9%89%E6%AF%94%E8%BE%83%E5%87%BD%E6%95%B0%E7%9A%84%E8%A7%84%E5%88%99/","content":"\n\n\n\n解释比较规则：strict weak orderingstd::greater()、std::less()、自定义比较函数，这些都其实是用作比较的，要遵从c++制定的比较规则。\n\n需要满足三种特性要求，否则使用中会报错：\n\n反自反性：false\ntrue的互斥性：true则false（但不要求false则怎么样）\n传递性：true＋true则true\n\nless和greater其实是什么两个函数的头文件是functional\n比如less\ntemplate &lt;class T&gt; struct less &#123;  bool operator() (const T&amp; x, const T&amp; y) const &#123;return x&lt;y;&#125;  typedef T first_argument_type;  typedef T second_argument_type;  typedef bool result_type;&#125;;\n\n可以看到关键就是bool operator()和return x&lt;y;\nbool operator()：要的就是这个返回值bool，决定比较是否要交换。这个结果用在排序和建堆中就表示是否要交换。return x&lt;y;：可以看到其实就是使用&lt;之类的操作符重载，这就是怎么排序的规则。PS：但这产生了限制，基本的元素int之类的，自然可以直接比较；但复杂类型如自定义一个类，里面有多个数据，我们就还得定义重载操作符比较，要不然编译器不知道该比较什么。\nbool返回值和比较操作符规则bool comp(a, b)意思是：返回的值指示作为第一个参数传递的元素是否被视为在其定义的特定严格弱排序中位于第二个参数之前。\n\n返回true：表示ab(a在b前）\n返回false：表示ba（a在b&#96;后）\n\n\n并不是想当然的位置交换comp(a, b)虽然会交换a和b，但你不能想当然地认为位置就该怎么样，到底数组中谁会是a，谁会是b，这要看调用的算法的。\n比如，[a &lt; b]  [6 &lt; 1] : 0，其实是算法调用时a是6，b是1，而非看到数组中原来的顺序就想当然的a是1，b是6。\n知识基础参考我的priority_queue博客这里简略再复述一些助于理解的关键信息。\n什么是优先级队列呢？\n其实就是一个披着队列外衣的堆，因为优先级队列对外接口只是从队头取元素，从队尾添加元素，再无其他取元素的方式，看起来就是一个队列。\n优先级队列内部元素是自动依照元素的权值排列。\n所以大家经常说的大顶堆（堆头是最大元素），小顶堆（堆头是最小元素），如果懒得自己实现的话，就直接用priority_queue（优先级队列）就可以了，底层实现都是一样的，从小到大排就是小顶堆，从大到小排就是大顶堆。\npriority_queue 容器适配器模拟的也是队列这种存储结构，即使用此容器适配器存储元素只能“从一端进（称为队尾），从另一端出（称为队头）”，且每次只能访问 priority_queue 中位于队头的元素。\n但是，priority_queue 容器适配器中元素的存和取，遵循的并不是 “First in,First out”（先入先出）原则，而是“*First in，Largest out*”原则。直白的翻译，指的就是先进队列的元素并不一定先出队列，而是优先级最大的元素最先出队列。（Largest out是指权重最大）\n通过以上的内容，我们可以用priority_queue来理解下面的内容。\n.bwfblhvyorpo{zoom:75%;}\n\n结论排序和建堆的效果排序：less变成升序（从左到右遍历下标时，数组元素是从小到大）greater变成降序（从左到右遍历下标时，数组元素是从大到小）\n建堆：less变成大顶堆（从上层到下层，堆元素是从大到小，同层之间随便）greater变成小顶堆（从上层到下层，堆元素是从小到大，同层之间随便）\n默认情况下：建堆的时候，默认是大根堆（堆头是最大元素），第三个参数用greater会变成小根堆；\n排序的时候，默认是从小到大，但是第三个参数用greater会变成从大到小\n可以看到默认情况下都是用less，但是看起来是“反转”的。这其实是两种操作的本质逻辑不同导致的\n解释结论我觉得下面解释的还是有点不好理解。以下是我个人的理解。从模拟过程和bool返回值来分析。\n我们在排序一个数组{a,b,c,d}的时候，如果是自己去实现排序（升序）的功能，大致的思路是，从头到尾每次遍历两个元素，如果a&gt;b，less返回false不满足less函数的x&lt;y。不满足升序要求，需要交换两个数的位置，使其要满足x&lt;y。所以是从小到大，升序。\n对于 std::sort 默认使用的升序排序，它会判断 less(x, y) 是否为 true，即 x &lt; y。如果返回 false，说明当前两个元素顺序不对，就会交换，从而实现升序排列。\n如果是priority_queue，priority_queue不是算法，是容器适配器，是优先级队列。**它的“优先级”是由 Compare 来定义的。**它需要在编译期确定比较器类型，并实例化一个对象在内部反复调用，它初始化的时候就要确定Compare是什么。因为priority_queue&lt;T,Container,Compare&gt;。Compare去决定它的优先级设置方法。\n想象一下在priority_queue（大顶堆）插入一个新元素a，从队尾push，priority_queue会更具Compare（less）制定的排序规则判断优先级。如果是a&lt;top，那less返回true，就不用交换两个数的位置。所以是大顶堆\n比如你用 less&lt;int&gt;，即 x &lt; y，那么在比较时，如果 less(a, top) &#x3D;&#x3D; true，说明 a 比 top 小，优先级低，就不需要上浮 a；\n如果 less(top, a) &#x3D;&#x3D; true，说明 a 优先级高（大顶堆），需要上浮。\n排序（std::sort）默认行为：std::less&lt;T&gt; → 升序\nstd::vector&lt;int&gt; v = &#123;3, 1, 4, 2&#125;;std::sort(v.begin(), v.end(), std::less&lt;int&gt;()); // 默认就是升序// 结果：1, 2, 3, 4\n\n\n比较逻辑：std::less 比较 a &lt; b，如果 true，则 a 应该排在 b 前面。\n效果：较小的元素在前，整体是升序。\n\n使用 std::greater&lt;T&gt; → 降序\nstd::sort(v.begin(), v.end(), std::greater&lt;int&gt;());// 结果：4, 3, 2, 1\n\n\n比较逻辑：std::greater 比较 a &gt; b，如果 true，则 a 应该排在 b 前面。\n效果：较大的元素在前，整体是降序。\n\n结论：在排序中，std::less → 升序，std::greater → 降序，符合直觉。\n建堆（std::priority_queue 或堆算法）默认行为：std::less&lt;T&gt; → 大顶堆\nstd::priority_queue&lt;int&gt; pq; // 默认是 std::less&lt;int&gt;，大顶堆pq.push(3); pq.push(1); pq.push(4);// 弹出的顺序是 4, 3, 1\n\n\n堆的性质：父节点 &gt;&#x3D; 子节点（堆顶是最大值）。\n比较逻辑：std::less 比较 a &lt; b，如果 true，则 b 优先级更高（会被放到堆顶）。\n为什么看起来是“反转”的？因为 std::priority_queue 的设计是“优先级高的先弹出”，而默认情况下它用 std::less 来决定谁“优先级更高”。\n默认 std::less 表示“更小的值优先级更低”，因此更大的值优先级更高，会放在堆顶。\n如果 a &lt; b 为 true，说明 b 比 a 大，所以 b 应该排在更前面（堆顶）。\n\n\n\n\n\n使用 std::greater&lt;T&gt; → 小顶堆\nstd::priority_queue&lt;int, std::vector&lt;int&gt;, std::greater&lt;int&gt;&gt; pq; // 小顶堆pq.push(3); pq.push(1); pq.push(4);// 弹出的顺序是 1, 3, 4\n\n\n堆的性质：父节点 &lt;&#x3D; 子节点（堆顶是最小值）。\n比较逻辑：std::greater 比较 a &gt; b，如果 true，则 b 优先级更高（会被放到堆顶）。\n如果 a &gt; b 为 true，说明 b 比 a 小，所以 b 应该排在更前面（堆顶）。\n\n\n\n结论：在建堆中，std::less → 大顶堆，std::greater → 小顶堆，看起来和排序是“反转”的。\n自定义符合两个条件：\n​\tbool：返回值bool​\treturn x&lt;y;：重载&lt;之类的操作符，并且要决定比较什么元素。​\tPS：建议还要常引用，保险，禁止发生修改要比较的元素可能。\n数组函数：使用时不加括号，加了报错。写成 bool cmp(const T&amp;, const T&amp;) 是因为 sort 要传入一个 函数指针。类的对象（仿函数）：注意，排序时的类必须使用类的对象才对，直接使用类报错。重载 () 是因为 sort 接受“可调用对象”，仿函数对象本质上是重载了括号运算符的类对象**。不能传入类名，而是类的实例：类名是类型，不能调用 operator()，而类对象才是“可调用的”。**\n#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;// 重写排序函数bool cmpfunc(const int &amp;a, const int &amp;b)&#123;    return a &lt; b;    // &lt; 升序; &gt; 降序&#125;// 模仿less、greater构建类struct cmpClass&#123;    bool operator()(const int &amp;i, const int &amp;j)    &#123;        return (i &lt; j);    &#125;&#125;cmpClassObject;\t\t// 注意，排序时的类必须使用类的对象才对，使用类报错。int main()&#123;\t// 使用函数    vector&lt;int&gt; v1 = &#123;2, 3, 1, 6, 2, 5, 4&#125;;    // 使用时不加括号，加了报错    sort(v1.begin(), v1.end(), cmpfunc);    for (int i = 0; i &lt; v1.size(); i++)    &#123;        cout &lt;&lt; v1[i] &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;    // 1 2 2 3 4 5 6        // 使用类的对象    vector&lt;int&gt; v2 = &#123;2, 3, 1, 6, 2, 5, 4&#125;;    sort(v2.begin(), v2.end(), cmpClassObject);    for (int i = 0; i &lt; v2.size(); i++)    &#123;        cout &lt;&lt; v2[i] &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;    // 1 2 2 3 4 5 6    return 0;\n\n\n\n优先级队列priority_queue&lt;T, Container, Compare&gt;这里 Compare 是一个仿函数类型，用于控制“谁优先”。\n比较对象 必须是 () 重载形式（即仿函数），因为 STL 库底层会调用 comp(a, b)。\n为什么 priority_queue 的比较器不能写成函数？因为它需要在编译期确定比较器类型，并实例化一个对象在内部反复调用：\npriority_queue&lt;T, vector&lt;T&gt;, cmpClass&gt; q;\n\n\n\n\n定义类时同时定义操作符重载函数：操作符重载函数，必须是具体的**操作符&lt;**之类的，写()报错——一个自定义类 重载函数&lt;在类内\n自定义类，自定义比较函数：操作符重载函数，必须是具体的**操作符&lt;**之类的，写()报错—————一个自定义类  重载函数&lt;在类外\n自定义类，自定义包含比较函数的结构体：操作符重载函数，必须是写()———————————–一个自定义类，一个比较函数的结构体（）\n\n#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;/******** 定义类时同时定义操作符重载函数 ********/struct Node1&#123;    // 要比较的元素    int x;    // 构造函数    Node1(int x) &#123; this-&gt;x = x; &#125;    // 操作符重载函数，必须是具体的操作符&lt;之类的，写()报错    bool operator&lt;(const Node1 &amp;b) const    &#123;        // 实现less中需要的&lt;,大顶堆        return x &lt; b.x;    &#125;&#125;;/******** 自定义类，自定义比较函数 ********/struct Node2&#123;    // 要比较的元素    int x;    // 构造函数    Node2(int x) &#123; this-&gt;x = x; &#125;&#125;;// 操作符重载函数，必须是具体的操作符&lt;之类的，写()报错bool operator&lt;(const Node2 &amp;a, const Node2 &amp;b)&#123;    // less,大顶堆    return a.x &lt; b.x;&#125;/******** 自定义类，自定义包含比较函数的结构体 ********/struct Node3&#123;    // 要比较的元素    int x;    // 构造函数    Node3(int x) &#123; this-&gt;x = x; &#125;&#125;;struct cmpClass&#123;    // 操作符重载函数，必须是写()    bool operator()(const Node3 &amp;a, const Node3 &amp;b)    &#123;        // less,大顶堆        return a.x &lt; b.x;    &#125;&#125;;int main()&#123;    /******** 初始化优先级队列的对象p ********/    // Node1类型，默认使用vector，小顶堆，同 priority_queue&lt;Node1, vector&lt;Node1&gt;, less&lt;Node1&gt; &gt; p;    priority_queue&lt;Node1&gt; p;    // 乱序入队p.emplace(1);p.emplace(3);p.emplace(2);// 弹出队首while (!p.empty())&#123;    cout &lt;&lt; p.top().x &lt;&lt; &quot; &quot;;    p.pop();&#125;cout &lt;&lt; endl;// 3 2 1/******** 初始化优先级队列的对象q ********/// 同 priority_queue&lt;Node2&gt; q;priority_queue&lt;Node2, vector&lt;Node2&gt;, less&lt;Node2&gt;&gt; q;// 乱序入队q.emplace(1);q.emplace(3);q.emplace(2);// 弹出队首while (!q.empty())&#123;    cout &lt;&lt; q.top().x &lt;&lt; &quot; &quot;;    q.pop();&#125;cout &lt;&lt; endl;// 3 2 1/******** 初始化优先级队列的对象r ********/priority_queue&lt;Node3, vector&lt;Node3&gt;, cmpClass&gt; r;// 乱序入队r.emplace(1);r.emplace(3);r.emplace(2);// 弹出队首while (!r.empty())&#123;    cout &lt;&lt; r.top().x &lt;&lt; &quot; &quot;;    r.pop();&#125;cout &lt;&lt; endl;// 3 2 1return 0;\n\n\n参考：C++：std::greater()、std::less()、自定义比较函数的规则-CSDN博客\n","categories":["C++"],"tags":["C++","排序","堆","优先队列","priority_queue","比较函数"]},{"title":"堆(heap)结构","url":"/2025/07/28/%E5%A0%86%E7%BB%93%E6%9E%84/","content":"\n\n","categories":["数据结构"],"tags":["堆","数据结构","完全二叉树"]},{"title":"安装win11系统","url":"/2025/07/24/%E5%AE%89%E8%A3%85win11%E7%B3%BB%E7%BB%9F/","content":"\n\n 安装win11系统。\n参考的视频【干货】WIN11系统安装重装教程、全程干货13分钟搞定，小白也能自己重装系统！超详细解说~_哔哩哔哩_bilibili\n1.在U盘下载好系统1.1格式化U盘1.2搜索win11 进入官方网站下载 Windows 11\n\n下载第二个\n\n会下载一个文件，下载好之后打开 按照提示下载到U盘\n2.搜索电脑启动BIOS的快捷键最快的办法是百度搜索或者直接问客服\n联想ThinkPad 是 F12 \n3.在打开电脑但是并没有开机的时候狂按快捷键，使用U盘启动4.点击下一步即可这里选择第二个\n\n分区可以先全部删除，进入系统之后再分区\n系统盘建议安装在ssd固态硬盘\n5.跳过联网shift + F10\n输入 oobe\\bypassnro.cmd\n回车之后电脑会重启\n之后可以进行分区和联网下载电脑驱动\n","categories":["安装win11"],"tags":["电脑刷机"]},{"title":"基于Opencv实现张正友标定法以及机器人手眼标定","url":"/2025/09/11/%E5%9F%BA%E4%BA%8EOpencv%E5%AE%9E%E7%8E%B0%E5%BC%A0%E6%AD%A3%E5%8F%8B%E6%A0%87%E5%AE%9A%E6%B3%95%E4%BB%A5%E5%8F%8A%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%89%8B%E7%9C%BC%E6%A0%87%E5%AE%9A/","content":"\n\nOpenCV简要介绍OpenCV（全称 Open Source Computer Vision Library）是由英特尔发起并由社区维护的跨平台、开源计算机视觉与机器学习库，核心目标是为开发者提供通用、高效的计算机视觉解决方案。\nOpenCV 核心特点\n开源与免费OpenCV 是一个开源项目，任何人都可以免费使用、修改和分发其代码。这意味着你可以根据需要对 OpenCV 进行定制化修改。\n跨平台支持OpenCV 支持多个操作系统平台，包括 Windows、Linux、macOS、Android 和 iOS。你可以在各种设备上使用 OpenCV，包括桌面、服务器以及移动设备。\n支持多种编程语言OpenCV 提供了多种编程语言的接口，支持 C++、Python、Java、JavaScript 和 MATLAB 等多种编程语言。因此，无论你是 C++ 开发者还是 Python 爱好者，都能轻松使用 OpenCV。\n强大的功能库OpenCV 提供了数百个优化的算法，涵盖了计算机视觉和图像处理的方方面面。以下是一些常见的应用：\n图像处理： 图像滤波、边缘检测、颜色空间转换、形态学操作、特征提取等。\n视频分析： 视频捕捉、运动分析、物体检测与追踪等。\n机器学习与人工智能： OpenCV 集成了深度学习框架，可以进行人脸识别、目标检测、图像分类等。\n计算机视觉： 图像匹配、物体识别、立体视觉、深度图计算等。\n\n\n高效的性能OpenCV 内置的许多算法都经过高度优化，支持硬件加速（如 Intel 的 TBB、OpenCL、CUDA 等技术），使得它在处理复杂计算时具备高性能，尤其在处理视频流和实时图像分析时非常高效。\n\nOpenCV中的相机标定经过之前的介绍，我们已经知道了在相机标定中需要求解的有内参、畸变系数、外参。\nopencv中标定核心函数计算内参和畸变系数：采用基于已知标定物的标定方法：张正友标定法\n\n原理：只需一块平面棋盘格，拍摄多张不同姿态的图片。\n步骤：\n检测棋盘格角点（得到二维像素点 (u,v）\n知道棋盘格格点的三维世界坐标 (X,Y,0)\n建立二维–三维对应关系，先线性估计相机参数\n再通过非线性优化（最小化重投影误差）精确求解内参、畸变系数、外参\n\n\n\n整个流程：1.设置标定板类型​\tcv::Size 注意在opencv中是角点数量而不是格子数量。例如： 12 * 9 标定板的角点数是 11 *  8\n2.从路径中加载图片​\t用 std::vector &lt; cv::Mat &gt;&amp;  images 保存图片。读取图片的方法为 cv::Mat img &#x3D; cv::imread(fullPath, cv::IMREAD_COLOR);\n3.检测角点 —-要先转灰度图。CV_EXPORTS_W bool findChessboardCorners( InputArray image, Size patternSize, OutputArray corners,\n                                     int flags = CALIB_CB_ADAPTIVE_THRESH + CALIB_CB_NORMALIZE_IMAGE );\n\n4.亚像素级角点优化（提高精度）case HPLPatternType::CHESSBOARD:\t\tfound = cv::findChessboardCorners(gray, patternSize, imagePoints,\t\t\tcv::CALIB_CB_ADAPTIVE_THRESH | cv::CALIB_CB_NORMALIZE_IMAGE);\t\tif (found) &#123;\t\t\tcv::cornerSubPix(gray, imagePoints, cv::Size(11, 11), cv::Size(-1, -1),\t\t\t\tcv::TermCriteria(cv::TermCriteria::EPS + cv::TermCriteria::MAX_ITER, 30, 0.001));\t\t\tstd::cout &lt;&lt; imagePoints.size() &lt;&lt; &quot;  &quot;;\t\t&#125;\t\tbreak;\n\n\n前提：只有当角点检测成功（found为true）时，才进行后续优化。\n\ncv::cornerSubPix功能：将初步检测到的像素级角点优化到亚像素级别（精度可达 0.1 像素以内），这是提高后续标定（如相机内参、手眼矩阵）精度的关键步骤。\n\n参数说明：\n\ngray：输入灰度图（用于计算梯度信息，辅助亚像素定位）。\n\nimagePoints：输入输出参数，传入初步检测的角点，输出优化后的亚像素角点。\n\ncv::Size(11, 11)：搜索窗口大小（11×11 像素），表示在该范围内寻找更精确的角点位置。\n\ncv::Size(-1, -1)：死区大小（此处设为负，表示无死区，即使用整个搜索窗口计算）。\n\n终止条件\nTermCriteria\n\n\nEPS + MAX_ITER：满足 “精度阈值” 或 “最大迭代次数” 任一条件即停止优化。\n30：最大迭代次数（最多迭代 30 次）。\n0.001：精度阈值（当角点位置变化小于 0.001 像素时，停止优化）。\n\n\n\n\n\n5.根据标定板的参数生成理想的物理点​\t核心是为了让生成的三维物体点坐标顺序与图像中检测到的角点顺序保持一致，确保后续标定过程中 “三维物体点” 与 “二维图像点” 能正确匹配。\nint rows = boardSize.height;int cols = boardSize.width;case HPLPatternType::CHESSBOARD:\t\t// 生成 (j, i) 格子对应的三维坐标 (单位：size)\t\tfor (size_t i = 0; i &lt; rows; ++i) &#123;\t\t\tfor (int j = 0; j &lt; cols; ++j) &#123;\t\t\t\tm_objPts.emplace_back(j * spacing, i * spacing, 0);\t\t\t&#125;\t\t&#125;\t\tbreak;\n\n​\t双重循环即可，需要注意的是：\n​\t\t1.棋盘格的坐标系统定义\n​\t\t标定板（棋盘格）的三维坐标系通常这样定义：原点（0,0,0）设在棋盘格左上角的第一个内角点；x 轴沿水平方向（从左到右，对应 “列方向”）；y 轴沿垂直方向（从上到下，对应 “行方向”）；z 轴垂直于标定板平面（所有点 z&#x3D;0，因为棋盘格是平面）。\n​\t\t2.循环顺序与点的排列顺序\n​\t\t代码中：外层循环i：遍历棋盘格的行数（rows = boardSize.height），对应 y 轴方向（从上到下）；\n​\t\t\t\t内层循环j：遍历棋盘格的列数（cols = boardSize.width），对应 x 轴方向（从左到右）。\n​\t\t\t\t生成的三维坐标是 (j * spacing, i * spacing, 0)，即：\n​\t\t\t\t对于第i行、第j列的内角点，x 坐标由列索引j决定（水平方向），y 坐标由行索引i决定（垂直方向）。\n​\t\t\t\t这样生成的m_objPts中，点的顺序是 “按行排列”：先排完第 0 行的所有列（j 从 0 到 cols-1），再排第 1 行的所有列，以此类推。\n​\t\t3. 与图像角点检测顺序匹配\n​\t\t关键原因是：图像中检测到的角点顺序也是 “按行排列” 的。在之前的findChessboardCorners函数中，检测到的imagePoints（二维图像角点）顺序是从左到右、从上到下（先扫完一行，再扫下一行），与上述三维物体点的排列顺序完全一致。\n​\t\t如果循环顺序反过来（外层 j、内层 i），会导致三维物体点 “按列排列”，与二维图像点的顺序不匹配，后续标定（如calibrateCamera）时会因 “点对应错误” 导致结果失效。\n​\t\t总结\n​\t\t循环的内外层顺序（先 i 后 j）是为了保证：三维物体点的排列顺序 ↔ 二维图像角点的检测顺序 严格一致。​\t\t这种一致性是相机标定、位姿估计的核心前提 —— 只有每个二维图像点都能准确对应到唯一的三维物体点，才能通过几何关系求解相机内参或位姿矩阵。\n6.调用函数主要使用的函数： \n/** @overload */CV_EXPORTS_W double calibrateCamera( InputArrayOfArrays objectPoints,                                     InputArrayOfArrays imagePoints, Size imageSize,                                     InputOutputArray cameraMatrix, InputOutputArray distCoeffs,                                     OutputArrayOfArrays rvecs, OutputArrayOfArrays tvecs,                                     int flags = 0, TermCriteria criteria = TermCriteria(                                        TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON) );// 我的调用double rms = cv::calibrateCamera(m_objectPoints, m_imagePoints, m_imageSize,    cameraMatrix, distCoeffs, rvecs, tvecs, cv::CALIB_FIX_K3);\n\n主要功能是通过标定板图像的特征点，求解相机的内参矩阵（Camera Matrix）和畸变系数（Distortion Coefficients），并评估标定精度。\n\n参数说明：\nm_objectPoints&#x2F;m_imagePoints：三维物体点和二维图像点的对应关系（核心输入）。\nm_imageSize：图像尺寸（宽 x 高），用于辅助计算。\ncameraMatrix&#x2F;distCoeffs：输出参数，存储求解得到的内参矩阵和畸变系数。\nrvecs&#x2F;tvecs：输出参数，存储每幅图像对应的旋转 &#x2F; 平移向量。\ncv::CALIB_FIX_K3：标定标志，含义是 “固定畸变系数中的 k3 为 0”（简化模型，适用于畸变较小的场景）。\n\n\n返回值rms：重投影误差的均方根（Root Mean Square），是评估标定精度的核心指标（值越小越好，通常希望小于 1 像素）。\n\n7.实验和误差计算\n可以求总的RMS 和每张图片的RMS\n\n计算外参：根据之前的介绍我们知道，外参就是描述相机在世界坐标系下的位姿，在机器人手眼标定中，其实就是描述相机在机器人基座标系下的位姿。\n而在机器人手眼标定中，又分为两种：眼在手上、眼在手外。\n\n眼在手上：相机直接安装在机器人末端执行器上，与机械臂同步运动。此时，相机“看到”的场景会随着机械臂的移动而变化。\n\n眼在手外：相机安装在机器人之外的一个固定地方。不会随着机器人运动而运动。\n\n安装方式不同带来的影响：手眼标定的核心是建立 “相机坐标系” 与 “机器人基坐标系” 的转换关系，但相机与机器人的安装方式会改变位姿数据的物理意义：\n\nEyeInHand（眼在手上）：相机固定在机器人末端（夹爪）上，随机器人一起运动。此时，标定板固定在外部（如桌面），相机拍摄的是固定的标定板。机器人提供的位姿数据（robotPoseList）是 “夹爪坐标系 → 机器人基坐标系” 的转换（R_gripper2base, t_gripper2base），这正是手眼标定需要的位姿关系（因为相机与夹爪刚性连接，两者相对位姿不变）。\nEyeToHand（眼在手外）：相机固定在外部（如支架上），不随机器人运动。此时，标定板固定在机器人末端（夹爪）上，随机器人一起运动。机器人提供的位姿数据（robotPoseList）仍是 “夹爪坐标系 → 机器人基坐标系” 的转换，但手眼标定需要的是 “机器人基坐标系 → 夹爪坐标系” 的转换（因为标定板随夹爪运动，相机观察的是运动的标定板）。\n\n手眼标定算法（如cv::calibrateHandEye）要求输入的位姿数据必须满足 “运动端与固定端的对应关系”：\n\n对于EyeInHand：运动端是 “夹爪 + 相机”，固定端是 “标定板”，需要 “夹爪→基” 的位姿；\n对于EyeToHand：运动端是 “夹爪 + 标定板”，固定端是 “相机”，需要 “基→夹爪” 的位姿（与机器人原始数据方向相反）。\n\n因此，EyeToHand需要对原始位姿做逆变换，将 “夹爪→基” 转换为 “基→夹爪”：\n旋转矩阵R的处理（转置）\n旋转矩阵的 “逆变换” 等价于 “转置”（因为旋转矩阵是正交矩阵，其逆矩阵 &#x3D; 转置矩阵）：\n\n原始旋转矩阵R_gripper2base：表示 “夹爪→基” 的旋转；\n逆变换后Rt = R.t()：表示 “基→夹爪” 的旋转（即R_base2gripper）。\n\n平移向量t的处理（反向变换）\n平移向量的逆变换需要结合旋转矩阵：\n\n原始平移向量t_gripper2base：表示 “夹爪原点在基坐标系中的坐标”；\n逆变换后t_inv = -Rt * t：表示 “基原点在夹爪坐标系中的坐标”（即t_base2gripper）。\n\n推导逻辑：若P_base = R * P_gripper + t（夹爪坐标→基坐标），则逆变换为P_gripper = R.t() * (P_base - t) = R.t() * P_base - R.t() * t，因此 “基→夹爪” 的平移向量为-R.t() * t。\n总结\n两种安装方式下对R和t的处理不同，本质是为了统一位姿数据的方向，确保输入到手眼标定算法中的位姿关系符合 “运动端→固定端” 的逻辑：\n\nEyeInHand：直接使用 “夹爪→基” 的位姿（与运动方向一致）；\nEyeToHand：通过逆变换将 “夹爪→基” 转为 “基→夹爪” 的位姿（修正方向以匹配运动逻辑）。\n\n整个流程：1.设置标定板类型2.加载图片3.使用之前计算出来的内参和畸变系数进行图片矫正\t// 利用标定好的内参，对输入的相片进行图像校正（去除畸变，还原真实世界视角）\tstd::cout &lt;&lt; &quot;UndistoredImage:&quot; &lt;&lt; std::endl;\tfor (int i = 0; i &lt; m_vMatImages.size(); i++)\t&#123;\t\tcv::Mat Matundistorted;\t\tundistort(m_vMatImages[i], Matundistorted, m_cameraMatrix, m_distCoeffs);\t\tm_vMatundistortedImg.push_back(Matundistorted);\t&#125;&#125;\n\n4.对矫正之后的图像检测角点5.生成理想的物理点6.处理机器人末端数据—求解gripper2base（运动到固定）注意：这里要根据安装方式的不同去不同地处理  参考上面的“ 安装方式不同带来的影响”\n// 1. 提取平移向量cv::Mat tvec = (cv::Mat_&lt;double&gt;(3, 1) &lt;&lt; pose.x(), pose.y(), pose.z());// 2. 提取欧拉角并转为 Mat  单位：角度cv::Mat euler = (cv::Mat_&lt;double&gt;(1, 3) &lt;&lt; pose.r1(), pose.r2(), pose.r3());//std::cout &lt;&lt; &quot;Pose &quot; &lt;&lt; i &lt;&lt; &quot;: &quot;//\t&lt;&lt; &quot;T=(&quot; &lt;&lt; tvec &lt;&lt; &quot;),, &quot;//\t&lt;&lt; &quot;euler=(&quot; &lt;&lt; euler &lt;&lt; &quot;),,&quot; &lt;&lt; std::endl;// 3. 计算旋转矩阵cv::Mat rmat = eulerAngleToRotateMatrix(euler);//std::cout &lt;&lt; &quot;R=(&quot; &lt;&lt; rmat &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;cv::Mat R, Rt, t, t_inv;switch (m_InstallType)&#123;case HPLEyeHandType::EyeInHand:\t// 眼在手上\tm_Vec_t_gripper2base.push_back(tvec);\tm_Vec_R_gripper2base.push_back(rmat);\tbreak;case HPLEyeHandType::EyeToHand:\t// 眼在手外--对旋转矩阵进行转置；-对平移矩阵进行一次变换\tR = rmat;\t// 对旋转矩阵进行转置\tRt = R.t();\tm_Vec_R_gripper2base.push_back(Rt);\t// 读取末端平移矩阵\tt = tvec;\tt_inv = -Rt * t;\t//std::cout &lt;&lt; &quot;-Rt*t:&quot; &lt;&lt; t_inv &lt;&lt; std::endl;\tm_Vec_t_gripper2base.push_back(t_inv);\tbreak;\n\n\n\n7.使用pnp算法求解target2cam—–核心作用是计算 “标定板（目标）相对于相机的位姿”（即标定板在相机坐标系下的旋转和平移关系）CV_EXPORTS_W bool solvePnP( InputArray objectPoints, InputArray imagePoints,                            InputArray cameraMatrix, InputArray distCoeffs,                            OutputArray rvec, OutputArray tvec,                            bool useExtrinsicGuess = false, int flags = SOLVEPNP_ITERATIVE );\n\nPnP算法\nPnP（Perspective-n-Point，透视 n 点问题）是计算机视觉中的核心算法，核心逻辑是：已知相机内参的前提下，通过 “n 个 3D 世界坐标已知的点” 和它们对应的 “2D 图像像素坐标”，求解 3D 目标（如标定板）相对于相机的位姿（旋转矩阵 R + 平移向量 t）。\n简单理解：通过图像中 “已知 3D 位置的点”，反推 “相机看目标的角度（R）” 和 “相机到目标的距离（t）”。\nPnP 算法的核心好处\n\n精度高支持迭代法（如代码中 SOLVEPNP_ITERATIVE）、鲁棒法（如 solvePnPRansac 抗外点），能有效抑制噪声和少量误匹配点的干扰，适合高精度位姿测量（如机器人视觉引导）。\n依赖条件少仅需两个核心输入：① 相机内参（标定后可复用）；② 至少 4 个 3D-2D 点对（n≥4，实际用标定板的多个角点进一步提升精度），无需额外设备。\n通用性强广泛应用于相机标定、手眼标定、AR&#x2F;VR（虚拟物体对齐现实）、目标跟踪、机器人抓取等场景，是视觉位姿估计的 “基础工具”。\n工程化友好OpenCV 等库已优化实现，接口简洁、运行效率高，支持实时或批量处理（如代码中循环处理多帧图像的位姿）。\n\n8.调用函数cv::calibrateHandEye是 OpenCV 中用于机器人手眼标定的核心函数。它通过多组位姿数据，求解出相机与夹爪的相对位姿，为机器人视觉引导（如抓取、定位）提供坐标映射的关键参数。\n手眼标定的本质是建立 “相机” 与 “机器人末端” 的刚性转换关系。当机器人带动相机（或相机固定、机器人末端带动靶标）运动时，通过记录多组位姿，该函数可计算出：相机坐标系 → 机器人末端（夹爪）坐标系的旋转矩阵和平移向量，从而实现 “相机识别的目标坐标” 到 “机器人可执行的坐标” 的转换。\nCV_EXPORTS_W void calibrateHandEye( InputArrayOfArrays R_gripper2base, InputArrayOfArrays t_gripper2base,                                    InputArrayOfArrays R_target2cam, InputArrayOfArrays t_target2cam,                                    OutputArray R_cam2gripper, OutputArray t_cam2gripper,                                    HandEyeCalibrationMethod method=CALIB_HAND_EYE_TSAI );\n\n\n\n只需要将前面得到的gripper2base和target2cam参数放到函数中去调用即可。\nCV_EXPORTS_W void calibrateHandEye(    InputArrayOfArrays R_gripper2base,  // 输入：夹爪到机器人基坐标系的旋转矩阵集合    InputArrayOfArrays t_gripper2base,  // 输入：夹爪到机器人基坐标系的平移向量集合    InputArrayOfArrays R_target2cam,    // 输入：靶标到相机坐标系的旋转矩阵集合    InputArrayOfArrays t_target2cam,    // 输入：靶标到相机坐标系的平移向量集合    OutputArray R_cam2gripper,          // 输出：相机到夹爪坐标系的旋转矩阵    OutputArray t_cam2gripper,          // 输出：相机到夹爪坐标系的平移向量    HandEyeCalibrationMethod method = CALIB_HAND_EYE_TSAI  // 标定方法（默认TSAI）);\n\n\n\n标定方法介绍：\n\n\n方法枚举值\n核心原理\n优点\n缺点\n适用场景\n\n\n\nCALIB_HAND_EYE_TSAI\n分离求解旋转与平移：先通过矩阵运算求旋转，再用最小二乘法求平移\n计算效率高，精度均衡，抗中等噪声能力较好，工程实用性强\n平移误差依赖旋转结果，易累积；对严重噪声或位姿分布不均敏感\n常规工业场景（如装配、搬运），中等精度需求，对实时性有一定要求\n\n\nCALIB_HAND_EYE_PARK\n基于四元数表示旋转，构建线性方程组同时求解旋转与平移的近似解\n数学模型简单，计算速度快，适合快速验证\n对噪声极敏感，精度较低；位姿数据不足时易漂移\n快速原型验证，低精度场景（如误差允许＞1mm），对速度要求高的场景\n\n\nCALIB_HAND_EYE_HORAUD\n用对偶四元数统一表示旋转与平移，通过特征值分解同时优化两者\n理论精度高，抗噪声能力较强，避免误差累积\n计算复杂度高（特征值分解耗时），对上位姿数量和分布要求高（需≥10 组）\n高精度场景（如精密装配、微电子封装），离线标定且位姿数据充足\n\n\nCALIB_HAND_EYE_ANDREFF\n基于非线性优化（如 Levenberg-Marquardt），构建联合误差函数迭代求解最优解\n精度最高，对噪声和位姿分布不均容忍度好，无近似简化\n计算量最大（迭代耗时），需大量高质量位姿数据才能稳定收敛\n超高精度任务（如光学检测、精密定位），离线标定且对精度要求严苛的场景\n\n\n主要采用TSAI\n误差分析1.会进行多种标定方法的计算，如果有很大的误差，不同方法算出来的值会相差很多。\n2.重投影误差分析\n3.实际走点\n4.通过量化 “靶标在机器人基坐标系下的位姿一致性” 来评估标定结果的可靠性。\n核心逻辑是：若手眼标定准确，靶标在机器人基坐标系下的位姿应保持稳定（变化极小），因此通过计算多组位姿的 “平移偏差” 和 “旋转偏差” 来衡量标定精度。\n误差计算的核心原理\n手眼标定的本质是建立 “相机→夹爪” 的变换关系（矩阵X）。在标定过程中，无论相机是 “眼在手上”（随夹爪运动）还是 “眼在手外”（固定），靶标相对机器人基坐标系的位姿理论上应保持不变（因靶标要么固定在外部，要么随夹爪刚性连接）。\nstd::string HPLCaliAlgoOpenCV::HandEyeCalibrationError()&#123;\tstd::string error;\tif (m_Vec_R_gripper2base.size() != m_Vec_t_gripper2base.size() ||\t\tm_Vec_R_target2cam.size() != m_Vec_t_target2cam.size() ||\t\tm_Vec_R_gripper2base.size() != m_Vec_R_target2cam.size())&#123;\t\tstd::cerr &lt;&lt; &quot;Hand-eye calibration input size mismatch!&quot; &lt;&lt; std::endl;\t\treturn &quot;Hand-eye calibration input size mismatch!&quot;;\t&#125;\t// 构造手眼变换矩阵 X = [R | t]\tcv::Mat X = cv::Mat::eye(4, 4, CV_64F);\tm_HandEyeResult_RVec.copyTo(X(cv::Rect(0, 0, 3, 3)));\tm_HandEyeResult_TVec.copyTo(X(cv::Rect(3, 0, 1, 3)));\tstd::vector&lt;cv::Mat&gt; vec_target_in_base;\tstd::vector&lt;cv::Mat&gt; vec_R;\tfor (size_t i = 0; i &lt; m_Vec_R_gripper2base.size(); ++i)\t&#123;\t\t// T_e^b\t\tcv::Mat T_e_b = cv::Mat::eye(4, 4, CV_64F);\t\tm_Vec_R_gripper2base[i].copyTo(T_e_b(cv::Rect(0, 0, 3, 3)));\t\tm_Vec_t_gripper2base[i].copyTo(T_e_b(cv::Rect(3, 0, 1, 3)));\t\t// T_t^c\t\tcv::Mat T_t_c = cv::Mat::eye(4, 4, CV_64F);\t\tm_Vec_R_target2cam[i].copyTo(T_t_c(cv::Rect(0, 0, 3, 3)));\t\tm_Vec_t_target2cam[i].copyTo(T_t_c(cv::Rect(3, 0, 1, 3)));\t\t// 计算 T_t^b = T_e^b * X * T_t^c\t\tcv::Mat T_t_b = T_e_b * X * T_t_c;\t\tvec_target_in_base.push_back(T_t_b);\t\tvec_R.push_back(T_t_b(cv::Rect(0, 0, 3, 3)).clone());\t&#125;\t// 计算平移误差（平均值 + RMS）\tcv::Mat mean_t = cv::Mat::zeros(3, 1, CV_64F);\tfor (const auto&amp; T : vec_target_in_base)\t\tmean_t += T(cv::Rect(3, 0, 1, 3));\tmean_t /= (double)vec_target_in_base.size();\tdouble rms = 0.0;\tfor (const auto&amp; T : vec_target_in_base)\t&#123;\t\tcv::Mat diff = T(cv::Rect(3, 0, 1, 3)) - mean_t;\t\trms += cv::norm(diff);\t&#125;\trms /= vec_target_in_base.size();\t// --- 旋转误差 ---\tcv::Mat rvec_mean = cv::Mat::zeros(3, 1, CV_64F);\tfor (const auto&amp; R : vec_R)\t&#123;\t\tcv::Mat rvec;\t\tcv::Rodrigues(R, rvec);\t\trvec_mean += rvec;\t&#125;\trvec_mean /= static_cast&lt;double&gt;(vec_R.size());\tcv::Mat R_mean;\tcv::Rodrigues(rvec_mean, R_mean);\tdouble total_rot_error_deg = 0.0;\tfor (const auto&amp; R : vec_R)\t&#123;\t\tcv::Mat R_diff = R_mean.t() * R;\t\tdouble angle_rad = std::acos(std::min(1.0, std::max(-1.0, (cv::trace(R_diff)[0] - 1.0) / 2.0)));\t\tdouble angle_deg = angle_rad * 180.0 / CV_PI;\t\ttotal_rot_error_deg += angle_deg;\t&#125;\tdouble avg_rot_error_deg = total_rot_error_deg / vec_R.size();\tstd::ostringstream oss;\toss &lt;&lt; &quot;RMS translation error = &quot; &lt;&lt; rms &lt;&lt; &quot; mm\\n&quot;\t\t&lt;&lt; &quot;Average rotation error = &quot; &lt;&lt; avg_rot_error_deg &lt;&lt; &quot; deg&quot;;\t\terror = oss.str();\treturn error;&#125;\n\n","categories":["相机标定"],"tags":["opencv","相机标定","机器人"]},{"title":"无法打开“mscoree.lib”错误","url":"/2025/07/24/%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80%E2%80%9Cmscoree-lib%E2%80%9D%E9%94%99%E8%AF%AF/","content":"\n\n需要在下载VS的时候加插件\n下载了的也可以直接打开VS Install修复\n\n需要添加\n\n同时，我还安装了.NET Framework 4.8 SDK\n在单个组件里面。\n","categories":["报错"],"tags":["C++","VS","C#","hsl库"]},{"title":"替换css文件之后没有重新加载样式","url":"/2025/07/31/%E6%9B%BF%E6%8D%A2css%E6%96%87%E4%BB%B6%E4%B9%8B%E5%90%8E%E6%B2%A1%E6%9C%89%E9%87%8D%E6%96%B0%E5%8A%A0%E8%BD%BD%E6%A0%B7%E5%BC%8F/","content":"\n\n使用的是 Qt 的 qrc 资源系统（比如 &quot;:/qss/style.qss&quot;），那么只是替换文件是不够的，你需要重新编译资源文件。\n修改 .qrc 文件后重新运行 rcc 或者 重新构建项目。\n","categories":["报错"],"tags":["C++","Qt","CSS"]},{"title":"机器人模型描述格式URDF","url":"/2025/08/02/%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%A8%A1%E5%9E%8B%E6%8F%8F%E8%BF%B0%E6%A0%BC%E5%BC%8FURDF/","content":"\n\n参考：\nROS机器人建模与仿真（一）——URDF模型的建立和改进-CSDN博客\n(68 封私信 &#x2F; 20 条消息) 开源URDF文件数据集 - 知乎\n什么是URDF格式URDF，全称是Unified Robot Description Format，统一机器人描述格式。URDF文件格式用于描述机器人最早是由机器人操作系统（ROS）的开发人员在2009年引入，是一种描述机器人的运动学、动力学和几何形状的通用格式文件，独立于软件程序，方便不同的软件工具以及开发人员共享机器人数据模型。URDF文件重要的一点是其可读性，因为它是XML类型的文本文件。URDF文件中可以描述机器人的运动学结构、动力学参数、视觉外观（通过引用其它文件）和几何碰撞边界（通过引用其它文件）。\nURDF 是 ROS 中机器人模型的描述格式，包含对机器人刚体外观、物体属性、关节类型等方面的描述。URDF（Unified Robot Description Format，统一机器人描述格式）是 ROS 中一个非常重要的机器人模型描述格式，ROS 同时也提供 URDF 文件的 C++ 解析器，可以解析 URDF 文件中使用 XML 格式描述的机器人模型。\n1 URDF 文件中常用的标签1.1 &lt; link &gt; 标签&lt; link &gt;标签用于描述机器人某个刚体部分的外观和物理属性，包括尺寸（size）、颜色（color）、形状（shape）、惯性矩阵（inertial matrix）、碰撞参数（collision properties）等。\n&lt;link name = &quot;&lt;link name&gt;&quot;&gt; &lt;inertial&gt; ------------&lt;/inertial&gt;\t&lt;visual&gt;-------------&lt;/visual&gt;\t&lt;collision&gt;--------- &lt;/collision&gt;&lt;/link&gt;\n\n&lt; visual &gt;用于描述机器人link部分的外观参数，&lt; inertial &gt;标签用于描述link的惯性参数，而&lt; collision &gt;标签用于描述link的碰撞属性。一般来说，检测碰撞的link区域大于外观可视的区域，也就是说有一定的安全空间\n1.2 &lt; joint &gt;标签&lt; joint &gt;标签用于描述机器人关节的运动学和动力学属性，包括关节运动的位置和速度限制。机器人关节的主要作用是连接两个刚体link，这两个link分别称为 parent link 和 child link。\n&lt;joint name=&quot;&lt;name of the joint&gt;&quot;&gt;\t&lt;parent link = &quot;parent_link&quot; /&gt;\t&lt;child  link = &quot;child_link&quot; /&gt;\t&lt;calibration ---- /&gt;\t&lt;dynamics damping ---- /&gt;\t&lt;limit effort ---- /&gt;&lt;/joint&gt;\n\n其中必须指定joint的parent link 和 child link，还可以设置关节的其他属性。&lt; calibration &gt; : 关节的参考位置，用来校准关节的绝对位置&lt; dynamics &gt; : 用于描述关节的物理属性，例如阻尼值、物理经摩擦力等，经常在运动学仿真中用到。&lt; limit &gt; : 用于描述运动的一些极限值，包括关节运动的上下限位置、速度限制、力矩限制等。&lt; mimic &gt; : 用于描述该关节与已有关节的关系。&lt; safety_controller &gt; : 用于描述安全控制器的参数。\n1.3 &lt; robot &gt; 标签&lt; robot &gt; 是完整机器人模型的最顶层标签，&lt; link &gt; 和 &lt; joint &gt; 标签都必须包含在&lt; robot &gt;标签内。一个完整的机器人模型由一系列的&lt; link &gt; 和 &lt; joint &gt; 组成。\n&lt; robot &gt;标签语法如下：\n&lt;robot name = &quot;&lt;name of the robot&gt;&quot;&gt;\t&lt;link&gt; -------&lt;/link&gt;\t&lt;link&gt; -------&lt;/link&gt;\t&lt;joint&gt;-------&lt;/joint&gt;\t&lt;joint&gt;-------&lt;/joint&gt;&lt;/robot&gt;\n\n1.4 &lt; gazebo &gt;标签&lt; gazebo &gt;标签用于描述机器人模型在Gazebo中仿真所需要的参数，包括机器人材料的属性、Gzaebo 插件等。该标签不是机器人模型必须的部分，只有在 Gazebo 仿真时才需加入。\n&lt; gazebo &gt;标签的基本语法如下:\n&lt;gazebo reference = &quot;link_1&quot;&gt;\t&lt;material&gt; Gazebo/Black&lt;/material&gt;&lt;/gazebo&gt;\n\n2 创建一个机器人URDF 模型2.1 准备工作（创建功能包和文件夹）创建test_mrobot_description功能包，依赖urdf，xacro在其下创建4个文件夹urdf、meshes、launch和config\nurdf : 用于存放机器人模型的 URDF 或 xacro 文件meshes : 用于存放URDF中引用的模型渲染文件launch : 用于存放相关启动文件config : 用于存放日 rviz 的配置文件\n(经过测试，URDF文件不能加入中文字符，写程序时注意将中文注释去掉！！！)\n3.URDF文件解析URDF文件重要的一点是其可读性，因为它是XML类型的文本文件。可以通过tinyXML解析，OCC也有解析的能力，有自带 XmlDrivers &#x2F; XmlMDF 模块，也可用 xerces-c 等库，不直接支持 URDF，需要自行读取 XML + 构建模型。所以可以集成起来。\n","categories":["机器人"],"tags":["机器人","URDF"]},{"title":"机器人运动学","url":"/2025/08/02/%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%BF%90%E5%8A%A8%E5%AD%A6/","content":"\n\n主要学习资料、参考资料\n1.机器人学导论(John J. Craig 贠超 王伟)\n2.机器人动力学与控制（霍伟编著）\n3.机器人学基础（1）-位置运动学-正运动学、逆运动学方程建立及其求解-CSDN博客\n4.机器人学：（3）机器人运动学-CSDN博客\n一、正运动学正运动学可以理解为，已知机械臂各个关节θ，求机械臂手末端的位置和姿态。\n核心是坐标系变换链：T = A1(θ1) * A2(θ2) * ... * An(θn)其中每个Ai是关节的变换矩阵\n二、逆运动学逆运动学可以理解为，已知机械臂末端的位置和姿态(T)，求机械臂各个关节θ\n三、MDH和DH方法的区别1955年，Denavit和Hartenberg提出一种基于齐次变换矩阵的低副机构建模方法，该方法为每个连杆固连了一个坐标系，用 4x4 的变换矩阵描述相邻连杆的位姿关系，通过齐次变换建立运动学模型，被称为Denavit-Hartenberg参数模型，简称D-H模型，这种建模方法被称为D-H法。\n目前，D-H建模方法主要有两种：标准 D-H 方法（Standard D-H method）和改进的 D-H 方法（Modified D-H method）。这两种方法主要区别在于坐标系建立的位置不同。\nMDH（修正Denavit–Hartenberg）和DH（标准Denavit–Hartenberg）方法都是用于建立串联机器人机械臂的运动学模型的建模方法，它们的目标相同：建立各连杆之间的坐标变换关系。\n\n\n\n联系（相同点）\n\n\n项目\n内容\n\n\n\n目的\n建立各关节坐标系之间的齐次变换，用于正逆运动学求解\n\n\n参数数量\n都使用4个参数描述两坐标系之间的位置与方向关系（θ,d,a,α）\n\n\n应用场景\n都广泛应用于串联型机械臂的建模\n\n\n变换结构\n本质都是通过旋转和平移组合实现坐标系变换\n\n\n参数的定义：杆件长度 a、杆件扭角 α、关节距离 d、关节转角 θ\n区别（关键差异）\n\n\n比较项\n标准 DH 方法\n修正 MDH 方法\n\n\n\n坐标系设置\n旋转轴Z与下一个坐标系的Z轴共线\nZ轴仍为关节轴，但采用不同坐标系放置规则\n\n\n坐标系放置方式\nz 轴定义关节轴，x 轴沿两 z 轴的共同垂线方向\nx 轴平行于前一坐标系的 z 轴，定义略不同\n\n\n齐次变换矩阵\nAiDH&#x3D;Rz(θ)Tz(d)Tx(a)Rx(α)\nAiMDH&#x3D;Tx(a)Rx(α)Tz(d)Rz(θ)\n\n\n适用结构\n通用，但对某些结构建模较复杂（如冗余或特殊结构）\n更灵活，适合于复杂结构和软件自动建模\n\n\n工业应用\n比如《机器人学：建模与控制》中大量使用DH法\nROS、某些仿真软件更偏好MDH法\n\n\n总结：标准 DH 法适合教材与理论分析，MDH 更适合实际工程建模和复杂结构；两者变换本质一致，仅坐标系定义与变换顺序不同。\n参数的定义：杆件长度 a、杆件扭角 α、关节距离 d、关节转角 θ\nDH和MDH的四个参数的具体定义不一样（主要是对杆件长度和杆件扭角的定义不一样），齐次变换矩阵不一样（顺序不一样）。\nDH参数与MDH 参数间，除 i &#x3D; 0 和i &#x3D; n 的某些特殊情况外，一般地有以下关系：D H 参数｛a i ，αi ，di ，θi｝ &#x3D; 修改的 D H 参数｛a i₊₁ ，αi₊₁ ，di ，θi｝\nDH的变换矩阵是    d θ a α\nMDH的变换矩阵是  a α d θ\n.ttyujcbsuopr{zoom:50%;}\n\n.ltncptfstdkc{zoom:50%;}\n","categories":["机器人"],"tags":["C++","Qt","机器人运动学","研究生期间"]},{"title":"第一篇博客","url":"/2025/07/02/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/","content":"\n​\tDaiYueJuan.github.io这是我的博客网站！\n​\t这是我第一篇博客。记录一下为什么会有想写博客的念头。\n​\t在我研究生的学习过程之中，在我遇到问题的时候我会上网搜索。在CSDN，Google，百度，stackoverflow，还有GPT等等平台直到解决我遇到的问题。搜索的过程并不难，但是如果间隔很久再遇见同样的问题，我可能还是要整个平台再找一遍，这样效率很低。而人的记忆力也不是无限的，所以我决定写博客。\n为什么选择hexo，hexo是部署在github上面的，不会像CSDN一样突然收费或者文章不可见，并且是免费的。\n\n​\t记录我在学习的笔记以及遇到的问题和解决方法。学习永无止境。\n"},{"title":"相机标定原理介绍","url":"/2025/09/09/%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D/","content":"\n\n相机标定的原理简介相机标定（Camera Calibration）的原理主要是通过一系列已知几何信息的标定板图像，求解相机的内参、外参以及畸变参数，从而建立三维空间点与图像二维像素点之间的准确数学模型。\n相机是如何成像的相机标定的理论基础是 针孔成像模型。（小孔成像）\n.wpffhhkejuux{zoom: 80%;}\n\n空间点 (X,Y,Z)（在相机坐标系下）经过投影关系映射到图像平面上的像素点 (u,v)。基本关系为：\n\n其中，K为内参矩阵；[R|t]为外参矩阵。s：尺度因子（归一化用）。\n[u,v,1]是齐次坐标 的一种表达方式。\n\n前两个分量 (u,v)(u, v)(u,v) 还是原来的像素坐标；\n最后一个分量 “1” 是一个 尺度因子，保证齐次坐标与普通坐标的对应关系：\n(u,v)↔(ku,kv,k), k≠0\n它们表示的是同一个点。\n\n什么是内参？内参描述的是 相机自身的成像特性，与相机的物理结构（镜头、像素尺寸等）有关。\n所以内参矩阵一般标定一次之后，如果没有碰撞是不会改变的。\n\n其中：\n\nfx,fy：焦距在图像 x、y 方向的像素单位表示\nfx&#x3D;f&#x2F;dx，fy&#x3D;f&#x2F;dy\nf：实际焦距（mm）\ndx,dy：单个像素在物理尺寸上的宽高（mm&#x2F;pixel）\n\n\n(u0,v0)：主点（principal point），理想情况下是光轴穿过图像的点（通常接近图像中心）\nγ：像素坐标轴之间的夹角系数，若像素是矩形则 γ&#x3D;0\n\n总结：在标定时通常是固定的一组参数，求出后可用于去畸变、图像矫正。相机“内在的透视投影规律” → 相机的固有属性。\n什么是外参？外参描述的是 相机坐标系与世界坐标系之间的关系。\n它由旋转矩阵 R 和平移向量 t 组成：\n\n其中：\n\nR：3×3的旋转矩阵，描述世界坐标系相对于相机坐标系的旋转关系\nt：3×1 的平移向量，描述世界坐标系原点在相机坐标系下的位置\n\n总结：每张标定板图像对应一组外参，用来描述标定板在相机前的位置和方向。相机“放在空间里的位置和方向” → 相机和世界坐标系的关系。\n成像原理详细介绍\n相机成像系统中，共包含四个坐标系：世界坐标系、相机坐标系、图像坐标系、像素坐标系。\n\n世界坐标系：由用户定义的三维世界坐标系，描述物体和相机在真实世界中的位置，原点可以任意选择。\n相机坐标系：以相机的光心为坐标原点，x轴和y轴平行于图像坐标系的x轴和y轴，z轴为相机的光轴。\n图像坐标系：与成像平面重合，以成像平面的中心（光轴与成像平面的交点）为坐标原点，x 轴和 y轴分别平行于成像平面的两条边。\n像素坐标系：与成像平面重合，以成像平面的左上角顶点为原点，x 轴和 y 轴分别平行于图像坐标系的x轴和y轴。\n\n世界坐标系下的Pw点 ，在相机坐标系中的坐标为Pc，投影到图像坐标系后坐标为P(x,y) ，对应在像素坐标系中的坐标为P(u,v)。\n\n\n相机畸变与畸变矫正相机拍摄的图片还存在一定的畸变，畸变包括桶形畸变和枕形畸变。畸变模型包括径向畸变和切向畸变。\n径向畸变：可以这样来理解，对于透镜而言，以透镜的中心作为原点，往外是透镜的半径的方向，当光线越靠近中心的位置，畸变越小，沿着半径方向远离中心的时候，畸变越大。典型的径向畸变有桶形畸变和枕形畸变。如下图所示。\n切向畸变：切向畸变可以这样理解，当透镜与成像平面不行时，就产生了畸变，类似于透视变换。\n\n\n注：\n一般来说k1,k2,k3,k4,k5 一般只会用到k1 和k2\n如下图我做的梅卡曼德相机内参标定结果\n\n畸变系数 [k1, k2, p1, p2, k3]\n相机标定的方法相机标定的目标是去求解内参、畸变系数、外参。\n常见的相机标定方法基于已知标定物的标定（最常用）利用一个几何结构已知的标定板（如棋盘格、圆点阵列），获取多组图像来求解相机参数。\na) 张正友标定法（Zhang’s Method）\n原理：只需一块平面棋盘格，拍摄多张不同姿态的图片。\n步骤：\n检测棋盘格角点（得到二维像素点 (u,v）\n知道棋盘格格点的三维世界坐标 (X,Y,0)\n建立二维–三维对应关系，先线性估计相机参数\n再通过非线性优化（最小化重投影误差）精确求解内参、畸变系数、外参\n\n\n优点：方便、精度高、只需要平面棋盘格\n缺点：对角点检测精度敏感\n\nb) 基于圆点阵列&#x2F;对称圆标定板\n用规则排列的圆形点，提取圆心作为特征点\n优点：鲁棒性好，圆心定位比棋盘格角点更稳定，适合光照复杂环境\n缺点：特征检测比棋盘格稍复杂\n\nc) 三维标定物体（立体标定块）\n使用三维立体标定块（如立方体、3D 标定架）\n优点：几何约束更强，精度高\n缺点：制作复杂、成本高\n\n\n(2) 自标定（Self-Calibration）\n不使用标定板，只依赖图像序列中的几何约束（如相机运动信息、场景几何特征）。\n方法：通过基础矩阵 F、单应性矩阵 H 等约束求相机内参。\n优点：无需标定板，适合野外场景或移动设备（SLAM、SfM）。\n缺点：精度低于基于标定板的方法，收敛依赖运动轨迹。\n\n\n(3) 基于运动的标定（Hand-Eye Calibration, Robot Calibration）\n相机和机器人协作，通过已知的机器人运动信息（末端位姿）和相机观测到的特征点，联合求解外参或手眼关系。\n常用于：眼在手上 &#x2F; 眼在手外 机器人视觉系统。\n\n各方法对比\n\n\n方法\n特点\n优点\n缺点\n\n\n\n棋盘格（张正友法）\n平面标定板\n简单易用，精度高\n角点检测受噪声影响\n\n\n圆点阵列\n圆心特征\n鲁棒性好\n检测算法稍复杂\n\n\n立体标定块\n三维标定物\n高精度\n制作成本高\n\n\n自标定\n无需标定物\n灵活，适合SLAM\n精度低，收敛不稳定\n\n\n机器人手眼标定\n相机+机器人\n工业应用广泛\n依赖机器人精度\n\n\n总结：相机标定的目的是为了得到  世界坐标系下的三维点与成像平面上二维像素点之间的关系。\n相机标定的原理是，通过一系列的已知标定板的图像信息去求解相机内参外参和畸变系数。\n相机的内参和畸变系数在出厂之后如果不被撞动内部元器件，是不会改变的。\n下一篇文章将继续介绍 使用Opencv开源库实现 张正友标定法和机器人手眼标定。\n","categories":["相机标定"],"tags":["相机标定原理"]},{"title":"虚拟机Ubuntu和宿主机之间的复制粘贴功能","url":"/2025/08/04/%E8%99%9A%E6%8B%9F%E6%9C%BAUbuntu%E5%92%8C%E5%AE%BF%E4%B8%BB%E6%9C%BA%E4%B9%8B%E9%97%B4%E7%9A%84%E5%A4%8D%E5%88%B6%E7%B2%98%E8%B4%B4%E5%8A%9F%E8%83%BD/","content":"\n\n参考：\n关于VMware Tools 不再随旧版客户机操作系统的 VMware Workstation 一起提供。-CSDN博客\n(68 封私信 &#x2F; 20 条消息) VMware虚拟机和主机间复制粘贴共享剪贴板 - 知乎\n前言:看视频别人安装Ubuntu之后,能自动安装VMware Tools，实现VMware虚拟机和主机间复制粘贴共享剪贴板，但是我的不行，点击安装VMware Tools，提示\nVMware Tools 不再随旧版客户机操作系统的 VMware Workstation 一起提供。\n请从 https://packages-prod.broadcom.com/tools/frozen/linux/linux.iso 下载，并参阅 Install VMware Tools in VMware products 以了解安装步骤。\n客户机操作系统没有任何 VMware Tools 映像。\n解决：尝试参考关于VMware Tools 不再随旧版客户机操作系统的 VMware Workstation 一起提供。-CSDN博客的第一种解决方法\n\n方法一进入命令行，输入命令\nsudo apt-get install open-vm-tools-desktop\n一路输入yes下去，直到安装完成\n\n但是根本不行，说找不到这个。\n于是尝试第二种方法\n\n方法二1.复制上述连接https://packages-prod.broadcom.com/tools/frozen/linux/linux.iso\n2.打开火狐浏览器粘贴连接进入浏览器，下载弹出的文件\n\n发现连不上网，于是解决联网的问题，咨询ai老师\n联网问题解决：1.VMware 常见网络模式\nNAT：通过主机共享网络。\n桥接：直接使用主机网络。\n仅主机：只和主机通信。\n\n✔ 推荐使用：NAT 模式。\n\n设置路径：虚拟机 → 设置 → 网络适配器 → 选择 NAT 或 桥接。\n\n2、检查 Ubuntu 网络是否启用进入 Ubuntu，执行以下命令查看网络状态：\nip a\n\n或使用：\nnmcli device status\n\n查看 eth0 或 enp0s3 等网卡是否是 connected 状态。\n3.测试联网是否成功ping -c 4 www.baidu.comping -c 4 8.8.8.8\n\n\n能 ping 通域名 → 网络和 DNS 正常。\n能 ping 通 IP 但不能 ping 域名 → DNS 有问题。\n都 ping 不通 → 网卡&#x2F;网络配置错误。\n\n然后就可以联网了。\n一开始想复制网址过去打开，发现还不能复制，只好手打。\n下载之后，按照步骤操作。\n下载完成后打开文件所在目录可以看到下载了如下文件\n\n在文件所在目录空白处右键选择Open in Terminal进入命令行\n\n挂载设备进入命令行，使用如下命令，创建挂载目录\nsudo mkdir /media/iso_mount\n\n使用如下命令，将iso挂载到指定目录\nsudo mount -o loop ./linux.iso /media/iso_mount\n\n可以看到桌面出现如下文件，即挂载成功\n\n\n这个时候开始不顺利了\n\n\n**注意：**输入密码是不会显示的，输入完之后，直接回车即可。\n这里第一次输入错误因为 （mkdir/media/iso_mount 被当作一个整体命令）\n在ai老师的指导下，先删除了之前的文件目录，重新创建挂载就可以了，不是很清楚为什么。\n# 1. 删除残留文件/目录（如果存在）sudo rm -rf /media/iso_mount# 2. 正确创建目录（使用 mkdir）sudo mkdir /media/iso_mount# 3. 挂载ISO文件（确保当前在 ~/下载 目录）sudo mount -o loop ./linux.iso /media/iso_mount\n\n\n\n安装VmwareTool进入该目录，将压缩包复制到桌面\n\n\n我发现我的桌面已经有了\n\n在桌面进入命令行，输入如下命令，然后按下Tab补全，解压压缩包\ntar -zvxf ./V\n\n\n解压完成我们进入解压后的文件夹\n\n内容如下\n\n右键进入命令行，输入如下指令\nsudo ./[vmware]-install.pl\n\n进入如下界面\n\n输入yes，然后一路回车\n出现这个就是安装好了\n\n\n这个时候我发现还是不能复制粘贴，其实应该要重启之后再尝试，应该就可以了。\n重启你的系统sudo reboot\n\n\n\n下面是安装open-vm-tools和open-vm-tools-desktop\nsudo apt-get install open-vm-toolssudo apt-get install open-vm-tools-desktop\n\n\n\n安装过程中遇见如下问题\n\n这个提示是关于 PAM（Pluggable Authentication Modules）配置文件 /etc/pam.d/vmtoolsd 的冲突处理。在安装 open-vm-tools 时，安装程序发现该文件在系统中已经存在（可能是之前安装 VMware Tools 时创建的），并且与软件包维护者提供的版本不同。因此，它询问您如何处理这个冲突。\n### 选项解释：\n- Y 或 I：安装软件包维护者提供的版本（覆盖当前文件）\n- N 或 O：保留您当前使用的版本（不覆盖）\n- D：显示两个版本的区别（diff）\n- Z：将进程切换到后台（暂时不处理）\n问题核心\n\n冲突文件：/etc/pam.d/vmtoolsd (PAM 认证配置文件)\n冲突双方：\n您系统中已存在的版本（可能是之前安装留下的）\n软件包维护者提供的新版本\n\n\n\n\n- 开头行：当前系统中存在的配置（将被删除）\n+ 开头行：软件包提供的新配置（将替换旧配置）\n\n这个差异显示配置格式有重大变化，新版本使用了更标准的 PAM 配置方式。\n强烈建议选择\n✅ 输入 Y 然后按回车（使用软件包维护者提供的新版本）\n为什么选择 Y？\n\n兼容性保证：新版本是专门为当前软件（open-vm-tools 12.3.5）设计的\n安全性：旧配置可能包含已弃用的模块（如 pan_shells.so）\n功能完整性：确保 VMware Tools 认证系统正常工作\n避免后续问题：选择 N 可能导致服务启动失败\n\n安装后验证\n完成选择后执行：\n# 重启服务sudo systemctl restart vmtoolsd# 检查状态systemctl status vmtoolsd# 测试功能（安装后重启）sudo reboot\n\n\n\n至此，复制粘贴功能实现。\nUbuntu复制粘贴快捷键复制：Ctrl+Shift+C\n粘贴：Ctrl+Shift+V\n比Windows系统的多了个Shift。\nopen-vm-tools和open-vm-tools-desktop关系\nopen-vm-tools 和 open-vm-tools-desktop 都是 VMware的开源虚拟化工具，它们提供了一些增强功能和集成来改善虚拟机在 VMware 虚拟化环境中的性能和用户体验。\nopen-vm-tools-desktop 是 open-vm-tools 的扩展，专注于提供与桌面虚拟机相关的增强功能。安装open-vm-tools-desktop 将包括 open-vm-tools提供的所有功能。\n即只安装open-vm-tools-desktop也可以。但是只安装open-vm-tools可能还是不能共享剪贴板，某些 Linux 发行版和虚拟机环境需要额外的组件来实现这些功能，这时候就需要额外安装open-vm-tools-desktop了。\n\n","categories":["Ubuntu"],"tags":["虚拟机","Ubuntu","复制粘贴"]},{"title":"虚拟机安装Linux系统","url":"/2025/08/04/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85Linux%E7%B3%BB%E7%BB%9F/","content":"\n\n结果展示\n安装VMware虚拟机软件在微信公众号softgj里面找到VMware，建议安装版本比较新的。因为低版本VMware可能不能安装新版本的linux内核的系统。\n安装操作步骤一步一步来即可。\n密钥【MC60H-DWHD5-H80U9-6V85M-8280D】\n安装ubuntu22.04系统系统选择理由：参考常见Linux发行版本有哪些？ - C语言中文网\nLinux 的发行版本众多，下面给选择 Linux 发行版本犯愁的朋友一点建议：\n\n如果你需要的是一个服务器系统，而且已经厌烦了各种 Linux 的配置，只是想要一个比较稳定的服务器系统，那么建议你选择 CentOS 或 RHEL。\n如果你只是需要一个桌面系统，而且既不想使用盗版，又不想花大价钱购买商业软件，不想自己定制，也不想在系统上浪费太多时间，则可以选择 Ubuntu。\n如果你想深入摸索一下 Linux 各个方面的知识，而且还想非常灵活地定制自己的 Linux 系统，那就选择 Gentoo 吧，尽情享受 Gentoo 带来的自由快感。\n如果你对系统稳定性要求很高，则可以考虑 FreeBSD。\n如果你需要使用数据库高级服务和电子邮件网络应用，则可以选择 SuSE。\n\n以上纯属个人化建议，非官方指导意见。其实 Linux 的发行版本众多，但是系统的核心——内核却系出同门，所以只要学会使用其中一种，即可触类旁通。\n根据我在网上搜索，发现linux的教程以及大多数人下载的有两个发行版：CentOS、Ubuntu。CentOS（已被替代为 AlmaLinux&#x2F;Rocky）\n考虑到我对linux内核完全不熟悉，所以选择Ubuntu，因为他有桌面系统。等我上手熟悉之后再学习使用别的发行版。**因为命令行界面是 Linux 的精髓之一。善于使用命令行，可以大大提升效率。**所以，一开始可以依赖”图形界面”；但如果要想提升，必须让自己逐步适应”命令行界面”。\n选择22.04是因为现在最新的是24.04，但是我的教程里面是18.04，18.04官方支持已于 2023 年 5 月结束。折中选择了一个22.04（稳定，资源多）\n安装步骤：1.下载镜像文件在ubuntu官网找到之前的版本下载（其他下载）,注意这里下载的是桌面版不是服务器版，因为我是个人使用学习。\n\n2.具体安装步骤参考[VMware创建虚拟机，安装Linux系统——Ubuntu22.04版本_sysin 提取码-CSDN博客](https://blog.csdn.net/jacknbv/article/details/124640386?ops_request_misc=elastic_search_misc&amp;request_id=2297913f792d18bdb58604eff7bc251d&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~ElasticSearch~search_v2-14-124640386-null-null.142^v102^pc_search_result_base9&amp;utm_term=linux ubuntu22.04系统安装&amp;spm&#x3D;1018.2226.3001.4187)\n参考softgj安装linux操作系统内核ubuntu的教程\n其实两个都差不多，但是CSDN博客悠悠海风介绍的更加详细，我主要参考ta的。\n2.1创建虚拟机注意创建虚拟机我是选的第一个选项，而参考选择的第二个\n\n\n\n我设置的CPU和内存都是4\n\n2.2安装Ubuntu系统\n我确实没有出现下面的情况。\n我安装系统的时候，会出现BIOS配置，可能你们的不会出现，在这个界面中，利用方向键切换主菜单（Boot所在的那一栏）的选项，选择驱动程序–&gt;Hard Drive。\n\n\n注意：这里进去可能要很久 鼠标是一个⭕ 就是正在加载，要等一下。\n\n\n\n\n\n\n\n安装的时间可能需要二三十分钟。这样就安装完了。\n","categories":["软件安装"],"tags":["虚拟机","Linux内核","ubuntu"]},{"title":"解决 Typora 插入图片路径与 Hexo 不兼容","url":"/2025/09/11/%E8%A7%A3%E5%86%B3-Typora-%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84%E4%B8%8E-Hexo-%E4%B8%8D%E5%85%BC%E5%AE%B9/","content":"\n\n\n\n问题描述：每次在typaro 里面插入的图片格式都是这样的绝对路径\n\n而在hexo显示需要的是这样的格式\n\n第一个是绝对路径应该改为相对路径\n第二个是 &#x2F; 与 \\ 的不同\n解决方法：核心思路：让 Typora 自动将图片保存到 Hexo 文章的同名资源文件夹，并生成相对路径。\n1. 配置 Hexo 资源文件夹打开 Hexo 根目录的 _config.yml，添加以下配置：\npost_asset_folder: true  # 启用文章资源文件夹功能\n\n此后，使用 hexo new &quot;文章标题&quot; 创建文章时，会自动生成同名文件夹（如 相机标定原理介绍/）。\n2. 配置 Typora 自动保存图片打开 Typora → 偏好设置 → 图像，按以下步骤操作：\n\n插入图片时：选择 复制到指定路径，并输入路径：\n./$(filename)  # 表示当前文章的同名文件夹（与 Hexo 资源文件夹路径一致）\n\n\n若文章名为 相机标定原理介绍.md，图片会自动保存到 相机标定原理介绍/ 文件夹。\n关键：路径必须以 ./ 开头，表示当前文章所在目录。\n\n\n勾选：对本地位置的图片应用上述规则。\n\n链接格式：选择 相对路径（确保生成的路径不带盘符或绝对路径）。\n\n\n3. 验证效果\n插入图片时，Typora 会自动将图片复制到文章同名文件夹，并生成路径：\n![图片](相机标定原理介绍/1.png)  # 直接引用文件夹内的图片\n\n执行 hexo g &amp;&amp; hexo d 部署后，图片会被正确打包到 Hexo 的 public 目录。\n\n\n4. 注意事项\n必须通过 hexo new 命令创建文章，否则不会自动生成资源文件夹。\n若手动创建文章，需手动在 source/_posts/ 下创建同名文件夹，并在 Typora 中粘贴图片时选择 复制到当前文件夹。\n\n效果\n","categories":["hexo"],"tags":["hexo","解决问题","typora"]},{"title":"虚拟机克隆、快照、迁移、删除","url":"/2025/08/08/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%85%8B%E9%9A%86%E3%80%81%E5%BF%AB%E7%85%A7%E3%80%81%E8%BF%81%E7%A7%BB%E3%80%81%E5%88%A0%E9%99%A4/","content":"\n\n参考：\nVMware虚拟机快照、克隆、迁移的概述以及操作_哔哩哔哩_bilibili\n纯小白学习linux系统之—-VMware虚拟机克隆、快照、迁移、删除_wmware拷贝-CSDN博客\n安装虚拟机不只是为了学习和体验Linux内核的系统，还有虚拟机的非常多好处吸引我。\n1.快照1.1快照概念:记录了虚拟机在某个特定时间点的状态(照片备份、游戏存档 )\n1.2快照用途:可以在需要时轻松地恢复虚拟机到快照创建时的状态。\n可保存虚拟机某一时刻的完整状态（内存、磁盘、配置）可随时回退，如系统升级&#x2F;软件安装前创建快照，有问题可快速还原。\n详细：\n​\t**备份和恢复:**快速备份虚拟机状态的方法可以在数据丢失或损坏时快速恢复虚拟机到先前的状态。​\t测试和开发:在进行软件测试或开发时，可以先创建一个快照，然后进行更改。如果测试失败或发现错误，可以轻松地恢复虚拟机到快照状态，而不影响其他开发工作。​\t安全更新:在应用重要更新或配置更改之前，可以先创建一个快照，以便在更新失败时可以快速恢复到以前的状态，避免对生产环境造成影响。\n2.克隆2.1克隆概念:创建一个与源对象相似但完全独立的副本\n2.2克降用途:​\t快速部署:克降是快速创建相似配置的新对象的一种方法，因此在需要快速部署多个相似环境时非常有用，例如测试环境或开发环境。​\t测试和开发:在软件测试或开发过程中可以使用克降来创建一个与生产环境相似但独立的测试环境，以便进行安全的测试和开发工作。​\t灾难恢复:在灾难恢复方案中，克隆可以作为恢复备份数据的一种方式，通过创建虚拟机的克隆来快速恢复到先前的状态\n\n\n完整克隆：副本完全独立，性能高，占用存储空间大（适合生产环境）\n链接克隆：依赖父虚拟机，节省空间，但父机不可删除（适合临时测试）。\n\n这里我感觉还是完整克隆更好。\n3.迁移3.1迀移概念:将虚拟机从一个物理服务器或数据中心迁移到另一个物理服务器或数据中心的过程(迁移到新硬件、新位置或新环境。)\n冷迁移（关闭虚拟机）：将虚拟机从一台物理主机迁移到另一台，或存储位置迁移\n热迁移（不关闭虚拟机）：对操作要求较高，感兴趣的同学可以研究下。\n3.2迁移用途:​\t资源平衡:迁移可以帮助在物理服务器之间平衡负载，确保资源被有效利用。\n​\t维护和升级:当您需要对物理服务器进行维护或升级时，可以使用迁移将虚拟机转移到备用服务器上，而无需中断服务。\n​\t灾难恢复:在出现灾难情况时，迁移可以帮助您将虚拟机快速迁移到备用数据中心以确保业务连续性。\n3.3如何进行迁移 ?注意:迁移过去的虚拟机所在软件也就是vmware的版本一定要&gt;&#x3D;迁移前vmware的版本(vmware高版本兼容低版本，但是低版本缺失&#x2F;不匹配高版本的硬件版本、功能支持等)\n找到安装虚拟机操作系统时保存的文件夹，选择文件拷贝即可。\n","categories":["虚拟机"],"tags":["虚拟机","VMware","备份"]}]