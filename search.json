[{"title":"相机标定原理介绍","url":"/2025/09/09/相机标定原理介绍/","content":"\n<!--more-->\n\n# 相机标定的原理简介\n\n相机标定（Camera Calibration）的原理主要是通过一系列已知几何信息的标定板图像，求解相机的内参、外参以及畸变参数，从而建立三维空间点与图像二维像素点之间的准确数学模型。\n\n\n\n# 相机是如何成像的\n\n相机标定的理论基础是 **针孔成像模型**。（小孔成像）\n\n<img src=\"相机标定原理介绍/5.png\" style=\"zoom: 80%;\" />\n\n空间点 (X,Y,Z)（在相机坐标系下）经过投影关系映射到图像平面上的像素点 (u,v)。基本关系为：\n\n![图片](相机标定原理介绍/1.png)\n\n其中，K为内参矩阵；[R|t]为外参矩阵。s：尺度因子（归一化用）。\n\n[u,v,1]是齐次坐标 的一种表达方式。\n\n> 前两个分量 (u,v)(u, v)(u,v) 还是原来的像素坐标；\n>\n> 最后一个分量 “1” 是一个 **尺度因子**，保证齐次坐标与普通坐标的对应关系：\n>\n> (u,v)↔(ku,kv,k), k≠0\n>\n> 它们表示的是同一个点。\n\n## 什么是内参？\n\n内参描述的是 **相机自身的成像特性**，与相机的物理结构（镜头、像素尺寸等）有关。\n\n所以内参矩阵一般标定一次之后，如果没有碰撞是不会改变的。\n\n![图片](相机标定原理介绍/2.png)\n\n其中：\n\n- fx,fy：焦距在图像 x、y 方向的像素单位表示\n  - fx=f/dx，fy=f/dy\n  - f：实际焦距（mm）\n  - dx,dy：单个像素在物理尺寸上的宽高（mm/pixel）\n- (u0,v0)：主点（principal point），理想情况下是光轴穿过图像的点（通常接近图像中心）\n- γ：像素坐标轴之间的夹角系数，若像素是矩形则 γ=0\n\n**总结**：在标定时通常是固定的一组参数，求出后可用于去畸变、图像矫正。相机“内在的透视投影规律” → 相机的固有属性。\n\n## 什么是外参？\n\n外参描述的是 **相机坐标系与世界坐标系之间的关系**。\n\n它由旋转矩阵 R 和平移向量 t 组成：\n\n![图片](相机标定原理介绍/3.png)\n\n其中：\n\n- R：3×3的旋转矩阵，描述世界坐标系相对于相机坐标系的旋转关系\n- t：3×1 的平移向量，描述世界坐标系原点在相机坐标系下的位置\n\n**总结**：每张标定板图像对应一组外参，用来描述标定板在相机前的位置和方向。相机“放在空间里的位置和方向” → 相机和世界坐标系的关系。\n\n\n\n## 成像原理详细介绍\n\n![图片](相机标定原理介绍/4.png)\n\n**相机成像系统中，共包含四个坐标系：世界坐标系、相机坐标系、图像坐标系、像素坐标系。**\n\n- **世界坐标系**：由用户定义的三维世界坐标系，描述物体和相机在真实世界中的位置，原点可以任意选择。\n- **相机坐标系**：以相机的光心为坐标原点，x轴和y轴平行于图像坐标系的x轴和y轴，z轴为相机的光轴。\n- **图像坐标系**：与成像平面重合，以成像平面的中心（光轴与成像平面的交点）为坐标原点，x 轴和 y轴分别平行于成像平面的两条边。\n- **像素坐标系**：与成像平面重合，以成像平面的左上角顶点为原点，x 轴和 y 轴分别平行于图像坐标系的x轴和y轴。\n\n世界坐标系下的Pw点 ，在相机坐标系中的坐标为Pc，投影到图像坐标系后坐标为P(x,y) ，对应在像素坐标系中的坐标为P(u,v)。\n\n![图片](相机标定原理介绍/6.png)\n\n![图片](相机标定原理介绍/7.png)\n\n\n\n\n\n## 相机畸变与畸变矫正\n\n相机拍摄的图片还存在一定的畸变，畸变包括桶形畸变和枕形畸变。畸变模型包括**径向畸变**和**切向畸变**。\n\n\n\n### **径向畸变：**\n\n可以这样来理解，对于透镜而言，以透镜的中心作为原点，往外是透镜的半径的方向，**当光线越靠近中心的位置，畸变越小**，沿着半径方向远离中心的时候，畸变越大。典型的径向畸变有桶形畸变和枕形畸变。如下图所示。\n\n### **切向畸变：**\n\n切向畸变可以这样理解，当透镜与成像平面不行时，就产生了畸变，类似于透视变换。\n\n![图片](相机标定原理介绍/8.png)\n\n\n\n![图片](相机标定原理介绍/9.png)\n\n注：\n\n一般来说k1,k2,k3,k4,k5 一般只会用到k1 和k2\n\n如下图我做的梅卡曼德相机内参标定结果\n\n![图片](相机标定原理介绍/10.png)\n\n\n\n畸变系数 [k1, k2, p1, p2, k3]\n\n\n\n# 相机标定的方法\n\n**相机标定的目标是去求解内参、畸变系数、外参。**\n\n\n\n## 常见的相机标定方法\n\n### **基于已知标定物的标定**（最常用）\n\n利用一个几何结构已知的标定板（如棋盘格、圆点阵列），获取多组图像来求解相机参数。\n\n#### a) 张正友标定法（Zhang’s Method）\n\n- **原理**：只需一块平面棋盘格，拍摄多张不同姿态的图片。\n- **步骤**：\n  1. 检测棋盘格角点（得到二维像素点 (u,v）\n  2. 知道棋盘格格点的三维世界坐标 (X,Y,0)\n  3. 建立二维–三维对应关系，先线性估计相机参数\n  4. 再通过非线性优化（最小化重投影误差）精确求解内参、畸变系数、外参\n- **优点**：方便、精度高、只需要平面棋盘格\n- **缺点**：对角点检测精度敏感\n\n#### b) 基于圆点阵列/对称圆标定板\n\n- 用规则排列的圆形点，提取圆心作为特征点\n- **优点**：鲁棒性好，圆心定位比棋盘格角点更稳定，适合光照复杂环境\n- **缺点**：特征检测比棋盘格稍复杂\n\n#### c) 三维标定物体（立体标定块）\n\n- 使用三维立体标定块（如立方体、3D 标定架）\n- **优点**：几何约束更强，精度高\n- **缺点**：制作复杂、成本高\n\n------\n\n### (2) **自标定（Self-Calibration）**\n\n- 不使用标定板，只依赖图像序列中的几何约束（如相机运动信息、场景几何特征）。\n- **方法**：通过基础矩阵 F、单应性矩阵 H 等约束求相机内参。\n- **优点**：无需标定板，适合野外场景或移动设备（SLAM、SfM）。\n- **缺点**：精度低于基于标定板的方法，收敛依赖运动轨迹。\n\n------\n\n### (3) **基于运动的标定**（Hand-Eye Calibration, Robot Calibration）\n\n- 相机和机器人协作，通过已知的机器人运动信息（末端位姿）和相机观测到的特征点，联合求解外参或手眼关系。\n- 常用于：**眼在手上 / 眼在手外** 机器人视觉系统。\n\n## 各方法对比\n\n| 方法               | 特点        | 优点             | 缺点               |\n| ------------------ | ----------- | ---------------- | ------------------ |\n| 棋盘格（张正友法） | 平面标定板  | 简单易用，精度高 | 角点检测受噪声影响 |\n| 圆点阵列           | 圆心特征    | 鲁棒性好         | 检测算法稍复杂     |\n| 立体标定块         | 三维标定物  | 高精度           | 制作成本高         |\n| 自标定             | 无需标定物  | 灵活，适合SLAM   | 精度低，收敛不稳定 |\n| 机器人手眼标定     | 相机+机器人 | 工业应用广泛     | 依赖机器人精度     |\n\n\n\n# 总结：\n\n相机标定的目的是为了得到  世界坐标系下的三维点与成像平面上二维像素点之间的关系。\n\n相机标定的原理是，通过一系列的已知标定板的图像信息去求解相机内参外参和畸变系数。\n\n相机的内参和畸变系数在出厂之后如果不被撞动内部元器件，是不会改变的。\n\n下一篇文章将继续介绍 使用Opencv开源库实现 张正友标定法和机器人手眼标定。\n","tags":["相机标定原理"],"categories":["相机标定"]},{"title":"使用opencv标定相机方法","url":"/2025/09/09/使用opencv标定相机方法/","content":"\n<!--more-->\n\n","tags":["opencv","相机标定"],"categories":["相机标定"]},{"title":"VMware17.6安装VMware Tools失败的原因以及解决方法","url":"/2025/09/08/VMwareTools安装失败的原因以及解决方法/","content":"\n<!--more-->\n\n在VMware17.6里面 安装ubuntu 和 win11 都发现VMware Tools很难安装，一开始我以为是我系统安装的问题，后面经过搜索发现2025年有遇见同样的问题。\n\n\n\n原来是博通变更链接致 VMware 自动更新功能失效\n\n[博通变更链接致 VMware 自动更新功能失效，用户被迫手动升级 - IT之家](https://www.ithome.com/0/842/319.htm)\n\n然后参考\n\n[(68 封私信 / 24 条消息) vmware解决更新Tools报错，无法连接更新服务器。请检查您的 Internet 设置或联系您的系统管理员 - 知乎](https://zhuanlan.zhihu.com/p/1891460517534619423)\n\n[【解决方案】Windows11 Vmware 17.6.0更新Tools报错，无法连接更新服务器。请检查您的 Internet 设置或联系您的系统管理员。_无法解析更新服务器。请检查您的 internet 设置或联系您的系统管理员。-CSDN博客](https://blog.csdn.net/qq_45196785/article/details/146966596)\n\n\n\n解决方法为：\n\n在虚拟机下载VMware Tools工具 安装。\n\n下载地址：\n\n[https://packages.vmware.com/too](https://link.zhihu.com/?target=https%3A//packages.vmware.com/tools/esx/latest/windows/x64/)\n\n然后一直点下一步安装即可。\n","tags":["虚拟机","解决问题"],"categories":["虚拟机"]},{"title":"C++命名规范","url":"/2025/08/09/C-命名规范/","content":"\n<!--more-->\n\n参考：\n\n[看了这么多代码，谈一谈代码风格！ | 代码随想录](https://www.programmercarl.com/前序/代码风格.html#题外话)\n\nGoogle C++ 编程风格指南\n\n# 前言：\n\n为什么会注意到C++命名规范呢？\n\n因为在我实习的过程中，无法避免地需要去阅读师兄师姐师弟师妹的代码。在我们软件中当然也有 JJ 师兄定制的代码规范，但是并不是很全面也不是所有人都会去遵循，这就导致有些代码可读性非常非常非常差。\n\n举例一个我刚刚实习看的业务代码让我很难阅读的地方：\n\n**变量命名完全不规范**，成员变量和局部变量混乱，成员变量有时候加m_ 有时候不加，局部变量也有时候加m_ 。尽管有IDE的帮助，阅读起来还是很费劲。\n\n我相信他自己回来重新看也会很费劲。\n\n为了提升自己代码的可读性，规范命名是很重要的。方便自己也方便共同开发的大家。\n\n\n\n\n\n# 简略内容\n\n## 变量的命名\n\n主流有如下三种变量规则：\n\n- 小驼峰、大驼峰命名法\n- 下划线命名法\n- 匈牙利命名法\n\n**小驼峰**，第一个单词首字母小写，后面其他单词首字母大写。例如 `int myAge;`\n\n**大驼峰法**把第一个单词的首字母也大写了。例如：`int MyAge;`\n\n\n\n通常来讲 java和go都使用驼峰，C++的函数和结构体命名也是用大驼峰，\n\n下划线命名法是名称中的每一个逻辑断点都用一个下划线来标记，例如：`int my_age`，**下划线命名法是随着C语言的出现流行起来的，如果大家看过UNIX高级编程或者UNIX网络编程，就会发现大量使用这种命名方式**。\n\n**匈牙利命名法**是：变量名 = 属性 + 类型 + 对象描述，例如：`int iMyAge`，这种命名是一个来此匈牙利的程序员在微软内部推广起来，然后推广给了全世界的Windows开发人员。\n\n\n\n### **总结**：\n\n### 尽管现在IDE很发达，我个人现在还是认为**匈牙利命名法**更加有可读性。\n\n\n\n## 水平留白（代码空格）\n\n操作符左右一定有空格，例如\n\n```text\ni = i + 1;\n```\n\n分隔符（`,` 和`;`）前一位没有空格，后一位保持空格，例如：\n\n```text\nint i, j;\nfor (int fastIndex = 0; fastIndex < nums.size(); fastIndex++)\n```\n\n大括号和函数保持同一行，并有一个空格例如：\n\n```text\nwhile (n) {\n    n--;\n}\n```\n\n控制语句（while，if，for）后都有一个空格，例如：\n\n```text\nwhile (n) {\n    if (k > 0) return 9;\n    n--;\n}\n```\n\n以下是我刚写的力扣283.移动零的代码，大家可以看一下整体风格，注意空格的细节！\n\n```cpp\nclass Solution {\npublic:\n    void moveZeroes(vector<int>& nums) {\n        int slowIndex = 0;\n        for (int fastIndex = 0; fastIndex < nums.size(); fastIndex++) {\n            if (nums[fastIndex] != 0) {\n                nums[slowIndex++] = nums[fastIndex];\n            }\n        }\n        for (int i = slowIndex; i < nums.size(); i++) {\n            nums[i] = 0;\n        }\n    }\n};\n```\n\n\n\n### **总结**：\n\n其实在使用VS2019写代码的时候，编译器都会自动调整，比如说 int a=1;编译器会在你输入 ; 的时候自动修改为 int a = 1;\n\n所以也说明这样的代码看上去更加规范，好阅读不会挤在一起。\n\n\n\n\n\n# GoogleC++命名规范（详细）\n\n晚一点总结，里面内容很多。我还没有读完。\n","tags":["C++","代码命名规范"],"categories":["C++"]},{"title":"虚拟机克隆、快照、迁移、删除","url":"/2025/08/08/虚拟机克隆、快照、迁移、删除/","content":"\n\n\n<!--more-->\n\n参考：\n\n[VMware虚拟机快照、克隆、迁移的概述以及操作_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1CD421V72i/?spm_id_from=333.337.search-card.all.click&vd_source=a858a9df12a9613b40ef1eefb011b473)\n\n[纯小白学习linux系统之----VMware虚拟机克隆、快照、迁移、删除_wmware拷贝-CSDN博客](https://blog.csdn.net/kezhene1/article/details/149900866)\n\n安装虚拟机不只是为了学习和体验Linux内核的系统，还有虚拟机的非常多好处吸引我。\n\n# 1.快照\n\n## 1.1快照概念:\n\n记录了虚拟机在某个特定时间点的状态(照片备份、游戏存档 )\n\n## 1.2快照用途:\n\n可以在需要时轻松地恢复虚拟机到快照创建时的状态。\n\n可保存虚拟机某一时刻的完整状态（内存、磁盘、配置）可随时回退，如系统升级/软件安装前创建快照，有问题可快速还原。\n\n详细：\n\n​\t**备份和恢复:**快速备份虚拟机状态的方法可以在数据丢失或损坏时快速恢复虚拟机到先前的状态。\n​\t**测试和开发**:在进行软件测试或开发时，可以先创建一个快照，然后进行更改。如果测试失败或发现错误，可以轻松地恢复虚拟机到快照状态，而不影响其他开发工作。\n​\t**安全更新**:在应用重要更新或配置更改之前，可以先创建一个快照，以便在更新失败时可以快速恢复到以前的状态，避免对生产环境造成影响。\n\n \n\n# 2.克隆\n\n## 2.1克隆概念:\n\n创建一个与源对象相似但完全独立的副本\n\n## 2.2克降用途:\n\n​\t快速部署:克降是快速创建相似配置的新对象的一种方法，因此在需要快速部署多个相似环境时非常有用，例如测试环境或开发环境。\n​\t测试和开发:在软件测试或开发过程中可以使用克降来创建一个与生产环境相似但独立的测试环境，以便进行安全的测试和开发工作。\n​\t灾难恢复:在灾难恢复方案中，克隆可以作为恢复备份数据的一种方式，通过创建虚拟机的克隆来快速恢复到先前的状态\n\n![图片](虚拟机克隆、快照、迁移、删除/1.png)\n\n- **完整克隆**：副本完全独立，性能高，占用存储空间大（适合生产环境）\n- **链接克隆**：依赖父虚拟机，节省空间，但父机不可删除（适合临时测试）。\n\n这里我感觉还是**完整克隆**更好。\n\n\n\n# 3.迁移\n\n## 3.1迀移概念:\n\n将虚拟机从一个物理服务器或数据中心迁移到另一个物理服务器或数据中心的过程(迁移到新硬件、新位置或新环境。)\n\n冷迁移（关闭虚拟机）：将虚拟机从一台物理主机迁移到另一台，或存储位置迁移\n\n热迁移（不关闭虚拟机）：对操作要求较高，感兴趣的同学可以研究下。\n\n## 3.2迁移用途:\n\n​\t资源平衡:迁移可以帮助在物理服务器之间平衡负载，确保资源被有效利用。\n\n​\t维护和升级:当您需要对物理服务器进行维护或升级时，可以使用迁移将虚拟机转移到备用服务器上，而无需中断服务。\n\n​\t灾难恢复:在出现灾难情况时，迁移可以帮助您将虚拟机快速迁移到备用数据中心以确保业务连续性。\n\n## 3.3如何进行迁移 ?\n\n注意:\n迁移过去的虚拟机所在软件也就是vmware的版本一定要>=迁移前vmware的版本(vmware高版本兼容低版本，但是低版本缺失/不匹配高版本的硬件版本、功能支持等)\n\n找到安装虚拟机操作系统时保存的文件夹，选择文件拷贝即可。\n","tags":["虚拟机","VMware","备份"],"categories":["虚拟机"]},{"title":"虚拟机Ubuntu和宿主机之间的复制粘贴功能","url":"/2025/08/04/虚拟机Ubuntu和宿主机之间的复制粘贴功能/","content":"\n<!--more-->\n\n参考：\n\n[关于VMware Tools 不再随旧版客户机操作系统的 VMware Workstation 一起提供。-CSDN博客](https://blog.csdn.net/qq_39172792/article/details/146919942)\n\n[(68 封私信 / 20 条消息) VMware虚拟机和主机间复制粘贴共享剪贴板 - 知乎](https://zhuanlan.zhihu.com/p/665154528)\n\n\n\n# 前言:\n\n看视频别人安装Ubuntu之后,能自动安装VMware Tools，实现VMware虚拟机和主机间复制粘贴共享剪贴板，但是我的不行，点击安装VMware Tools，提示\n\nVMware Tools 不再随旧版客户机操作系统的 VMware Workstation 一起提供。\n\n请从 https://packages-prod.broadcom.com/tools/frozen/linux/linux.iso 下载，并参阅 Install VMware Tools in VMware products 以了解安装步骤。\n\n客户机操作系统没有任何 VMware Tools 映像。\n![](虚拟机Ubuntu和宿主机之间的复制粘贴功能/1.png)\n\n\n\n# 解决：\n\n尝试参考[关于VMware Tools 不再随旧版客户机操作系统的 VMware Workstation 一起提供。-CSDN博客](https://blog.csdn.net/qq_39172792/article/details/146919942)的第一种解决方法\n\n> ### 方法一\n>\n> 进入命令行，输入命令\n>\n> sudo apt-get install open-vm-tools-desktop\n>\n> 一路输入yes下去，直到安装完成\n\n**但是根本不行，说找不到这个。**\n\n于是尝试第二种方法\n\n> ### 方法二\n>\n> #### 1.复制上述连接\n>\n> https://packages-prod.broadcom.com/tools/frozen/linux/linux.iso\n>\n> #### 2.打开火狐浏览器\n>\n> 粘贴连接进入浏览器，下载弹出的文件\n\n发现连不上网，于是解决联网的问题，咨询ai老师\n\n## 联网问题解决：\n\n### 1.VMware 常见网络模式\n\n- **NAT**：通过主机共享网络。\n- **桥接**：直接使用主机网络。\n- **仅主机**：只和主机通信。\n\n✔ 推荐使用：**NAT 模式**。\n\n> 设置路径：虚拟机 → 设置 → 网络适配器 → 选择 NAT 或 桥接。\n\n### 2、检查 Ubuntu 网络是否启用\n\n进入 Ubuntu，执行以下命令查看网络状态：\n\n```\nip a\n```\n\n或使用：\n\n```\nnmcli device status\n```\n\n查看 `eth0` 或 `enp0s3` 等网卡是否是 `connected` 状态。\n\n### 3.测试联网是否成功\n\n```\nping -c 4 www.baidu.com\nping -c 4 8.8.8.8\n```\n\n- 能 ping 通域名 → 网络和 DNS 正常。\n- 能 ping 通 IP 但不能 ping 域名 → DNS 有问题。\n- 都 ping 不通 → 网卡/网络配置错误。\n\n然后就可以联网了。\n\n一开始想复制网址过去打开，发现还不能复制，只好手打。\n\n\n\n\n\n下载之后，按照步骤操作。\n\n## 下载完成后打开文件所在目录\n\n可以看到下载了如下文件\n\n![](虚拟机Ubuntu和宿主机之间的复制粘贴功能/2.png)\n\n在文件所在目录空白处右键选择Open in Terminal进入命令行\n\n![](虚拟机Ubuntu和宿主机之间的复制粘贴功能/3.png)\n\n## 挂载设备\n\n进入命令行，使用如下命令，创建挂载目录\n\n```\nsudo mkdir /media/iso_mount\n```\n\n使用如下命令，将iso挂载到指定目录\n\n```\nsudo mount -o loop ./linux.iso /media/iso_mount\n```\n\n可以看到桌面出现如下文件，即挂载成功\n\n![](虚拟机Ubuntu和宿主机之间的复制粘贴功能/5.png)\n\n\n\n> 这个时候开始不顺利了\n\n![](虚拟机Ubuntu和宿主机之间的复制粘贴功能/4.png)\n\n**注意：**输入密码是不会显示的，输入完之后，直接回车即可。\n\n这里第一次输入错误因为 （`mkdir/media/iso_mount` 被当作一个整体命令）\n\n在ai老师的指导下，先删除了之前的文件目录，重新创建挂载就可以了，不是很清楚为什么。\n\n```\n# 1. 删除残留文件/目录（如果存在）\nsudo rm -rf /media/iso_mount\n\n# 2. 正确创建目录（使用 mkdir）\nsudo mkdir /media/iso_mount\n\n# 3. 挂载ISO文件（确保当前在 ~/下载 目录）\nsudo mount -o loop ./linux.iso /media/iso_mount\n```\n\n\n\n## 安装VmwareTool\n\n进入该目录，将压缩包复制到桌面\n\n![](虚拟机Ubuntu和宿主机之间的复制粘贴功能/6.png)\n\n> 我发现我的桌面已经有了\n\n在桌面进入命令行，输入如下命令，然后按下Tab补全，解压压缩包\n\n```\ntar -zvxf ./V\n```\n\n![](虚拟机Ubuntu和宿主机之间的复制粘贴功能/7.png)\n\n解压完成我们进入解压后的文件夹\n\n![](虚拟机Ubuntu和宿主机之间的复制粘贴功能/8.png)\n\n内容如下\n\n![](虚拟机Ubuntu和宿主机之间的复制粘贴功能/9.png)\n\n右键进入命令行，输入如下指令\n\n```\nsudo ./[vmware]-install.pl\n```\n\n进入如下界面\n\n![](虚拟机Ubuntu和宿主机之间的复制粘贴功能/10.png)\n\n输入yes，然后一路回车\n\n出现这个就是安装好了\n\n![](虚拟机Ubuntu和宿主机之间的复制粘贴功能/11.png)\n\n![](虚拟机Ubuntu和宿主机之间的复制粘贴功能/12.png)\n\n这个时候我发现还是不能复制粘贴，其实应该要重启之后再尝试，应该就可以了。\n\n### 重启你的系统\n\n```text\nsudo reboot\n```\n\n\n\n下面是安装open-vm-tools和open-vm-tools-desktop\n\n```\nsudo apt-get install open-vm-tools\nsudo apt-get install open-vm-tools-desktop\n```\n\n\n\n安装过程中遇见如下问题\n\n![](虚拟机Ubuntu和宿主机之间的复制粘贴功能/13.png)\n\n这个提示是关于 PAM（Pluggable Authentication Modules）配置文件 `/etc/pam.d/vmtoolsd` 的冲突处理。在安装 `open-vm-tools` 时，安装程序发现该文件在系统中已经存在（可能是之前安装 VMware Tools 时创建的），并且与软件包维护者提供的版本不同。因此，它询问您如何处理这个冲突。\n\n\\### 选项解释：\n\n\\- **Y 或 I**：安装软件包维护者提供的版本（覆盖当前文件）\n\n\\- **N 或 O**：保留您当前使用的版本（不覆盖）\n\n\\- **D**：显示两个版本的区别（diff）\n\n\\- **Z**：将进程切换到后台（暂时不处理）\n\n**问题核心**\n\n1. **冲突文件**：`/etc/pam.d/vmtoolsd` (PAM 认证配置文件)\n2. **冲突双方**：\n   - 您系统中已存在的版本（可能是之前安装留下的）\n   - 软件包维护者提供的新版本\n\n- `-` 开头行：当前系统中存在的配置（将被删除）\n- `+` 开头行：软件包提供的新配置（将替换旧配置）\n\n这个差异显示配置格式有重大变化，新版本使用了更标准的 PAM 配置方式。\n\n**强烈建议选择**\n\n✅ **输入 `Y` 然后按回车**\n（使用软件包维护者提供的新版本）\n\n**为什么选择 Y？**\n\n1. **兼容性保证**：新版本是专门为当前软件（open-vm-tools 12.3.5）设计的\n2. **安全性**：旧配置可能包含已弃用的模块（如 `pan_shells.so`）\n3. **功能完整性**：确保 VMware Tools 认证系统正常工作\n4. **避免后续问题**：选择 N 可能导致服务启动失败\n\n**安装后验证**\n\n完成选择后执行：\n\n```\n# 重启服务\nsudo systemctl restart vmtoolsd\n\n# 检查状态\nsystemctl status vmtoolsd\n\n# 测试功能（安装后重启）\nsudo reboot\n```\n\n\n\n**至此，复制粘贴功能实现。**\n\n# Ubuntu复制粘贴快捷键\n\n复制：Ctrl+Shift+C\n\n粘贴：Ctrl+Shift+V\n\n比Windows系统的多了个Shift。\n\n\n\n# open-vm-tools和open-vm-tools-desktop关系\n\n1. open-vm-tools 和 open-vm-tools-desktop 都是 VMware的开源虚拟化工具，它们提供了一些增强功能和集成来改善虚拟机在 VMware 虚拟化环境中的性能和用户体验。\n2. open-vm-tools-desktop 是 open-vm-tools 的扩展，专注于提供与桌面虚拟机相关的增强功能。安装open-vm-tools-desktop 将包括 open-vm-tools提供的所有功能。\n3. 即只安装open-vm-tools-desktop也可以。但是只安装open-vm-tools可能还是不能共享剪贴板，某些 Linux 发行版和虚拟机环境需要额外的组件来实现这些功能，这时候就需要额外安装open-vm-tools-desktop了。\n","tags":["虚拟机","Ubuntu","复制粘贴"],"categories":["Ubuntu"]},{"title":"虚拟机安装Linux系统","url":"/2025/08/04/虚拟机安装Linux系统/","content":"\n<!--more-->\n\n# 结果展示\n\n![图片](虚拟机安装Linux系统/1)\n\n\n\n# 安装VMware虚拟机软件\n\n在微信公众号softgj里面找到VMware，建议安装版本比较新的。因为低版本VMware可能不能安装新版本的linux内核的系统。\n\n安装操作步骤一步一步来即可。\n\n密钥【MC60H-DWHD5-H80U9-6V85M-8280D】\n\n\n\n# 安装ubuntu22.04系统\n\n## 系统选择理由：\n\n参考[常见Linux发行版本有哪些？ - C语言中文网](https://c.biancheng.net/view/710.html)\n\nLinux 的发行版本众多，下面给选择 Linux 发行版本犯愁的朋友一点建议：\n\n1. 如果你需要的是一个服务器系统，而且已经厌烦了各种 Linux 的配置，只是想要一个比较稳定的服务器系统，那么建议你选择 CentOS 或 RHEL。\n2. 如果你只是需要一个桌面系统，而且既不想使用盗版，又不想花大价钱购买商业软件，不想自己定制，也不想在系统上浪费太多时间，则可以选择 Ubuntu。\n3. 如果你想深入摸索一下 Linux 各个方面的知识，而且还想非常灵活地定制自己的 Linux 系统，那就选择 Gentoo 吧，尽情享受 Gentoo 带来的自由快感。\n4. 如果你对系统稳定性要求很高，则可以考虑 FreeBSD。\n5. 如果你需要使用数据库高级服务和电子邮件网络应用，则可以选择 SuSE。\n\n以上纯属个人化建议，非官方指导意见。其实 Linux 的发行版本众多，但是系统的核心——内核却系出同门，所以只要学会使用其中一种，即可触类旁通。\n\n\n\n根据我在网上搜索，发现linux的教程以及大多数人下载的有两个发行版：CentOS、Ubuntu。CentOS（已被替代为 AlmaLinux/Rocky）\n\n考虑到我对linux内核完全不熟悉，所以选择Ubuntu，因为他有桌面系统。等我上手熟悉之后再学习使用别的发行版。**因为命令行界面是 Linux 的精髓之一。善于使用命令行，可以大大提升效率。**所以，一开始可以依赖\"图形界面\"；但如果要想提升，必须让自己逐步适应\"命令行界面\"。\n\n选择22.04是因为现在最新的是24.04，但是我的教程里面是18.04，18.04官方支持已于 2023 年 5 月结束。折中选择了一个22.04（稳定，资源多）\n\n\n\n## 安装步骤：\n\n### 1.下载镜像文件\n\n在ubuntu官网找到之前的版本下载（其他下载）,注意这里下载的是桌面版不是服务器版，因为我是个人使用学习。\n\n![](虚拟机安装Linux系统/2.png)\n\n### 2.具体安装步骤\n\n参考[VMware创建虚拟机，安装Linux系统——Ubuntu22.04版本_sysin 提取码-CSDN博客](https://blog.csdn.net/jacknbv/article/details/124640386?ops_request_misc=elastic_search_misc&request_id=2297913f792d18bdb58604eff7bc251d&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~ElasticSearch~search_v2-14-124640386-null-null.142^v102^pc_search_result_base9&utm_term=linux ubuntu22.04系统安装&spm=1018.2226.3001.4187)\n\n参考softgj安装linux操作系统内核ubuntu的教程\n\n其实两个都差不多，但是CSDN博客悠悠海风介绍的更加详细，我主要参考ta的。\n\n#### 2.1创建虚拟机\n\n注意创建虚拟机我是选的第一个选项，而参考选择的第二个\n\n![](虚拟机安装Linux系统/3.png)\n\n![](虚拟机安装Linux系统/4.png)\n\n![](虚拟机安装Linux系统/5.png)![](虚拟机安装Linux系统/6.png)\n\n\n\n**我设置的CPU和内存都是4**\n\n\n\n![](虚拟机安装Linux系统/7.png)![](虚拟机安装Linux系统/8.png)![](虚拟机安装Linux系统/9.png)![](虚拟机安装Linux系统/10.png)![](虚拟机安装Linux系统/11.png)![](虚拟机安装Linux系统/12.png)![](虚拟机安装Linux系统/13.png)\n\n\n\n\n\n#### 2.2安装Ubuntu系统\n\n![](虚拟机安装Linux系统/14.png)\n\n我确实没有出现下面的情况。\n\n我安装系统的时候，会出现BIOS配置，可能你们的不会出现，在这个界面中，利用方向键切换主菜单（Boot所在的那一栏）的选项，选择驱动程序-->Hard Drive。\n\n![](虚拟机安装Linux系统/15.png)\n\n\n\n![](虚拟机安装Linux系统/16.png)\n\n\n\n**注意：这里进去可能要很久 鼠标是一个⭕ 就是正在加载，要等一下。**\n\n\n\n![](虚拟机安装Linux系统/17.png)\n\n![](虚拟机安装Linux系统/18.png)\n\n![](虚拟机安装Linux系统/19.png)\n\n![](虚拟机安装Linux系统/20.png)\n\n![](虚拟机安装Linux系统/21.png)\n\n![](虚拟机安装Linux系统/22.png)\n\n![](虚拟机安装Linux系统/23.png)\n\n安装的时间可能需要二三十分钟。\n这样就安装完了。\n\n","tags":["虚拟机","Linux内核","ubuntu"],"categories":["软件安装"]},{"title":"机器人模型描述格式URDF","url":"/2025/08/02/机器人模型描述格式URDF/","content":"\n\n\n<!--more-->\n\n参考：\n\n[ROS机器人建模与仿真（一）——URDF模型的建立和改进-CSDN博客](https://blog.csdn.net/qq_43551910/article/details/121773348)\n\n[(68 封私信 / 20 条消息) 开源URDF文件数据集 - 知乎](https://zhuanlan.zhihu.com/p/1889001005816976558)\n\n\n\n# 什么是URDF格式\n\nURDF，全称是Unified Robot Description Format，统一机器人描述格式。URDF文件格式用于描述机器人最早是由机器人操作系统（ROS）的开发人员在2009年引入，是一种描述机器人的运动学、动力学和几何形状的通用格式文件，独立于软件程序，方便不同的软件工具以及开发人员共享机器人数据模型。URDF文件重要的一点是其可读性，因为它是XML类型的文本文件。URDF文件中可以描述机器人的运动学结构、动力学参数、视觉外观（通过引用其它文件）和几何碰撞边界（通过引用其它文件）。\n\nURDF 是 ROS 中机器人模型的描述格式，包含对机器人刚体外观、物体属性、关节类型等方面的描述。URDF（Unified Robot Description Format，统一机器人描述格式）是 ROS 中一个非常重要的机器人模型描述格式，ROS 同时也提供 URDF 文件的 C++ 解析器，可以解析 URDF 文件中使用 XML 格式描述的机器人模型。\n\n\n\n\n# 1 URDF 文件中常用的标签\n\n## 1.1 < link > 标签\n\n< link >标签用于描述机器人某个刚体部分的**外观和物理属性**，包括尺寸（size）、颜色（color）、形状（shape）、惯性矩阵（inertial matrix）、碰撞参数（collision properties）等。\n\n```\n<link name = \"<link name>\"> \n<inertial> ------------</inertial>\n\t<visual>-------------</visual>\n\t<collision>--------- </collision>\n</link>\n```\n\n< visual >用于描述机器人link部分的外观参数，< inertial >标签用于描述link的惯性参数，而< collision >标签用于描述link的碰撞属性。**一般来说，检测碰撞的link区域大于外观可视的区域，也就是说有一定的安全空间**\n\n## 1.2 < joint >标签\n\n< joint >标签用于描述机器人**关节的运动学和动力学属性**，包括关节运动的位置和速度限制。机器人关节的主要作用是连接两个刚体link，这两个link分别称为 parent link 和 child link。\n\n```\n<joint name=\"<name of the joint>\">\n\t<parent link = \"parent_link\" />\n\t<child  link = \"child_link\" />\n\t<calibration ---- />\n\t<dynamics damping ---- />\n\t<limit effort ---- />\n</joint>\n```\n\n其中必须指定joint的parent link 和 child link，还可以设置关节的其他属性。\n< calibration > : 关节的参考位置，用来校准关节的绝对位置\n< dynamics > : 用于描述关节的物理属性，例如阻尼值、物理经摩擦力等，经常在运动学仿真中用到。\n< limit > : 用于描述运动的一些极限值，包括关节运动的上下限位置、速度限制、力矩限制等。\n< mimic > : 用于描述该关节与已有关节的关系。\n< safety_controller > : 用于描述安全控制器的参数。\n\n## 1.3 < robot > 标签\n\n< robot > 是完整机器人模型的最顶层标签，< link > 和 < joint > 标签都必须包含在< robot >标签内。一个完整的机器人模型由一系列的< link > 和 < joint > 组成。\n\n< robot >标签语法如下：\n\n```\n<robot name = \"<name of the robot>\">\n\t<link> -------</link>\n\t<link> -------</link>\n\t<joint>-------</joint>\n\t<joint>-------</joint>\n</robot>\n```\n\n## 1.4 < gazebo >标签\n\n< gazebo >标签用于描述机器人模型在Gazebo中仿真所需要的参数，包括机器人材料的属性、Gzaebo 插件等。该标签不是机器人模型必须的部分，只有在 Gazebo 仿真时才需加入。\n\n< gazebo >标签的基本语法如下:\n\n```\n<gazebo reference = \"link_1\">\n\t<material> Gazebo/Black</material>\n</gazebo>\n```\n\n# 2 创建一个机器人URDF 模型\n\n## 2.1 准备工作（创建功能包和文件夹）\n\n创建test_mrobot_description功能包，依赖urdf，xacro\n在其下创建4个文件夹urdf、meshes、launch和config\n\nurdf : 用于存放机器人模型的 URDF 或 xacro 文件\nmeshes : 用于存放URDF中引用的模型渲染文件\nlaunch : 用于存放相关启动文件\nconfig : 用于存放日 rviz 的配置文件\n\n**(经过测试，URDF文件不能加入中文字符，写程序时注意将中文注释去掉！！！)**\n\n\n\n\n\n# 3.URDF文件解析\n\nURDF文件重要的一点是其可读性，因为它是**XML类型的文本文件**。可以通过tinyXML解析，OCC也有解析的能力，有自带 `XmlDrivers` / `XmlMDF` 模块，也可用 `xerces-c` 等库，不直接支持 URDF，需要自行读取 XML + 构建模型。所以可以集成起来。\n","tags":["机器人","URDF"],"categories":["机器人"]},{"title":"机器人运动学","url":"/2025/08/02/机器人运动学/","content":"\n\n\n<!--more-->\n\n**主要学习资料、参考资料**\n\n1.机器人学导论(John J. Craig 贠超 王伟)\n\n2.机器人动力学与控制（霍伟编著）\n\n3.[机器人学基础（1）-位置运动学-正运动学、逆运动学方程建立及其求解-CSDN博客](https://blog.csdn.net/Bellwen/article/details/129182436)\n\n4.[机器人学：（3）机器人运动学-CSDN博客](https://blog.csdn.net/weixin_43724057/article/details/129739113)\n\n\n\n# 一、正运动学\n\n**正运动学可以理解为，已知机械臂各个关节θ，求机械臂手末端的位置和姿态。**\n\n核心是坐标系变换链：\n`T = A1(θ1) * A2(θ2) * ... * An(θn)`\n其中每个`Ai`是关节的变换矩阵\n\n\n\n# 二、逆运动学\n\n**逆运动学可以理解为，已知机械臂末端的位置和姿态(T)，求机械臂各个关节θ**\n\n\n\n# 三、MDH和DH方法的区别\n\n1955年，**Denavit和Hartenberg**提出一种基于齐次变换矩阵的低副机构建模方法，该方法为每个连杆固连了一个坐标系，用 4x4 的变换矩阵描述相邻连杆的位姿关系，通过齐次变换建立运动学模型，被称为Denavit-Hartenberg参数模型，简称D-H模型，这种建模方法被称为D-H法。\n\n目前，D-H建模方法主要有两种：**标准 D-H 方法（Standard D-H method）**和**改进的 D-H 方法（Modified D-H method）**。这两种方法**主要区别**在于**坐标系建立的位置不同**。\n\nMDH（修正Denavit–Hartenberg）和DH（标准Denavit–Hartenberg）方法都是用于建立**串联机器人机械臂的运动学模型**的建模方法，它们的目标相同：**建立各连杆之间的坐标变换关系**。\n\n\n\n![](机器人运动学/DH.png)\n\n\n\n\n\n\n\n![](机器人运动学/MDH的特点.png)\n\n\n\n![](机器人运动学/MDH.png)\n\n## 联系（相同点）\n\n| 项目     | 内容                                                     |\n| -------- | -------------------------------------------------------- |\n| 目的     | 建立各关节坐标系之间的齐次变换，用于正逆运动学求解       |\n| 参数数量 | 都使用4个参数描述两坐标系之间的位置与方向关系（θ,d,a,α） |\n| 应用场景 | 都广泛应用于**串联**型机械臂的建模                       |\n| 变换结构 | **本质都是通过旋转和平移组合实现坐标系变换**             |\n\n\n\n参数的定义：杆件长度 a、杆件扭角 α、关节距离 d、关节转角 θ\n\n\n\n## 区别（关键差异）\n\n| 比较项         | **标准 DH 方法**                                 |            **修正 MDH 方法**            |\n| -------------- | ------------------------------------------------ | :-------------------------------------: |\n| 坐标系设置     | 旋转轴Z与下一个坐标系的Z轴共线                   | Z轴仍为关节轴，但采用不同坐标系放置规则 |\n| 坐标系放置方式 | z 轴定义关节轴，x 轴沿两 z 轴的共同垂线方向      | x 轴平行于前一坐标系的 z 轴，定义略不同 |\n| 齐次变换矩阵   | AiDH=Rz(θ)Tz(d)Tx(a)Rx(α)                        |       AiMDH=Tx(a)Rx(α)Tz(d)Rz(θ)        |\n| 适用结构       | 通用，但对某些结构建模较复杂（如冗余或特殊结构） |  更灵活，适合于复杂结构和软件自动建模   |\n| 工业应用       | 比如《机器人学：建模与控制》中大量使用DH法       |      ROS、某些仿真软件更偏好MDH法       |\n\n\n\n### 总结：\n\n标准 DH 法适合教材与理论分析，**MDH 更适合实际工程建模和复杂结构**；两者变换本质一致，仅坐标系定义与变换顺序不同。\n\n\n参数的定义：杆件长度 a、杆件扭角 α、关节距离 d、关节转角 θ\n\n**DH和MDH的四个参数的具体定义不一样（主要是对杆件长度和杆件扭角的定义不一样），齐次变换矩阵不一样（顺序不一样）。**\n\nDH参数与MDH 参数间，除 i = 0 和i = n 的某些特殊情况外，**一般地有以下关系：**\nD H 参数｛a i ，αi ，di ，θi｝ = 修改的 D H 参数｛a i₊₁ ，αi₊₁ ，di ，θi｝\n\n\n\nDH的变换矩阵是    d θ a α\n\nMDH的变换矩阵是  a α d θ\n\n<img src=\"机器人运动学/DH建模.png\" style=\"zoom:50%;\" />\n\n<img src=\"机器人运动学/mDH建模.png\" style=\"zoom:50%;\" />\n","tags":["C++","Qt","机器人运动学","研究生期间"],"categories":["机器人"]},{"title":"替换css文件之后没有重新加载样式","url":"/2025/07/31/替换css文件之后没有重新加载样式/","content":"\n\n\n<!--more-->\n\n使用的是 Qt 的 `qrc` 资源系统（比如 `\":/qss/style.qss\"`），那么只是替换文件是不够的，你需要**重新编译资源文件**。\n\n修改 `.qrc` 文件后重新运行 `rcc` 或者 **重新构建项目**。\n","tags":["C++","Qt","CSS"],"categories":["报错"]},{"title":"错误LNK2001,无法解析的外部符号，static QMetaObject","url":"/2025/07/31/QMetaObject/","content":"\n\n\n<!--more-->\n\n严重性\t代码\t说明\t项目\t文件\t行\t禁止显示状态 错误\tLNK2001\t无法解析的外部符号 \"public: static struct QMetaObject const xxxxx::staticMetaObject\" (?staticMetaObject@xxxxx@@2UQMetaObject@@B)\t\n\n# **出现场景：**\n\n在新电脑安装VS2019,和QT VS TOOLS插件之后，代码是可以正常运行生成的。后面安装了番茄助手，然后QT VS TOOLS 的插件就不见了（暂时没有找到原因） 。就出现了这个报错。\n\n\n\n这个链接错误（`LNK2001: 无法解析的外部符号 staticMetaObject`）通常是由于 **Qt 宏**（如 `Q_OBJECT`）使用不当或相关的 moc 文件没有被正确生成/链接导致的。\n\n# **常见原因及解决方案：**\n\n **1.类中使用了 `Q_OBJECT` 宏，但未运行 `moc`（Meta-Object Compiler）**\n\n​\t检查你的类 `xxxxx` 的头文件是否包含了 `Q_OBJECT` 宏。\n\n**2.头文件未被正确包含在构建系统中（尤其是非 Qt Creator 的项目）**\n\n​\t确保你的类头文件 `xxx` 已添加到项目中，而不是仅仅被引用（否则 VS 不会触发 moc）。\n\n​\t**右键 `.h` 文件 → 属性 → 设置为 “使用 MOC 编译器” 或确保 Qt VS Tools 插件启用。**\n\n![图片](QMetaObject/1.png)\n\n\n在设置之后代码可以生成，但是我觉得很奇怪为什么之前添加新文件不会需要手动修改类型呢？后面发现是QT VS TOOLS插件的问题。\n\n我重新安装之后，解决方案里面有些项目被卸载。又卸载重新安装了一次，把被卸载的项目先移除然后再添加进来。\n","tags":["C++","Qt"],"categories":["报错"]},{"title":"VS2019番茄助手安装","url":"/2025/07/29/VS2019番茄助手安装/","content":"\n\n\n<!--more-->\n\n每次安装都会忘记一些关键步骤，写下来！\n\n参考：[给 VS2019 安装个 Visual Assist x 插件 - ALLEN_2008 - 博客园](https://www.cnblogs.com/allen-blog/articles/17324636.html#!comments)\n\n[VS2019 安装番茄助手（Visual Assist x 插件）攻略_vs2019番茄助手-CSDN博客](https://blog.csdn.net/No_21name/article/details/135392409?ops_request_misc=&request_id=&biz_id=102&utm_term=番茄助手VS2019&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-8-135392409.142^v102^pc_search_result_base9&spm=1018.2226.3001.4187)\n\n\n\n## 相应环境\n\n- 系统平台：WIN11\n- VS：VS2019\n- VAX版本：Visual Assist X 10.9.2406.0（其他版本也可对应操作）\n\n## 重点说明：\n\n1. 安装VA_X_Setup2440_0.exe前，先要右键exe文件勾选兼容性。在 win7 下，Visual Assist x 可能需要兼容运行（右击，属性，兼容性设置），因为直接双击可能就给你红框崩溃。\n2. 去掉 VS2019 插件更新勾选框和 VAX 更新勾选框。（这个我没用到）\n\n## 安装步骤\n\n先上一张安装文件源图\n\n![图片](VS2019番茄助手安装/11.png)\n\n双击直接安装VA_X_Setup2406_0.exe，在装到VS2019时会发生错误，提示安装不成功（不用管，接着让它装）。**就是一直不管它，一开始会retry，后面会说错误**\n此时，\n\n​\t用 everything（一个软件，可以在网上下载） 在 Temp 文件夹找到与 VS2019 匹配的安装版本，这里是 VaXSetup.vsix，拷贝到桌面（ 重点！在出现错误窗口的时候，不要关！不要关！不要关！这个时候用everything去搜 VaXSetup.vsix ）\n\n​\t等原文件 VA_X_Setup2406_0.exe 安装完之后（VA_X_Setup2406_0.exe等它报错才能删除），会在C:\\Users\\用户\\AppData\\Local\\Microsoft\\VisualStudio\\16.0_5b3ff307（这个地方每个人是不同的，但是都是16.0_开头）\\Extensions 下产生文件。删除这个目录下所有文件夹和文件。（这个路径不一定是完全相同的）\n\n​\t使用 VaXSetup.vsix 重新安装，此时是安装到 VS2019，最终会提示安装成功。同时会在 Extensions 目录生成新的文件夹和文件。（其实对于 VS2019， VAX 是安装 Extensions 目录下的，所以如果 VAX 插件出现问题，则可以多次删除，多次重装。2010 及之前版本则不同。）\n\n​\t用破解的 VA_X64.dll 和 PiaoYun64.dll 拷贝到 Extensions/随机文件夹(就一个文件夹，名字是随机的)/ ，路径下（简单一点的话就用everything搜VA_X.dll,找到类似这个路径，把VA_X64.dll 和 PiaoYun64.dll 拷贝进去）。\n\n​\t找到 VS2019 的安装目录。具体为：右击 VS2019 图标->属性，在快捷方式栏找到“目标”，“目标”后面的文本框就是 [VS2019 安装](https://so.csdn.net/so/search?q=VS2019 安装&spm=1001.2101.3001.7020)目录.（如图）\n\n![图片](VS2019番茄助手安装/22.png)\n\n​\t按住win+R，输入cmd打开，在命令行切换到 5（第五步） 的目录，运行命令：devenv.exe /safemode，回车（安全模式下运行一回）（如图）。此时在 VS2019 插件管理有 Visual Assist x 插件，但不能用。直接关闭 VS2019。\n\n怎么用命令行进入：\n\n默认是在C盘 所以先输入 d: 进入D盘\n\n然后使用cd可以进入目标目录（或者文件夹打开之后会自动进去像我的一样）\n\n![图片](VS2019番茄助手安装/44.png)\n\n<img src=\"VS2019番茄助手安装/33.png\" alt=\"图片\" style=\"zoom:80%;\" />\n\n​\t这次正常打开 VS2019，最终会看到 extension 菜单下出现 Visual Assist x。\n\n​\t这还没完。需要去掉插件更新和 Visual Assist x 更新勾选。具体为：\n　　* ​\t拓展->管理拓展->已安装->弹出对话框的右上角，具体下图。\n\n![图片](VS2019番茄助手安装/55.png)\n\n![图片](VS2019番茄助手安装/66.png)\n\nVisual Assist x options 对话框左边->startup，见下图。\n\n![图片](VS2019番茄助手安装/77.png)\n\n![图片](VS2019番茄助手安装/88.png)\n\n\n\n在这里可以设置快捷键生成注释块\n\n\n\n\n\n![图片](VS2019番茄助手安装/99.png)\n\n\n\n![图片](VS2019番茄助手安装/100.png)\n","tags":["C++","软件安装","番茄助手"],"categories":["软件安装"]},{"title":"std::greater()和std::less()在排序和建堆的应用以及自定义比较函数的规则","url":"/2025/07/28/std-greater-和std-less-在排序和建堆的应用以及自定义比较函数的规则/","content":"\n<!--more-->\n\n\n\n# 解释\n\n## 比较规则：strict weak ordering\n\n`std::greater()`、`std::less()`、自定义比较函数，这些都其实是用作比较的，要遵从c++制定的比较规则。\n\n![图片](std-greater-和std-less-在排序和建堆的应用以及自定义比较函数的规则/compare.png)\n\n需要满足三种特性要求，否则使用中会报错：\n\n- 反自反性：`false`\n- `true`的互斥性：`true`则`false`（但不要求`false`则怎么样）\n- 传递性：`true`＋`true`则`true`\n\n## less和greater其实是什么\n\n两个函数的头文件是functional\n\n比如`less`\n\n```\ntemplate <class T> struct less {\n  bool operator() (const T& x, const T& y) const {return x<y;}\n  typedef T first_argument_type;\n  typedef T second_argument_type;\n  typedef bool result_type;\n};\n```\n\n可以看到关键就是**bool operator()**和**return x<y;**\n\n**bool operator()**：要的就是这个返回值bool，**决定比较是否要交换。这个结果用在排序和建堆中就表示是否要交换。**\n**return x<y;**：可以看到其实就是使用<之类的操作符重载，这就是怎么排序的规则。\nPS：但这产生了限制，基本的元素int之类的，自然可以直接比较；但复杂类型如自定义一个类，里面有多个数据，我们就还得定义重载操作符比较，要不然编译器不知道该比较什么。\n\n\n\n## bool返回值和比较操作符\n\n### 规则\n\n`bool comp(a, b)`意思是：返回的值指示作为第一个参数传递的元素是否被视为在其定义的特定严格弱排序中位于第二个参数之前。\n\n- 返回`true`：表示`ab`(`a`在`b`前）\n- 返回`false`：表示`ba`（a`在`b`后）\n\n![图片](std-greater-和std-less-在排序和建堆的应用以及自定义比较函数的规则/11.png)\n\n### 并不是想当然的位置交换\n\ncomp(a, b)虽然会交换a和b，但你不能想当然地认为位置就该怎么样，到底数组中谁会是a，谁会是b，这要看调用的算法的。\n\n比如，[a < b]  [6 < 1] : 0，其实是算法调用时a是6，b是1，而非看到数组中原来的顺序就想当然的a是1，b是6。\n\n\n\n\n\n\n# 知识基础\n\n## 参考我的[priority_queue]()博客\n\n这里简略再复述一些助于理解的关键信息。\n\n什么是**优先级队列**呢？\n\n其实***就是一个披着队列外衣的堆***，因为优先级队列对外接口只是从队头取元素，从队尾添加元素，再无其他取元素的方式，看起来就是一个队列。\n\n优先级队列内部元素是自动依照元素的**权值**排列。\n\n所以大家经常说的**大顶堆**（堆头是最大元素），**小顶堆**（堆头是最小元素），如果懒得自己实现的话，**就直接用priority_queue（优先级队列）就可以了，底层实现都是一样的**，从小到大排就是小顶堆，从大到小排就是大顶堆。\n\npriority_queue 容器适配器模拟的也是队列这种存储结构，即使用此容器适配器存储元素只能“从一端进（称为队尾），从另一端出（称为队头）”，且每次只能访问 priority_queue 中位于队头的元素。\n\n但是，priority_queue 容器适配器中元素的存和取，遵循的并不是 “First in,First out”（先入先出）原则，而是“***\\*First in，Largest out\\****”原则。直白的翻译，指的就是先进队列的元素并不一定先出队列，而是优先级最大的元素最先出队列。（**Largest out**是指权重最大）\n\n**通过以上的内容，我们可以用priority_queue来理解下面的内容。**\n\n<img src=\"std-greater-和std-less-在排序和建堆的应用以及自定义比较函数的规则/priority_queue.png\" alt=\"图片\" style=\"zoom:75%;\" />\n\n# 结论\n\n## 排序和建堆的效果\n\n### 排序：\n\nless<T>变成**升序**（从左到右遍历下标时，数组元素是**从小到大**）\ngreater<T>变成**降序**（从左到右遍历下标时，数组元素是**从大到小**）\n\n### 建堆：\n\nless<T>变成**大顶堆**（从上层到下层，堆元素是从大到小，同层之间随便）\ngreater<T>变成小顶堆（从上层到下层，堆元素是从小到大，同层之间随便）\n\n### 默认情况下：\n\n**建堆**的时候，默认是**大根堆**（堆头是最大元素），第三个参数用greater<T>会变成小根堆；\n\n**排序**的时候，默认是**从小到大**，但是第三个参数用greater<T>会变成从大到小\n\n可以看到默认情况下都是用**less**，但是**看起来是“反转”的**。这其实是两种操作的本质逻辑不同导致的\n\n\n\n## 解释结论\n\n我觉得下面解释的还是有点不好理解。以下是我**个人的理解**。从模拟过程和bool返回值来分析。\n\n我们在**排序**一个数组{a,b,c,d}的时候，如果是自己去实现排序（升序）的功能，大致的思路是，**从头到尾**每次遍历两个元素，如果a>b，less返回false不满足less函数的x<y。不满足升序要求，需要交换两个数的位置，使其要满足x<y。所以是从小到大，升序。\n\n对于 `std::sort` 默认使用的升序排序，它会判断 `less(x, y)` 是否为 true，即 `x < y`。如果返回 **false**，说明当前两个元素顺序**不对**，就会交换，从而实现升序排列。\n\n如果是**priority_queue**，priority_queue不是算法，是容器适配器，是优先级队列。**它的“优先级”是由 Compare 来定义的。**它需要在编译期确定比较器类型，并实例化一个对象在内部反复调用，它初始化的时候就要确定Compare是什么。因为priority_queue<T,Container,Compare>。Compare去决定它的优先级设置方法。\n\n想象一下在priority_queue（大顶堆）插入一个新元素a，从队尾push，priority_queue会更具Compare（less）制定的排序规则判断优先级。如果是a<top，那less返回true，就不用交换两个数的位置。所以是大顶堆\n\n比如你用 `less<int>`，即 `x < y`，那么在比较时，如果 **`less(a, top)` == true**，说明 a 比 top 小，优先级低，就不需要上浮 a；\n\n如果 **`less(top, a)` == true**，说明 a 优先级高（大顶堆），需要上浮。\n\n### **排序（`std::sort`）**\n\n默认行为：`std::less<T>` → **升序**\n\n```\nstd::vector<int> v = {3, 1, 4, 2};\nstd::sort(v.begin(), v.end(), std::less<int>()); // 默认就是升序\n// 结果：1, 2, 3, 4\n```\n\n- **比较逻辑**：`std::less` 比较 `a < b`，**如果 `true`，则 `a` 应该排在 `b` 前面。**\n- **效果**：较小的元素在前，整体是升序。\n\n使用 `std::greater<T>` → **降序**\n\n```\nstd::sort(v.begin(), v.end(), std::greater<int>());\n// 结果：4, 3, 2, 1\n```\n\n- **比较逻辑**：`std::greater` 比较 `a > b`，如果 `true`，则 `a` 应该排在 `b` 前面。\n- **效果**：较大的元素在前，整体是降序。\n\n**结论**：在排序中，`std::less` → 升序，`std::greater` → 降序，符合直觉。\n\n\n\n### **建堆（`std::priority_queue` 或堆算法）**\n\n默认行为：`std::less<T>` → **大顶堆**\n\n```\nstd::priority_queue<int> pq; // 默认是 std::less<int>，大顶堆\npq.push(3); pq.push(1); pq.push(4);\n// 弹出的顺序是 4, 3, 1\n```\n\n- **堆的性质**：父节点 >= 子节点（堆顶是最大值）。\n- **比较逻辑**：`std::less` 比较 `a < b`，**如果 `true`，则 `b` 优先级更高（会被放到堆顶）**。\n  - **为什么看起来是“反转”的？**\n    因为 `std::priority_queue` 的设计是“优先级高的先弹出”，而默认情况下它用 `std::less` 来决定谁“优先级更高”。\n  - 默认 `std::less` 表示“更小的值优先级更低”，因此更大的值优先级更高，会放在堆顶。\n    - 如果 `a < b` 为 `true`，说明 `b` 比 `a` 大，所以 `b` 应该排在更前面（堆顶）。\n\n使用 `std::greater<T>` → **小顶堆**\n\n```\nstd::priority_queue<int, std::vector<int>, std::greater<int>> pq; // 小顶堆\npq.push(3); pq.push(1); pq.push(4);\n// 弹出的顺序是 1, 3, 4\n```\n\n- **堆的性质**：父节点 <= 子节点（堆顶是最小值）。\n- **比较逻辑**：**`std::greater` 比较 `a > b`，如果 `true`，则 `b` 优先级更高（会被放到堆顶）。**\n  - 如果 `a > b` 为 `true`，说明 `b` 比 `a` 小，所以 `b` 应该排在更前面（堆顶）。\n\n**结论**：在建堆中，`std::less` → 大顶堆，`std::greater` → 小顶堆，看起来和排序是“反转”的。\n\n\n\n\n\n\n\n\n\n# 自定义\n\n符合两个条件：\n\n​\tbool：返回值bool\n​\treturn x<y;：重载<之类的操作符，并且要决定比较什么元素。\n​\tPS：建议还要常引用，保险，禁止发生修改要比较的元素可能。\n\n## 数组\n\n**函数：使用时不加括号，加了报错。写成 `bool cmp(const T&, const T&)` 是因为 `sort` 要传入一个 **函数指针**。**\n**类的对象（仿函数）：注意，排序时的类必须使用类的对象才对，直接使用类报错。重载 `()` 是因为 `sort` 接受“可调用对象”，仿函数对象本质上是**重载了括号运算符的类对象**。**不能传入类名，而是类的实例**：类名是类型，不能调用 `operator()`，而类对象才是“可调用的”。**\n\n\n\n```\n#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\n// 重写排序函数\nbool cmpfunc(const int &a, const int &b)\n{\n    return a < b;\n    // < 升序; > 降序\n}\n\n// 模仿less、greater构建类\nstruct cmpClass\n{\n    bool operator()(const int &i, const int &j)\n    {\n        return (i < j);\n    }\n}cmpClassObject;\t\t// 注意，排序时的类必须使用类的对象才对，使用类报错。\n\nint main()\n{\n\t// 使用函数\n    vector<int> v1 = {2, 3, 1, 6, 2, 5, 4};\n    // 使用时不加括号，加了报错\n    sort(v1.begin(), v1.end(), cmpfunc);\n    for (int i = 0; i < v1.size(); i++)\n    {\n        cout << v1[i] << \" \";\n    }\n    cout << endl;\n    // 1 2 2 3 4 5 6\n    \n    // 使用类的对象\n    vector<int> v2 = {2, 3, 1, 6, 2, 5, 4};\n    sort(v2.begin(), v2.end(), cmpClassObject);\n    for (int i = 0; i < v2.size(); i++)\n    {\n        cout << v2[i] << \" \";\n    }\n    cout << endl;\n    // 1 2 2 3 4 5 6\n    return 0;\n```\n\n\n\n## 优先级队列\n\n### `priority_queue<T, Container, Compare>`\n\n这里 `Compare` 是一个**仿函数类型**，用于控制“谁优先”。\n\n比较对象 **必须是 `()` 重载形式**（即仿函数），因为 STL 库底层会调用 `comp(a, b)`。\n\n### 为什么 `priority_queue` 的比较器不能写成函数？\n\n因为它需要在编译期确定比较器类型，并实例化一个对象在内部反复调用：\n\n```\npriority_queue<T, vector<T>, cmpClass> q;\n```\n\n\n\n- 定义类时同时定义**操作符重载函数**：操作符重载函数，必须是具体的**操作符<**之类的，写()报错------一个自定义类 重载函数<在类内\n- 自定义类，**自定义比较函数**：操作符重载函数，必须是具体的**操作符<**之类的，写()报错---------------一个自定义类  重载函数<在类外\n- 自定义类，自定义包含**比较函数的结构体**：**操作符重载函数，必须是写()**-----------------------------------一个自定义类，一个比较函数的结构体（）\n\n```\n#include <iostream>\n#include <queue>\nusing namespace std;\n\n/******** 定义类时同时定义操作符重载函数 ********/\nstruct Node1\n{\n    // 要比较的元素\n    int x;\n    // 构造函数\n    Node1(int x) { this->x = x; }\n    // 操作符重载函数，必须是具体的操作符<之类的，写()报错\n    bool operator<(const Node1 &b) const\n    {\n        // 实现less中需要的<,大顶堆\n        return x < b.x;\n    }\n};\n\n/******** 自定义类，自定义比较函数 ********/\nstruct Node2\n{\n    // 要比较的元素\n    int x;\n    // 构造函数\n    Node2(int x) { this->x = x; }\n};\n\n// 操作符重载函数，必须是具体的操作符<之类的，写()报错\nbool operator<(const Node2 &a, const Node2 &b)\n{\n    // less,大顶堆\n    return a.x < b.x;\n}\n\n/******** 自定义类，自定义包含比较函数的结构体 ********/\nstruct Node3\n{\n    // 要比较的元素\n    int x;\n    // 构造函数\n    Node3(int x) { this->x = x; }\n};\n\nstruct cmpClass\n{\n    // 操作符重载函数，必须是写()\n    bool operator()(const Node3 &a, const Node3 &b)\n    {\n        // less,大顶堆\n        return a.x < b.x;\n    }\n};\n\nint main()\n{\n    /******** 初始化优先级队列的对象p ********/\n    // Node1类型，默认使用vector，小顶堆，同 priority_queue<Node1, vector<Node1>, less<Node1> > p;\n    priority_queue<Node1> p;\n    // 乱序入队\np.emplace(1);\np.emplace(3);\np.emplace(2);\n\n// 弹出队首\nwhile (!p.empty())\n{\n    cout << p.top().x << \" \";\n    p.pop();\n}\ncout << endl;\n// 3 2 1\n\n/******** 初始化优先级队列的对象q ********/\n// 同 priority_queue<Node2> q;\npriority_queue<Node2, vector<Node2>, less<Node2>> q;\n\n// 乱序入队\nq.emplace(1);\nq.emplace(3);\nq.emplace(2);\n\n// 弹出队首\nwhile (!q.empty())\n{\n    cout << q.top().x << \" \";\n    q.pop();\n}\ncout << endl;\n// 3 2 1\n\n/******** 初始化优先级队列的对象r ********/\npriority_queue<Node3, vector<Node3>, cmpClass> r;\n\n// 乱序入队\nr.emplace(1);\nr.emplace(3);\nr.emplace(2);\n\n// 弹出队首\nwhile (!r.empty())\n{\n    cout << r.top().x << \" \";\n    r.pop();\n}\ncout << endl;\n// 3 2 1\nreturn 0;\n```\n\n\n参考：[C++：std::greater()、std::less()、自定义比较函数的规则-CSDN博客](https://blog.csdn.net/sandalphon4869/article/details/105419706)\n","tags":["C++","堆","排序","优先队列","priority_queue","比较函数"],"categories":["C++"]},{"title":"堆(heap)结构","url":"/2025/07/28/堆结构/","content":"\n<!--more-->\n\n","tags":["数据结构","完全二叉树","堆"],"categories":["数据结构"]},{"title":"priority_queue","url":"/2025/07/28/priority-queue/","content":"\n<!--more-->\n\n参考：[C++ STL priority_queue容器适配器详解 - C语言中文网](https://c.biancheng.net/view/6987.html)\n\n[代码随想录](https://www.programmercarl.com/0347.前K个高频元素.html#算法公开课)\n\n## **优先级队列**\n\n### 以下参考代码**随想录**\n\n什么是优先级队列呢？\n\n其实**就是一个披着队列外衣的堆**，因为优先级队列对外接口只是从队头取元素，从队尾添加元素，再无其他取元素的方式，看起来就是一个队列。\n\n而且优先级队列内部元素是自动依照元素的权值排列。那么它是如何有序排列的呢？\n\n缺省情况下priority_queue利用max-heap（大顶堆）完成对元素的排序，这个大顶堆是以vector为表现形式的complete binary tree（完全二叉树）。\n\n什么是堆呢？\n\n**堆是一棵完全二叉树，树中每个结点的值都不小于（或不大于）其左右孩子的值。** 如果父亲结点是大于等于左右孩子就是大顶堆，小于等于左右孩子就是小顶堆。\n\n所以大家经常说的大顶堆（堆头是最大元素），小顶堆（堆头是最小元素），如果懒得自己实现的话，就直接用priority_queue（优先级队列）就可以了，底层实现都是一样的，从小到大排就是小顶堆，从大到小排就是大顶堆。\n\n\n\n### 以下参考**C语言中文网**\n\npriority_queue 容器适配器模拟的也是队列这种存储结构，即使用此容器适配器存储元素只能“从一端进（称为队尾），从另一端出（称为队头）”，且每次只能访问 priority_queue 中位于队头的元素。\n\n但是，priority_queue 容器适配器中元素的存和取，遵循的并不是 “First in,First out”（先入先出）原则，而是“**First in，Largest out**”原则。直白的翻译，指的就是先进队列的元素并不一定先出队列，而是优先级最大的元素最先出队列。\n\n> 注意，“First in，Largest out”原则是笔者为了总结 priority_queue 存取元素的特性自创的一种称谓，仅为了方便读者理解。\n\n那么，priority_queue 容器适配器中存储的元素，优先级是如何评定的呢？很简单，每个 priority_queue 容器适配器在创建时，都制定了一种排序规则。根据此规则，该容器适配器中存储的元素就有了优先级高低之分。\n\n举个例子，假设当前有一个 priority_queue 容器适配器，其制定的排序规则是按照元素值从大到小进行排序。根据此规则，自然是 priority_queue 中值最大的元素的优先级最高。\n\npriority_queue 容器适配器为了保证每次从队头移除的都是当前优先级最高的元素，每当有新元素进入，它都会根据既定的排序规则找到优先级最高的元素，并将其移动到队列的队头；同样，当 priority_queue 从队头移除出一个元素之后，它也会再找到当前优先级最高的元素，并将其移动到队头。\n\n基于 priority_queue 的这种特性，因此该容器适配器有被称为**优先级队列**。\n\n> priority_queue 容器适配器“First in，Largest out”的特性，和它底层采用**堆结构**存储数据是分不开的。有关该容器适配器的底层实现，后续章节会进行深度剖析。\n\n[STL](https://c.biancheng.net/stl/) 中，priority_queue 容器适配器的定义如下：\n\n```\ntemplate <typename T,\n        typename Container=std::vector<T>,\n        typename Compare=std::less<T> >\nclass priority_queue{\n    //......\n}\n```\n\n可以看到，priority_queue 容器适配器模板类最多可以传入 3 个参数，它们各自的含义如下：\n\n- typename T：指定存储元素的具体类型；\n\n- typename Container：指定 priority_queue 底层使用的基础容器，默认使用 vector 容器。\n\n  > 作为 priority_queue 容器适配器的底层容器，其必须包含 empty()、size()、front()、push_back()、pop_back() 这几个成员函数，[STL](https://c.biancheng.net/stl/) 序列式容器中只有 vector 和 deque 容器符合条件。\n\n- typename Compare：指定容器中评定元素优先级所遵循的排序规则，默认使用\n\n  ```\n  std::less<T>\n  ```\n\n  ##### 按照元素值从大到小进行排序，还可以使用\n\n  ```\n  std::greater<T>\n  ```\n\n  按照元素值从小到大排序，但更多情况下是使用自定义的排序规则。\n\n  > 其中，std::less<T> 和 std::greater<T> 都是以函数对象的方式定义在 <function> 头文件中。关于如何自定义排序规则，后续章节会做详细介绍。\n\n#### 创建priority_queue的几种方式\n\n由于 priority_queue 容器适配器模板位于`<queue>`头文件中，并定义在 std 命名空间里，因此在试图创建该类型容器之前，程序中需包含以下 2 行代码：\n\n```\n#include <queue>\nusing namespace std;\n```\n\n创建 priority_queue 容器适配器的方法，大致有以下几种。\n\n1) 创建一个空的 priority_queue 容器适配器，第底层采用默认的 vector 容器，排序方式也采用默认的 std::less<T> 方法：\n\n```\nstd::priority_queue<int> values;\n```\n\n2) 可以使用普通数组或其它容器中指定范围内的数据，对 priority_queue 容器适配器进行初始化：\n\n```\n//使用普通数组\nint values[]{4,1,3,2};\nstd::priority_queue<int>copy_values(values,values+4);//{4,2,3,1}\n//使用序列式容器\nstd::array<int,4>values{ 4,1,3,2 };\nstd::priority_queue<int>copy_values(values.begin(),values.end());//{4,2,3,1}\n```\n\n注意，**以上 2 种方式必须保证数组或容器中存储的元素类型和 priority_queue 指定的存储类型相同**。另外，用来初始化的数组或容器中的数据不需要有序，priority_queue 会自动对它们进行排序。\n\n3) 还可以手动指定 priority_queue 使用的底层容器以及排序规则，比如：\n\n```\nint values[]{ 4,1,2,3 };\nstd::priority_queue<int, std::deque<int>, std::greater<int> >copy_values(values, values+4);//{1,3,2,4}\n```\n\n事实上，std::less<T> 和 std::greater<T> 适用的场景是有限的，更多场景中我们会使用自定义的排序规则。\n\n> 由于自定义排序规则的方式不只一种，因此这部分知识将在后续章节做详细介绍。\n\n\n\n#### priority_queue提供的成员函数\n\npriority_queue 容器适配器提供了表 2 所示的这些成员函数。\n\n\n\n| 成员函数                       | 功能                                                         |\n| ------------------------------ | ------------------------------------------------------------ |\n| empty()                        | 如果 priority_queue 为空的话，返回 true；反之，返回 false。  |\n| size()                         | 返回 priority_queue 中存储元素的个数。                       |\n| top()                          | 返回 priority_queue 中第一个元素的引用形式。                 |\n| push(const T& obj)             | 根据既定的排序规则，将元素 obj 的副本存储到 priority_queue 中适当的位置。 |\n| push(T&& obj)                  | 根据既定的排序规则，将元素 obj 移动存储到 priority_queue 中适当的位置。 |\n| emplace(Args&&... args)        | Args&&... args 表示构造一个存储类型的元素所需要的数据（对于类对象来说，可能需要多个数据构造出一个对象）。此函数的功能是根据既定的排序规则，在容器适配器适当的位置直接生成该新元素。 |\n| pop()                          | 移除 priority_queue 容器适配器中第一个元素。                 |\n| swap(priority_queue<T>& other) | 将两个 priority_queue 容器适配器中的元素进行互换，需要注意的是，进行互换的 2 个 priority_queue 容器适配器中存储的元素类型以及底层采用的基础容器类型，都必须相同。 |\n\n> 和 queue 一样，priority_queue 也没有迭代器，因此访问元素的唯一方式是遍历容器，通过不断移除访问过的元素，去访问下一个元素。\n\n\n\n\n\n## 在 C++ 中，`emplace` 和 `push` 的区别\n\n`emplace` 和 `push` 都可以用来向容器中添加元素，但它们的工作方式有所不同。在这个特定的代码中，使用 `emplace` 比 `push` 更高效，原因如下：\n\n###  **`emplace` 直接构造元素**\n\n- `q.emplace(nums[i], i)` 会直接在优先队列的内存中构造一个 `pair<int, int>` 对象，避免了临时对象的创建和拷贝/移动操作。\n- 它等价于 `q.push(std::pair<int, int>(nums[i], i))`，但更高效，因为 `emplace` 直接在容器内部构造对象，省去了额外的拷贝或移动开销。\n\n### **`push` 需要构造临时对象**\n\n- 如果使用 `push`，你需要显式构造一个 `pair` 对象，如 `q.push(make_pair(nums[i], i))` 或 `q.push({nums[i], i)})`。\n- 这会先创建一个临时 `pair` 对象，然后将其拷贝或移动到优先队列中，多了一次不必要的构造和拷贝/移动操作。\n\n### **性能优势**\n\n- 对于像 `pair<int, int>` 这样的简单类型，`emplace` 和 `push` 的性能差异可能不大，但在更复杂的场景（如构造含多个参数的对象）时，`emplace` 能显著减少开销。\n- 由于 `emplace` 是 C++11 引入的优化方式，它更符合现代 C++ 的高效编程风格。\n\n### 代码对比\n\ncpp\n\n```\n// 使用 emplace（推荐）\nq.emplace(nums[i], i);  // 直接在优先队列中构造 pair\n\n// 使用 push（需要构造临时对象）\nq.push(std::make_pair(nums[i], i));  // 先构造临时 pair，再拷贝/移动到队列\n```\n","tags":["C++","C++基础","STL","容器适配器"],"categories":["C++"]},{"title":"C++数字与字符串互相转换","url":"/2025/07/28/C-零碎知识/","content":"\n<!--more-->\n\n\n\n# C/C++数字与字符串互相转换\n\n参考：原文链接：https://blog.csdn.net/m0_73633807/article/details/140817283\n\n### 字符串转为数字\n\n#### 一、利用ASCII\n\n我们知道每个字符都有一个ASCII码，利用这一点可以将字符-'0'转为数字。在[字母大小写转换](https://so.csdn.net/so/search?q=字母大小写转换&spm=1001.2101.3001.7020)时也可以利用这个性质。\n\n![图片](C-零碎知识/ASCII.png)\n\n```\n#include<iostream>\n#include<cstring>\nusing namespace std;\nchar ch[]={'1','2','3','4','5'};\nint main(){\n\tfor(int i=0;i<strlen(ch);i++){\n\t\tcout<<ch[i]-'0'<<\" \";\n\t}\n\treturn 0;\n}\n```\n\n#### 二、stoi()\n\n**stoi**函数是C++标准库中的一个函数，用于将字符串转换为整数，针对于string类型的。stoi函数是C++11引入的，因此只有在C++11及以上的版本中才能使用该函数。如果你的编译器版本较老，不支持C++11，那么就无法使用stoi函数。学校机房的dev-C++一般是C98标准的，需要自己手动改成C11。\n\n```\nint num=stoi(const string&  str, size_t* idx = 0, int base = 10);\n```\n\n其中，str是需要转换的字符串；idx是一个指向size_t类型的指针，用于保存转换结束的位置；base是进制，默认为10进制。一般只给传第一个参数即可，也可以利用此函数实现进制转换。\n\n类似的还有**stol()、stof()、stod(),**分别将字符串类型转换成long long、float、double类型。\n\n\n```\n#include<iostream>\n#include<cstring>\n \nusing namespace std;\nstring s=\"12345\";\nint main(){\n\tint a=stoi(s);\n\tlong long b=stol(s);\n\tdouble c=stod(s);\n\tfloat d=stof(s);\n\tcout<<\"int:\"<<a<<endl;\n\tcout<<\"long long:\"<<b<<endl;\n\tcout<<\"double:\"<<c<<endl;\n\tcout<<\"float:\"<<d<<endl;\n\treturn 0;\n}\n```\n\n#### 三、atoi()\n\natoi()函数是C语言中的一个函数，主要用于将字符串转换为整数。针对于字符数组,类似的还有atol()、atof()、atod()。\n\n```\nint num=atoi(const char *str);\n```\n\n其中，str是一个以null结尾的字符串，表示要转换的整数。\n\n该函数将从字符串的开头开始解析，直到遇到第一个非数字字符为止。如果开头是一个正号或负号，它也会解析为整数的一部分。如果字符串中的第一个非空格字符不是有效的数字字符或正负号，则返回0。\n\n#### 四、sscanf()\n\nsscanf函数是一个用来将字符串按照指定格式解析的函数。它接受一个输入字符串和一个格式字符串作为参数，并根据格式字符串的指示将字符串中的数据解析为对应的变量中。主要是针对于字符数组。\n\n```\nsscanf(str,\"%d\",&num);//str字符数组,%dint类型,num转换完成数字\n```\n\n#### 五、stringstream\n\nstringstream是C++中的一个类，可以用来对字符串进行输入输出操作。它是基于字符串的流，可以用来将字符串转换为其他类型的数据，以及将其他类型的数据转换为字符串。stringstream类的头文件是<sstream>，我们需要包含这个头文件才能使用stringstream类。\n\n```\n#include<iostream>\n#include<sstream>\n#include<cstring>\n#include<typeinfo>\n \nusing namespace std;\nint main(){\n\tstringstream ss;\n\tstring s=\"12345\";\n\tint num;\n\tss<<s;//将字符串读入字符串流 \n\tss>>num;//从字符串流中读取数据转换为整数\n\tcout<<typeid(num).name()<<\" \"<<num<<endl;\n\treturn 0; \n}\n```\n\n\n\n### 数字转为字符串\n\n#### 一、利用ASCII\n\n字符转数字可以-'0'，数字转字符那么就可以+'0'，还是利用了ASCII码值的特性。\n\n```\n#include<iostream>\n#include<cstring>\nusing namespace std;\nint nums[]={1,2,3,4,5};\nint main(){\n\tfor(int i=0;i<sizeof(nums)/sizeof(int);i++){\n\t\tcout<<nums[i]+'0'<<\" \";\n\t}\n\treturn 0;\n}\n```\n\n注意：转换结果为49 50 51 52 53 ，对应ASCII码值，因为原理就是用[ASCII码转换](https://so.csdn.net/so/search?q=ASCII码转换&spm=1001.2101.3001.7020)的。\n\n#### 二、to_string()\n\nto_string函数是C++标准库提供的一个函数，用于将不同类型的数据转换为字符串。可以将int、float、double、long long等类型转换为string类型。**需要包含头文件#include<cstring>**\n\n```\n#include<iostream>\n#include<cstring>\nusing namespace std;\nint a=24;\nlong long b=12345678;\ndouble c=3.1415;\nstring s;\nint main(){\n\ts=to_string(a);\n\tcout<<s<<endl;\n\ts=to_string(b);\n\tcout<<s<<endl;\n\ts=to_string(c);\n\tcout<<s<<endl;\n\treturn 0;\n}\n```\n\n#### 三、itoa()\n\nitoa函数用于将整数转换为字符串。类似的还有ltoa、ftoa、dtoa分别将long long、float、double转换为字符串类型。针对于字符数组。\n\n```\nitoa(num,str,10);\n```\n\n第一个参数是待转换的数字，第二个参数是转换完成的字符数组，第三个是转换的进制数，默认10进制。\n\n```\n#include<iostream>\n#include<cstring>\nusing namespace std;\nint n=12345;\nchar str[10];\nint main(){\n\titoa(n,str,10); \n\tcout<<str<<endl;\n\treturn 0;\n}\n```\n\n#### 四、sprintf()\n\nsprintf()函数是c语言库中的函数，可以将数字转换为字符串类型，一般转换为字符数组。\n\n```\nsprintf(str,\"%d\",num);\n```\n\nstr是转换完成的字符数组，%d是类型，num是待转换的数字。 \n\n```\n#include<iostream>\n#include<cstring>\nusing namespace std;\nint n=12345;\nchar str[10];\nint main(){\n\tsprintf(str,\"%d\",n); \n\tcout<<str<<endl;\n\treturn 0;\n}\n```\n\n#### 五、stringstream\n\n与字符串转数字的一样，可以互相转换，同时还是要包含**头文件<sstream>，具体使用如下**\n\n```cpp\n#include<iostream>\n#include<sstream>\n#include<cstring>\n#include<typeinfo>\n \nusing namespace std;\nint main(){\n\tstringstream ss;\n\tstring s=\"12345\";\n\tint num=54321;\n\tss<<num;//将int类型的数据写入字符串流中\n\ts=ss.str();//将字符串流中的数据转换为string类型\n\tcout<<typeid(s).name()<<\" \"<<num<<endl;\n\treturn 0; \n}\n```\n\n\n\n\n\n# 个人总结：\n\n在C++中：\n\n**字符串转数字**：常用ASCII、stoi()\\stod()\\stol()\\stoll()。 ASCII只能是一位数字，stoi()\\stod()\\stol()\\stoll()适用于各种类型。\n\nstoi-----string to int\n\n\n\n**数字转为字符串**：常用ASCII、**to_string()**（要包含头文件#include<cstring>）\n","tags":["C++","刷题"],"categories":["C++"]},{"title":"无法打开“mscoree.lib”错误","url":"/2025/07/24/无法打开“mscoree-lib”错误/","content":"\n\n\n<!--moore-->\n\n需要在下载VS的时候加插件\n\n下载了的也可以直接打开VS Install修复\n\n![图片](无法打开“mscoree-lib”错误/2.png)\n\n\n\n需要添加\n\n![图片](无法打开“mscoree-lib”错误/1.jpg)\n\n\n\n同时，我还安装了.NET Framework 4.8 SDK\n\n在单个组件里面。\n","tags":["C++","VS","C#","hsl库"],"categories":["报错"]},{"title":"QtInstallation问题","url":"/2025/07/24/QtInstallation问题/","content":"\n\n\n<!--more-->\n\n​\t在安装好VS2019和Qt5.14.2之后，我准备跑之前的代码，打开代码之后vs提示的错误如下：\n\n![图片](QtInstallation问题/1.png)\n\n\n\n这里主要解决第一个。\n\nThe project's'Qt Installation' property is not set correctly.Please specify a valid Qt version or path.\n\n\n\n在vs 点击“扩展“ --> ”Qt VS Tools“--->\"Qt Versions\"或者\"Options\"\n\n![图片](QtInstallation问题/2.png)\n\n\n\n在name 输入 自己qt的版本 和操作系统位数\n\n在Location 选择qt的安装路径\n\n​\t进入选择对话框后，按照安装路径进入以下文件夹，选择qmake.exe,点击打开\n\n注意： 这里要区分32位和64位\n\n![图片](QtInstallation问题/3.png)\n","tags":["Qt","QtInstallation","VS2019"],"categories":["Qt"]},{"title":"安装win11系统","url":"/2025/07/24/安装win11系统/","content":"\n<!--more-->\n\n 安装win11系统。\n\n参考的视频[【干货】WIN11系统安装重装教程、全程干货13分钟搞定，小白也能自己重装系统！超详细解说~_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1oG4y1d7Dv/?spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=a858a9df12a9613b40ef1eefb011b473)\n\n\n\n\n\n# 1.在U盘下载好系统\n\n## 1.1格式化U盘\n\n\n\n## 1.2搜索win11 进入官方网站\n\n[下载 Windows 11](https://www.microsoft.com/zh-cn/software-download/windows11)\n\n\n\n![图片](安装win11系统/1.png)\n\n\n\n下载第二个\n\n![图片](安装win11系统/Snipaste_2025-07-24_16-16-13.png)\n\n\n\n会下载一个文件，下载好之后打开 按照提示下载到U盘\n\n\n\n# 2.搜索电脑启动BIOS的快捷键\n\n最快的办法是百度搜索或者直接问客服\n\n联想ThinkPad 是 F12 \n\n\n\n \n\n# 3.在打开电脑但是并没有开机的时候狂按快捷键，使用U盘启动\n\n\n\n# 4.点击下一步即可\n\n这里选择第二个\n\n![图片](安装win11系统/2.png)\n\n分区可以先全部删除，进入系统之后再分区\n\n系统盘建议安装在ssd固态硬盘\n\n\n\n# 5.跳过联网\n\nshift + F10\n\n输入 oobe\\bypassnro.cmd\n\n回车之后电脑会重启\n\n之后可以进行分区和联网下载电脑驱动\n","tags":["电脑刷机"],"categories":["安装win11"]},{"title":"hexo如何添加图片","url":"/2025/07/07/hexo如何添加图片/","content":"\n\n<!--more-->\n\n\n\n\n参考Kathy's Blog [在hexo博客中插入图片的方法 | Kathy's Blog](https://kathy-kx.github.io/2023/04/16/在hexo博客中插入图片的方法/)\n\n## 如果图片保存在本地\n\n### 方法一：全局资源文件夹\n\n即，将所有文章的资源统一用一个全局资源文件夹管理。\n此方法的优点是比较**简便**，并且当多篇文章需要引用同一资源时，也比较方便。缺点是当文章很多时，各个文章的图片都在同一文件夹，**不便管理**。\n具体方法：\n在hexo文件夹下的source目录下，新建一个文件夹叫images(名字随意)，将要插入的图片放在该文件夹中。\nmd文档内，使用`![图片](图片链接地址 \"图片title\")`的格式，圆括号内的链接地址写(/images/name.jpeg)。\n这里的 / 指的是根目录，对于hexo，资源文件的根目录就是source。\n例如，在md文档中写：\n`![图片](/images/20.jpeg \"甘雨\")`\n同时将“20.jpeg”这个图片文件放在hexo文件夹/source/images下。\n\n---这个我没有使用\n\n\n\n### 方法二：文章资源文件夹\n\n即，对于每篇文章，使用一个文件夹管理资源。\n此方法的优点是，当文章很多时，**便于结构化管理**。缺点是，比方法一麻烦一点。\n具体方法：\n2.1 修改hexo文件夹中的_config.yml文件，如下：\n\n```\npost_asset_folder: true\nmarked:\n  prependRoot: true\n  postAsset: true\n```\n\n2.2 在终端cd到hexo文件夹，`hexo new [layout] <title>` 命令创建一篇新文章，此时会在hexo文件夹的source目录下，自动创建一个文件夹和.md文件。\n注：这句命令中的layout可暂时不写，使用默认的。title就是你的新文章的名字。如果文章名中有**空格**，务必将整个文章名用双引号引起来。如果文章名中没有空格，可以加双引号，也可以不加。\n例如，执行`hexo new \"hexo如何添加图片\"`，如下：\n\n![图片](hexo如何添加图片/1.png)\n\n\n\n会在source/_post文件夹下生成一个”hexo如何添加图片.md”文件。同时还生成了一个同名的资源文件夹。\n\n2.3 我们可以将所有与该文章有关的资源（包括图片）放在这个关联文件夹中\n2.4 通过相对路径来引用图片资源。\n例如，将“1.jpeg”这个图片资源放在该文件夹中，并在.md文件中像这样引用图片：`![图片](1.jpeg)`，这个方法在资源较多时方便管理。\n\n如下图所示写\n\n![图片](hexo如何添加图片/2.png)\n\n注意：要注意斜杠的方向是/ 不是\\\n\n\n\n\n\n另附**Typora编辑器中不显示图片**的解决方案：\n安装下面的插件，可以使Typora等Markdown编辑器预览以及Hexo发布预览时，均能正常显示图片。\n`npm install hexo-asset-img --save`\n这样，如果你使用Typora编辑markdown文档，在typora内也可以显示图片了。\n","tags":["hexo"],"categories":["hexo"]},{"title":"HEXO的Next主题设置以及个性化设置","url":"/2025/07/05/HEXO的Next主题设置以及个性化设置/","content":"\n<!--more-->\n\n在已经搭建Hexo个人博客的基础上，设置next的主题和个性化设置。\n\n搭建Hexo个人博客可以参考Fiveth的博客“如何用Hexo搭建个人博客”。[如何用Hexo搭建个人博客?](https://blog.fiveth.cc/p/bb32/)\n\n\n\n# 1.设置next主题\n\n进入hexo官网，点击“主题”，在搜索的地方输入“next”，点击“nexT”进入到github里面。下面有官方的详细安装介绍。\n\n我使用的是 clone ssh的方法。将文件夹放在themes目录下。\n\n然后在 _config.yml 文件设置theme: next\n\n最后hexo clean && hexo g && hexo s\n\n即可生成\n\n注意：这里的theme: next应该与文件夹的名称相同，如果下载的文件是hexo-theme-next，可以改文件夹的名称也可以改theme: next为 theme: hexo-theme-next\n\n\n\n# 2.个性化next主题\n\n根据clone下来的next文件里面的 _config.yml 可以得知\n\n===============================================================\n\nIt's recommended to use Alternate Theme Config to configure NexT\n\nModifying this file may result in merge conflict\n\nSee: https://theme-next.js.org/docs/getting-started/configuration\n\n===============================================================\n\nTheme Core Configuration Settings\n\nSee: https://theme-next.js.org/docs/theme-settings/\n\n\n\n进入网站可以知道，NexT 目前支持两种推荐的配置方式，你只需要**选择其中一种**：\n\n​\t传统方式是修改 `themes/next/_config.yml`，但这个文件会在更新主题时被覆盖，所以 NexT 主题现在推荐使用 **Hexo 的“主题配置重载（Alternate Theme Config）”功能**。\n\n​\t它允许你在 Hexo 根目录创建一个 `_config.[theme_name].yml` 文件（NexT 默认的 theme 名是 `next`，所以就是 `_config.next.yml`）。\n\n​\tHexo 会优先加载这个文件的配置，并覆盖掉默认的主题配置。\n\n\n\n​\t**theme_config 模式** —— 把 NexT 配置直接写在主配置文件 `_config.yml` 中。\n\n我使用的第一种方法。将其copy即可。\n\n```\n# Installed through npm\ncp node_modules/hexo-theme-next/_config.yml _config.next.yml\n# Installed through Git\ncp themes/next/_config.yml _config.next.yml\n```\n\n\n\n## 2.1设置Scheme\n\n\\# Schemes\n\n\\#scheme: Muse\n\n\\#scheme: Mist\n\n\\#scheme: Pisces\n\nscheme: Gemini\n\n取消井号键即可，其他的注释掉。\n\n\n\n## 2.2设置分类和标签以及关于\n\n在博客根目录下打开git bash here \n\n```\nhexo new page categories\nhexo new page tags\nhexo new page about\n```\n\n然后找到blog/source/categories/index.md\n\n路径下的index.md文件\n\n```\n---\ntitle: 分类\ndate: 2025-07-04 15:16:40\ntype: \"categories\"\n---\n```\n\n```\n---\ntitle: 标签\ndate: 2025-07-04 15:16:23\ntype: \"tags\"\n---\n```\n\n之后写文章的时候添加即可。\n\n```\ntitle: HEXO的Next主题设置以及个性化设置\ndescription: 我的hexo界面设置\ndate: 2025-07-05 14:39:54\ntags:\n  - hexo\n  - next主题\ncategories:\n  - hexo\n```\n\n\n\n在about文件夹里面的index.md编辑就可以了。\n\n\n\n## 2.3设置阅读全文\n\n1.在文章中使用`< !--more-->` 手动进行截断\n\n2.文章简介可以写在开头\n\n```\ndescription: 我的hexo界面设置\n```\n\n3.在**主题配置文件**中添加 ，默认截取的长度为 150 字符，可以根据需要自行设定,直接复制到 _config 文件的底部\n\n```\nauto_excerpt:\n  enable: true\n  length: 150\n```\n\n\n\n## 2.4设置显示字数统计和阅读时长\n\n在博客目录下安装`npm install hexo-symbols-count-time --save`\n\n在`_config.yml`中加入配置\n\n```\nsymbols_count_time:\n #文章内是否显示\n  symbols: true\n  time: true\n # 网页底部是否显示\n  total_symbols: true\n  total_time: true\n```\n\n\n\n## 2.5设置站内搜索\n\n在博客目录下安装`npm install hexo-generator-searchdb --save`，此时使用`hexo cl && hexo g`就会在博客public目录下生成一个search.json，在使用`hexo d`部署上去搜索就可以用了\n\n```\nsearch:\n  path: search.json\n  field: post\n```\n\n在_config.next.yml\n\n里面将local_search: \n\n```\nlocal_search:\n  enable: true\n```\n\n","tags":["hexo","next主题"],"categories":["hexo"]},{"title":"DIY主机","url":"/2025/07/03/DIY主机/","content":"<!--more-->\n​\t刚刚结束自己主机的安装，来记录一下经验和历程，方便之后自己需要再次配主机或者帮朋友看配置。\n\n# 如何写适合自己的配置单\n+\n## 1.确定预算和需求\n\n​\t配电脑主机也是买东西，最重要的当然是准备花多少钱和主要用来干什么。\n\n​\t**预算**可以分为几个档：3000以下，3000-4000，4000-5000，5000-6000，以及更高。感觉不是重度生产力用户，在4000-5000都是够用的。我为什么这么说呢？因为10块和100块的东西使用差别可能很明显，像杂牌有线耳机和苹果有线耳机你用起来能够很明显的感受到区别。那100块的和1000块的呢？当然也有区别，但是在普通人的感官下没有10元和100元的大，还有更贵的耳机和1000元的对比，当然也有区别，但是我应该很难对比感受出来。从够用的情况来说5000左右的电脑主机已经非常够了。在这里我只讨论一手商品。\n\n​\t**需求**主要分为工作和游戏。\n\n​\t工作也有细分，以我写代码编程来说，我需要好一点点的CPU，更多的线程和更快的处理速度。至于其他的工作需求，我就不是很懂了。\n\n​\t游戏大概分为网游、单机、3a、fps。网游相对于其他的更加看重cpu一点。当然显卡也很重要。\n\n​\t**我的需求**：流程的编程，以及游戏，游戏主要玩英雄联盟和地平线4。所以我的cpu和显卡都不用特别好也不要特别差就可以了。\n\n​\t**我的预算：**4000-5000\n\n\n\n## 2.根据预算和需求写配置单\n\n### \t2.1主机有八大组成部分：**CPU、主板、散热、显卡、内存、硬盘、机箱、电源**\n\n​\t \tCPU：是电脑的处理器，用来处理数据\n\n​\t\t主板：我认为是整个电脑的载体，连接起整个电脑。\n\n​\t\t散热：散热主要是安装在CPU上面的散热，还有机箱风扇。顾名思义就是用来散热，让电脑不会太烫。\n\n​\t\t显卡：我认为主要作用就是和显示相关，比如游戏和三维建模的显示和加载速度。\n\n​\t\t内存：内存和我们平时问“欸，你手机多大内存？”的内存不一样，内存是电脑临时存储数据的地方，越大就放的越多处理越快。一般来说最好是双通道（也就是两根一起），现在常见的有8+8，16+16。内存有很多参数，比如颗粒，时序，频率。据我的了解，颗粒最重要，好的颗粒会更加耐用也更贵。时序是越小越好，频率是越高越好。但是！我觉得像我这种普通人C18的时序和C16时序，频率3200和3600很难用出区别。根据预算选择即可。\n\n​\t\t硬盘：就是电脑的存储空间。现在的内存分为固态硬盘和机械硬盘，固态的读写速度很快，体积也小，但是一但损坏数据不可恢复。机械硬盘读写速度相对于更慢，体积更大，数据更容易恢复。硬盘大小主要分为：512G，1T，2T。\n\n​\t\t机箱：能把这些配件装在一起的容器。要注意机箱能不能装下这些配件，根据预算选择，有海景房和普通的。\n\n​\t\t电源：电源是电脑的心脏，用来给电脑供电。最好稍微买大一点点。选择好一点的品牌。网上会有很多测评，选一个比较好的即可。\n\n\n\n​\t了解完八大件，就可以写配置单了。以我的预算为例：4000-5000，最后实际花费4500+\n\n### \t2.2首先确定 CPU、主板、显卡 三个（不分先后）。\n\n​\t\t**显卡：**一般来说**显卡**可能占到预算的50%左右，那我大概就是2000左右，显卡有N卡和A卡，N卡是英伟达生产的，A卡是AMD。N卡更贵一点，但是市面上很多游戏和软件更支持N卡，A卡便宜一些，但是有掉驱动的风险和市面支持度小于N卡。 \n\n​\t\t显卡由两大公司生产，然后下发给其他厂家组装。一线品牌有华硕、微星、技嘉（蓝宝石不知道算不算）。二线就是其他了。但是我认为区别不会很大，因为最核心的东西不是他们生产的，根据预算买就可以了。\n\n​\t\t我买的是A卡：7650gre 品牌蓝宝石 具体型号为7650gre极地版。2000左右的显卡都是入门级别也叫甜品卡。建议买新款显卡。pdd购入价格1889。\n\n​\t\t**CPU和主板：**CPU两大生产商为Intel和AMD，Intel在之前市场占有率大于AMD但是现在慢慢也差不多了。可以看CPU天梯图，但是我个人观察下来，觉得Intel的选择更多，和显卡一样，买新不买旧。主板可以和CPU一起买，价格会更便宜。一般来说，这两个的价格会差不多，也是根据预算选择，其实预算确定之后选择就比较少了。需要注意的是，主板能不能跑满cpu，怎么看呢？网上搜一下就知道了。其实我觉得主板还是比较重要的，它是整个电脑的载体，提供八大件接口。建议买华硕，微星，技嘉。\n\n​\t\t我买的13490f和技嘉的B760M GAMING AC DDR4一共1379，pdd平台购入。\n\n###  \t2.3 其他配件\n\n​\t\t内存：建议双通道，然后再选一个性价比比较高的即可。比如现在的DDR4比DDR5便宜很多。\n\n​\t\t硬盘：一定要有一个固态硬盘，用来安装系统。游戏和办公软件也建议安装在固态硬盘，最好是1T。选性价比高即可，这种很难用坏。也要注意颗粒，现在来说最好避免QLC颗粒。机械硬盘根据需求可加可不加。\n\n​\t\t散热：在网上看一下测评，选择一个使用得多并且品牌售后好的常用的即可。要注意能不能压住cpu的散热（搜索即可知道）。\n\n​\t\t机箱：在能把所有东西放进去的前提下，依据个人喜好选择。我比较重视机箱前面的接口数量和类型，但是我的主板并没有前置typeC的接口，很可惜我的价位没有这种配置。\n\n​\t\t电源：尽量选择网上评价好的，这一部分不能省钱。电源瓦数根据整个主机来算，不会算就可以看网上其他人差不多配置买多大的就可以了。电源品牌的选择也可以网上搜索评价较好的。\n\n​\t\t\n\n### \t2.4我的配置单\n\n![图片](DIY主机/装机配置.png)\n\n\n\n# 装机\n\n## 1.准备工作\n\n​\t要先熟悉整个装机的过程，推荐B站硬件茶谈和天才赵德驻，可以各看一遍，并且做好笔记。除了这些也可以去小红书，抖音搜索一些技巧。\n\n​\t还要吃饱饭！\n\n## 2.我的装机历程。\n\n我提前一天看了B站的视频并且做了步骤的PPT和注意事项，搜索了各大平台。\n\n主要参考豆瓣两位姐妹的文章\n\n[12600KF+5060成果展示！附从选购到点亮全流程经验](https://www.douban.com/group/topic/326821051/?_spm_id=OTM4NjgwMDE&dt_dapp=1&dt_platform=wechat_friends&_i=1534451iG_Juqn)\n\n[教你从0开始打造自己的电竞书桌——新手小白618装机全流程攻略](https://www.douban.com/group/topic/328560793/?_spm_id=MTQ4NzM5MzI0&dt_dapp=1&dt_platform=wechat_friends&_i=1534526iG_Juqn)\n\n\n\n我录制了每一个的拆箱视频。\n\n\n\nCPU-内存-硬盘-散热-显卡（暂时）-电源（全模组接线）--尝试点亮--拆掉显卡和电源线--拆机箱--安装主板--接线--安装显卡--安装风扇\n\n需要注意的是，主板供电的24pin接口特别难插拔，最好上下晃动不要左右。\n\n先点亮再接线\n\n点不了看赵德驻\n\n我是主板放进机箱之前点亮之后没有拆掉主板24pin的电线，直接接入主机，这样也很方便，觉得甚至cpu供电也可以这样因为cpu供电在主板进入机箱之后不好插。\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["装机","电脑","DIY"],"categories":["电脑"]},{"title":"第一篇博客","url":"/2025/07/02/第一篇博客/","content":"<!--more-->\n​\tDaiYueJuan.github.io这是我的博客网站！\n\n​\t这是我第一篇博客。记录一下为什么会有想写博客的念头。\n\n​\t在我研究生的学习过程之中，在我遇到问题的时候我会上网搜索。在CSDN，Google，百度，stackoverflow，还有GPT等等平台直到解决我遇到的问题。搜索的过程并不难，但是如果间隔很久再遇见同样的问题，我可能还是要整个平台再找一遍，这样效率很低。而人的记忆力也不是无限的，所以我决定写博客。\n\n    为什么选择hexo，hexo是部署在github上面的，不会像CSDN一样突然收费或者文章不可见，并且是免费的。\n\n​\t记录我在学习的笔记以及遇到的问题和解决方法。学习永无止境。\n\n"},{"title":"Hello World","url":"/2025/07/02/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n<!--more-->\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"}]